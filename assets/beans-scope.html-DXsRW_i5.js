import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as c,c as l,a as n,b as a,d as t,e}from"./app-CARt6Xo2.js";const i={},u=n("h1",{id:"bean作用域-scope",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#bean作用域-scope"},[n("span",null,"Bean作用域（Scope）")])],-1),r=n("p",null,"当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。",-1),d=n("code",null,"ApplicationContext",-1),k={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom",target:"_blank",rel:"noopener noreferrer"},g=e("<table><thead><tr><th>Bean作用域（Scope）</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>(默认) 在整个应用程序中只创建一个Bean实例</td></tr><tr><td>prototype</td><td>每次请求时，创建一个新的Bean实例</td></tr><tr><td>request</td><td>Web程序中，为每个HTTP请求创建一个Bean实例</td></tr><tr><td>session</td><td>Web程序中，为每个HTTP会话创建一个Bean实例</td></tr><tr><td>application</td><td>Web程序中，为每个<code>ServletContext</code>创建一个Bean实例</td></tr><tr><td>websocket</td><td>Web程序中，为每个<code>WebSocket</code>连接创建一个Bean实例</td></tr></tbody></table>",1),m={class:"hint-container note"},v=n("p",{class:"hint-container-title"},"注",-1),b={href:"https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/support/SimpleThreadScope.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom-using",target:"_blank",rel:"noopener noreferrer"},q=e(`<h2 id="单例作用域-singleton" tabindex="-1"><a class="header-anchor" href="#单例作用域-singleton"><span>单例作用域（singleton）</span></a></h2><p>单例作用域（singleton scope）是Spring框架中Bean定义的默认作用域。 当你将一个Bean定义为单例作用域时，对所有具有匹配ID或名称的Bean的调用都会返回这个特定的Bean实例。</p><p>下图说明了单例作用域：</p><figure><img src="http://img.geekyspace.cn/pictures/2024/singleton.png" alt="singleton" tabindex="0" loading="lazy"><figcaption>singleton</figcaption></figure><p>Spring的单例Bean概念与《设计模式》GoF（四人帮）书中定义的单例模式有所不同。</p><ul><li>GoF单例模式通过硬编码对象的作用域，确保每个类加载器（ClassLoader）下，仅有一个特定类的实例被创建</li><li>Spring单例的作用域最好被描述为每个容器（per-container）和每个bean（per-bean）</li></ul><p>单例作用域是Spring中的默认作用域。要在XML中将一个Bean定义为单例，参考按照以下示例：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- 以下是等效的冗余写法（因为单例作用域是默认的） --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>singleton<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原型作用域-prototype" tabindex="-1"><a class="header-anchor" href="#原型作用域-prototype"><span>原型作用域（prototype）</span></a></h2><p>原型作用域（prototype scope）的Bean部署，意味着每次请求该特定Bean时都会创建一个新的Bean实例。 也就是说，当一个Bean被注入到另一个Bean中，或者通过容器上的<code>getBean()</code>方法调用请求它，每次都会产生一个新的实例。 作为一项规则，将原型（prototype）作用域用于所有有状态的Bean，将单例（singleton）作用域用于无状态的Bean。</p><p>下图说明了原型作用域：</p><figure><img src="http://img.geekyspace.cn/pictures/2024/prototype.png" alt="prototype" tabindex="0" loading="lazy"><figcaption>prototype</figcaption></figure><p>（注意⚠️：以上图片中的数据访问对象（DAO）通常不配置为原型作用域，因为典型的DAO不持有任何会话状态。）</p><p>以下示例展示了如何在XML中将一个Bean定义为原型作用域：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>accountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.DefaultAccountService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prototype<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),f=n("code",null,"@PostConstruct",-1),x=n("code",null,"@PreDestroy",-1),S={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html#beans-factory-extension-bpp",target:"_blank",rel:"noopener noreferrer"},B=n("code",null,"new",-1),w={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle",target:"_blank",rel:"noopener noreferrer"},y=n("h2",{id:"单例bean与原型bean依赖",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#单例bean与原型bean依赖"},[n("span",null,"单例Bean与原型Bean依赖")])],-1),_=n("p",null,"当你在单例作用域的Bean中使用对原型作用域Bean的依赖时，请注意依赖关系是在实例化时解析的。 因此，如果你将一个原型作用域的Bean注入到一个单例作用域的Bean中，将会实例化一个新的原型Bean，然后将其依赖注入到单例Bean中。 这个原型实例是唯一供给单例作用域Bean的实例。",-1),P={href:"https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html",target:"_blank",rel:"noopener noreferrer"},T=e(`<h2 id="请求、会话、应用程序和websocket作用域" tabindex="-1"><a class="header-anchor" href="#请求、会话、应用程序和websocket作用域"><span>请求、会话、应用程序和WebSocket作用域</span></a></h2><p><code>request</code>、<code>session</code>、<code>application</code>和<code>webSocket</code>作用域只有在使用Web感知（aware）的Spring应用程序上下文实现， 如<code>XmlWebApplicationContext</code>时才可用。 如果你在常规的Spring IoC容器中使用这些作用域，比如<code>ClassPathXmlApplicationContext</code>， 将会抛出一个IllegalStateException异常，提示未知的Bean作用域。</p><h3 id="初始web配置" tabindex="-1"><a class="header-anchor" href="#初始web配置"><span>初始Web配置</span></a></h3><p>对于Web作用域的Bean，即<code>request</code>、<code>session</code>、<code>application</code>和<code>websocket</code>的Bean，需要进行特定的作用域范围设置， 初始设置取决于你的特定Servlet环境。 对于标准作用域，如<code>singleton</code>和<code>prototype</code>则不需要进行这些初始设置。</p><p>如果你在Spring Web MVC中访问作用域内的Bean，实际上是在Spring <code>DispatcherServlet</code>处理的请求中进行访问， 无需进行特殊设置。<code>DispatcherServlet</code>已经暴露了所有相关状态。</p><p>如果你使用Servlet Web容器，在Spring的<code>DispatcherServlet</code>之外处理请求（例如，使用<code>JSF</code>），需要进行以下配置：</p><ul><li>注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>， 可以通过使用<code>WebApplicationInitializer</code>接口以编程方式完成</li><li>或者，在你的Web应用程序的<code>web.xml</code>文件中添加以下声明：</li></ul><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">&gt;</span></span>
    ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">&gt;</span></span>
            org.springframework.web.context.request.RequestContextListener
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">&gt;</span></span>
    ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你在设置监听器（listener）时遇到问题，可以考虑使用Spring的<code>RequestContextFilter</code>。 过滤器（filter）的映射取决于周围Web应用程序的配置，因此你需要根据实际情况进行适当的调整。 以下示例展示了Web应用中过滤器的部分配置：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">&gt;</span></span>
    ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>requestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.RequestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>requestContextFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
    ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>DispatcherServlet</code>、<code>RequestContextListener</code>和<code>RequestContextFilter</code>都实现相同的作用， 即把HTTP请求对象绑定到正在处理该请求的线程（Thread）上。 这使得请求范围（request-scoped）和会话范围（session-scoped）的Bean在整个调用链下游可用。</p><h3 id="请求作用域-request" tabindex="-1"><a class="header-anchor" href="#请求作用域-request"><span>请求作用域（request）</span></a></h3><p>以下XML示例中Bean的作用域是HTTP请求（request）级别的：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>loginAction<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.LoginAction<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>request<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>对于每个HTTP请求，Spring容器会创建一个新的<code>LoginAction</code>实例</li><li>每个实例独立，状态改变不会影响其他实例</li><li>请求结束后，相关实例被销毁</li></ul><p>可以使用<code>@RequestScope</code>注解可将组件限定在请求作用域内：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@RequestScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginAction</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="会话作用域-session" tabindex="-1"><a class="header-anchor" href="#会话作用域-session"><span>会话作用域（session）</span></a></h3><p>以下XML示例中Bean的作用域是HTTP会话（Session）级别的：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>对于单个HTTP会话（Session），Spring容器会创建一个新的<code>UserPreferences</code>实例</li><li>允许会话内状态更改，但不会影响其他会话</li><li>当HTTP会话（Session）结束时，相关联的Bean实例也会被销毁</li></ul><p>可以使用<code>@SessionScope</code>注解将组件限定在会话作用域内：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@SessionScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserPreferences</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用程序作用域-application" tabindex="-1"><a class="header-anchor" href="#应用程序作用域-application"><span>应用程序作用域（application）</span></a></h3><p>以下XML示例中Bean的作用域是<code>ServletContext</code>级别的：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>appPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.AppPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>application<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>对于整个Web应用程序，Spring容器仅会创建一个<code>AppPreferences</code>实例，存储在<code>ServletContext</code>属性中</li><li>这类似于Spring的单例Bean，但在两个重要方面有所不同： <ol><li>它是每个<code>ServletContext</code>的单例，而不是每个Spring <code>ApplicationContext</code> （在任何给定的Web应用程序中可能有多个<code>ApplicationContext</code>）</li><li>它实际上是作为<code>ServletContext</code>属性暴露和可见的</li></ol></li></ul><p>可以使用<code>@ApplicationScope</code>注解将组件限定在应用程序作用域内：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@ApplicationScope</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppPreferences</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="websocket作用域" tabindex="-1"><a class="header-anchor" href="#websocket作用域"><span>WebSocket作用域</span></a></h3>`,30),C={href:"https://docs.spring.io/spring-framework/reference/web/websocket/stomp/scope.html",target:"_blank",rel:"noopener noreferrer"},j=n("h3",{id:"bean-scope作为依赖项",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#bean-scope作为依赖项"},[n("span",null,"Bean Scope作为依赖项")])],-1),W=n("p",null,[a("Spring IoC容器不仅管理对象（Bean）的实例化，还管理协作对象（或依赖项）的注入。 当需要将生命周期较短的Bean（HTTP请求作用域的Bean）注入到生命周期较长的Bean中，可以选择"),n("strong",null,"注入一个AOP代理对象"),a("。 换句话说，你需要注入一个代理对象，具有与被代理Bean相同的接口，能够从相关作用域获取实际的Bean实例，并代理其方法调用。")],-1),M={class:"hint-container note"},A=e('<p class="hint-container-title">注</p><p>你还可以在定义<code>singleton</code>作用域的Bean之间使用 <code>&lt;aop:scoped-proxy/&gt;</code>， 这样引用就会通过一个可序列化的中间代理进行，因此能够在反序列化时重新获取目标<code>singleton</code> Bean。</p><p>当对<code>prototype</code>作用域的Bean声明<code>&lt;aop:scoped-proxy/&gt;</code>时，对共享代理的每个方法调用都会导致创建一个新的目标实例，并将调用转发到新创建的实例上。</p><p>此外，作用域代理并不是以生命周期安全的方式从较短作用域中访问Bean的唯一方法。 你还可以将注入点（即构造函数或setter参数或autowired字段）声明为<code>ObjectFactory&lt;MyTargetBean&gt;</code>， 允许在每次需要时通过调用<code>getObject()</code>来获取当前实例，而无需持有实例或将其分开存储。</p><p>作为一个扩展变体，你还可以声明<code>ObjectProvider&lt;MyTargetBean&gt;</code>，它提供了几个额外的访问变体，包括<code>getIfAvailable</code> 和<code>getIfUnique</code>。</p>',5),L=n("code",null,"Provider<MyTargetBean>",-1),U=n("code",null,"get()",-1),F={href:"https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html",target:"_blank",rel:"noopener noreferrer"},D=e(`<p>以下示例中的配置只有一行，但理解其“为什么（why）”以及“如何（how）”背后的原因同样重要：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans<span class="token punctuation">&quot;</span></span>
	<span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
	<span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/aop<span class="token punctuation">&quot;</span></span>
	<span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

	<span class="token comment">&lt;!-- 一个以代理方式暴露的HTTP Session作用域的bean --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
		<span class="token comment">&lt;!-- 指示容器对周围的bean进行代理 --&gt;</span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>scoped-proxy</span><span class="token punctuation">/&gt;</span></span> (1) 定义代理的行
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

	<span class="token comment">&lt;!-- 一个以单例方式作用域的bean，使用对上述bean的代理进行注入 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.SimpleUserService<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
		<span class="token comment">&lt;!-- 对代理的userPreferences bean的引用 --&gt;</span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),H=n("code",null,"userPreferences",-1),R=n("code",null,"<aop:scoped-proxy/>",-1),I={href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-other-injection-proxies",target:"_blank",rel:"noopener noreferrer"},O={href:"https://docs.spring.io/spring-framework/reference/core/appendix/xsd-schemas.html",target:"_blank",rel:"noopener noreferrer"},J=e(`<p><strong>为什么在<code>request</code>、<code>session</code>和自定义作用域层次上的Bean定义需要使用<code>&lt;aop:scoped-proxy/&gt;</code>元素？</strong></p><p>考虑以下单例Bean定义，并将其与上述作用域所需的定义进行对比：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userManager<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上，单例Bean（<code>userManager</code>）被注入了对HTTP会话作用域的Bean（<code>userPreferences</code>）的引用。 这里<strong>关键点是</strong>：</p><ul><li>单例Bean（<code>userManager</code>）它在容器中只被实例化一次，并且它的依赖项<code>userPreferences</code> Bean也只被注入一次</li><li>这意味着<code>userManager</code> Bean始终操作同一个的<code>userPreferences</code>对象（即最初注入时的对象），这不是期望的行为</li></ul><p><strong>问题描述：单例与会话作用域的交互</strong></p><p>当把一个生命周期较短的作用域Bean注入到一个生命周期较长的作用域Bean时，这不是你想要的行为 （例如，在单例Bean中注入一个HTTP Session作用域的协作Bean作为依赖项）。 相反，你需要一个单例的<code>userManager</code>对象，而且，在HTTP Session的生命周期内，你需要一个特定于HTTP Session的<code>userPreferences</code>对象。</p><p><strong>解决方案：使用代理对象</strong></p><p>因此，容器会创建一个代理对象，具有与被代理Bean相同的接口（最好是一个<code>UserPreferences</code>实例），能够从相关作用域获取实际的Bean实例，并代理其方法调用。 容器将这个代理对象注入到<code>userManager</code> Bean中，而这个<code>userManager</code> Bean并不知道这个<code>UserPreferences</code>引用是一个代理。 在这个例子中，当<code>UserManager</code>实例调用依赖注入的<code>UserPreferences</code>对象上的方法时，实际上是在调用代理上的方法。 然后，代理从HTTP Session中获取真实的<code>UserPreferences</code>对象，并将方法调用委托给真实的<code>UserPreferences</code>对象。</p><p>以下是将请求作用域和会话作用域的 Bean 注入到协作对象中的<strong>正确完整配置</strong>：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>scoped-proxy</span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userManager<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.something.UserManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="选择要创建的代理类型" tabindex="-1"><a class="header-anchor" href="#选择要创建的代理类型"><span>选择要创建的代理类型</span></a></h4><p>默认情况下，当Spring容器为使用<code>&lt;aop:scoped-proxy/&gt;</code>元素标记的Bean创建代理时，会创建一个基于CGLIB的类代理。</p><div class="hint-container note"><p class="hint-container-title">注</p><p>CGLIB代理只拦截public方法的调用! 不要在这样的代理上调用非public的方法。它们不会被委托给实际的作用域目标对象。</p></div><p>另外，你也可以通过在<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code>属性中指定<code>false</code>的方式， 配置Spring容器为这些作用域Bean创建基于JDK接口的标准代理。 使用基于JDK接口的代理，意味着你的应用程序 classpath 中不需要额外的库来影响这种代理。 然而，这也意味着作用域Bean的类<strong>必须实现至少一个接口</strong>，并且所有注入该作用域Bean的协作对象必须通过其中一个接口引用该Bean。 以下示例展示了基于接口的代理：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- DefaultUserPreferences 实现了 UserPreferences 接口 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.stuff.DefaultUserPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>session<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>scoped-proxy</span> <span class="token attr-name">proxy-target-class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userManager<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.stuff.UserManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userPreferences<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16),X={href:"https://docs.spring.io/spring-framework/reference/core/aop/proxying.html",target:"_blank",rel:"noopener noreferrer"},N=e('<h3 id="直接注入request-session引用" tabindex="-1"><a class="header-anchor" href="#直接注入request-session引用"><span>直接注入<code>request</code>/<code>session</code>引用</span></a></h3><p>作为<strong>工厂作用域的替代方案</strong>，Spring <code>WebApplicationContext</code>还支持将 <code>HttpServletRequest</code>、<code>HttpServletResponse</code>、<code>HttpSession</code>、<code>WebRequest</code> 和（如果存在 JSF）<code>FacesContext</code>和<code>ExternalContext</code>直接注入到Spring管理的Bean中， 只需通过基于类型的自动装配即可，与普通Bean的其他注入点一起。 Spring 通常为这些请求和会话对象注入代理，这样做的好处是可以在单例Bean和可序列化Bean中正常工作，类似于工厂作用域Bean的作用域代理。</p><h2 id="自定义作用域" tabindex="-1"><a class="header-anchor" href="#自定义作用域"><span>自定义作用域</span></a></h2><p>Bean作用域机制是可扩展的。你可以定义自己的作用域，甚至重新定义现有的作用域，尽管后者被认为是不良实践，而且你不能覆盖内置的<code>singleton</code>和<code>prototype</code>作用域。</p><h3 id="创建自定义-scope" tabindex="-1"><a class="header-anchor" href="#创建自定义-scope"><span>创建自定义 Scope</span></a></h3>',5),z=n("code",null,"org.springframework.beans.factory.config.Scope",-1),Z={href:"https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/beans/factory/config/Scope.html",target:"_blank",rel:"noopener noreferrer"},E=e(`<p>Scope 接口有四个方法用于从作用域中获取对象、将它们从Scope中移除，以及让对象被销毁。</p><p><strong>获取作用域内的对象</strong></p><p>例如，会话作用域的实现会返回会话作用域的Bean（如果不存在，则该方法会返回该Bean的新实例，并将其绑定到会话中以供将来引用）。 以下方法返回底层作用域中的对象：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>Object get(String name, ObjectFactory<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>?</span><span class="token punctuation">&gt;</span></span> objectFactory)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>移除作用域内的对象</strong></p><p>例如，会话作用域的实现会从底层会话中移除会话作用域的Bean。 应该返回对象，但如果找不到指定名称的对象，则可以返回<code>null</code>。以下方法从底层作用域中移除对象：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>Object remove(String name)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注册销毁回调</strong></p><p>以下方法注册一个回调（callback），该回调在作用域被销毁 或 作用域中的指定对象被销毁时调用：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>void registerDestructionCallback(String name, Runnable destructionCallback)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,10),V={href:"https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback",target:"_blank",rel:"noopener noreferrer"},G=e(`<p><strong>获取会话标识符</strong></p><p>以下方法获取底层作用域的会话标识符（conversation id）：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> <span class="token function">getConversationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于每个作用域，这个标识符是不同的。对于会话作用域的实现，这个标识符（id）可以是会话标识符（session id）。</p><h3 id="使用自定义-scope" tabindex="-1"><a class="header-anchor" href="#使用自定义-scope"><span>使用自定义 Scope</span></a></h3><p>在编写和测试一个或多个自定义Scope实现之后，你需要让Spring容器知道你的新作用域。 下面的方法是向Spring容器注册新Scope的核心方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">registerScope</span><span class="token punctuation">(</span><span class="token class-name">String</span> scopeName<span class="token punctuation">,</span> <span class="token class-name">Scope</span> scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该方法声明在<code>ConfigurableBeanFactory</code>接口上，可以通过大多数Spring ApplicationContext实现中的BeanFactory属性访问到。</p><p><code>registerScope(..)</code>方法的第一个参数是与作用域相关联的唯一名称。 Spring容器本身中的示例名称包括<code>singleton</code>和<code>prototype</code>。 <code>registerScope(..)</code>方法的第二个参数是你希望注册和使用的自定义Scope实现的实际实例。</p><p>假设你编写了自定义的Scope实现，并按下面的示例进行注册：</p><div class="hint-container note"><p class="hint-container-title">注</p><p>下面的示例使用了<code>SimpleThreadScope</code>，它包含在Spring中，但不是默认注册的。对于你自己的自定义Scope实现，注册的步骤是相同的。</p></div><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Scope</span> threadScope <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleThreadScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
beanFactory<span class="token punctuation">.</span><span class="token function">registerScope</span><span class="token punctuation">(</span><span class="token string">&quot;thread&quot;</span><span class="token punctuation">,</span> threadScope<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来可以创建符合你自定义Scope规则的Bean定义，示例如下：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thread<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用自定义Scope实现，你不仅可以通过编程方式注册作用域，还可以通过使用<code>CustomScopeConfigurer</code>类进行声明性的作用域注册，示例如下：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/aop<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.beans.factory.config.CustomScopeConfigurer<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>scopes<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thread<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.context.support.SimpleThreadScope<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thing2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x.y.Thing2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thread<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Rick<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>scoped-proxy</span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thing1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x.y.Thing1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thing2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>thing2<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">注</p><p>当你将<code>&lt;aop:scoped-proxy/&gt;</code>放置在<code>FactoryBean</code>实现的<code>&lt;bean&gt;</code>声明内部时，作用域的是工厂Bean本身，而不是从<code>getObject()</code>返回的对象。</p></div>`,17);function K(Q,Y){const s=o("ExternalLinkIcon");return c(),l("div",null,[u,r,n("p",null,[a("你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强大且灵活的，因为你可以通过配置选择创建的对象的作用域，而不必在Java类级别上固定对象的作用域。 Bean定义可以是多种作用域之一。Spring框架支持六种作用域，其中四种仅在使用Web感知（aware）的"),d,a("时才可用。 你还可以创建"),n("a",k,[a("自定义作用域"),t(s)]),a("。")]),g,n("div",m,[v,n("p",null,[a("线程作用域（Thread Scope）在Spring框架中是可用的，但默认情况下并没有注册。参阅 "),n("a",b,[a("SimpleThreadScope"),t(s)]),a("。 关于如何注册此Scope或任何其他自定义Scope的说明，参阅 "),n("a",h,[a("自定义Scope"),t(s)]),a("。")])]),q,n("p",null,[a("与其他作用域相比，Spring并不管理原型（prototype）Bean的完整生命周期。 容器实例化、配置并组装原型对象，然后将其交给客户端，之后就不会对那个原型实例保持任何记录。 因此，尽管初始化生命周期回调方法（如"),f,a("）会在所有对象上调用，而不考虑作用域， 但在原型作用域的情况下，配置的销毁生命周期回调方法（如"),x,a("）则不会被调用。 客户端代码必须清理原型作用域的对象，并释放原型Bean所持有的昂贵资源。 要让Spring容器释放原型作用域Bean所持有的资源，可以尝试使用一个自定义的"),n("a",S,[a("Bean后置处理器"),t(s)]),a(" ，该后置处理器持有需要清理的Bean的引用。")]),n("p",null,[a("在某些方面，Spring容器对于原型（prototype）作用域Bean的角色类似于Java中的"),B,a("运算符。 但是，一旦Spring容器创建并交付原型Bean给客户端，所有生命周期管理的工作都需要由客户端自行处理。 有关Spring容器中Bean的生命周期的详细信息，参阅 "),n("a",w,[a("生命周期回调"),t(s)])]),y,_,n("p",null,[a("然而，假设你希望单例作用域的Bean在运行时重复获取原型作用域的Bean的新实例。 你不能将一个原型作用域的Bean注入到你的单例Bean中，因为这种注入只会在Spring容器实例化单例Bean并解析并注入其依赖时发生一次。 如果你需要在运行时多次获取原型Bean的新实例，参阅 "),n("a",P,[a("方法注入（Method Injection）"),t(s)]),a("。")]),T,n("p",null,[a("WebSocket作用域与WebSocket会话的生命周期相关联，适用于基于WebSocket的STOMP应用程序， 详情参阅："),n("a",C,[a("WebSocket作用域"),t(s)])]),j,W,n("div",M,[A,n("p",null,[a("JSR-330的变体被称为Provider，使用"),L,a("声明，并且每次检索尝试时都需要对应的"),U,a("调用。有关JSR-330的更多细节， 请参阅"),n("a",F,[a("此处"),t(s)]),a("。")])]),D,n("p",null,[a("要创建"),H,a("代理，需要在作用域Bean定义中插入一个子元素"),R,a(" （参阅"),n("a",I,[a("选择要创建的代理类型"),t(s)]),a(" 和"),n("a",O,[a("基于XML模式的配置"),t(s)]),a("）。")]),J,n("p",null,[a("关于选择基于类或基于接口的代理的更多详细信息，请参阅 "),n("a",X,[a("代理机制"),t(s)]),a("。")]),N,n("p",null,[a("要将自定义作用域集成到Spring容器中，你需要实现"),z,a("接口，该接口在本节中有详细描述。 要了解如何实现自定义作用域，请参阅Spring框架自带的Scope实现以及"),n("a",Z,[a("Scope"),t(s)]),a(" javadoc，其中更详细地解释了你需要实现的方法。")]),E,n("p",null,[a("参阅 "),n("a",V,[a("javadoc"),t(s)]),a(" 或 Spring Scope 的实现，以了解更多关于销毁callback的信息。")]),G])}const an=p(i,[["render",K],["__file","beans-scope.html.vue"]]),sn=JSON.parse('{"path":"/md/spring-framework/core/beans-scope.html","title":"Bean作用域（Scope）","lang":"zh-CN","frontmatter":{"title":"Bean作用域（Scope）","author":"流浪码客","isOriginal":true,"date":"2024-04-03T00:00:00.000Z","category":"Spring","tag":"Spring Framework","description":"Bean作用域（Scope） 当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。 你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强...","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/spring-framework/core/beans-scope.html"}],["meta",{"property":"og:title","content":"Bean作用域（Scope）"}],["meta",{"property":"og:description","content":"Bean作用域（Scope） 当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。 你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.geekyspace.cn/pictures/2024/singleton.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-01T18:57:43.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"Spring Framework"}],["meta",{"property":"article:published_time","content":"2024-04-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-01T18:57:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Bean作用域（Scope）\\",\\"image\\":[\\"http://img.geekyspace.cn/pictures/2024/singleton.png\\",\\"http://img.geekyspace.cn/pictures/2024/prototype.png\\"],\\"datePublished\\":\\"2024-04-03T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-01T18:57:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"单例作用域（singleton）","slug":"单例作用域-singleton","link":"#单例作用域-singleton","children":[]},{"level":2,"title":"原型作用域（prototype）","slug":"原型作用域-prototype","link":"#原型作用域-prototype","children":[]},{"level":2,"title":"单例Bean与原型Bean依赖","slug":"单例bean与原型bean依赖","link":"#单例bean与原型bean依赖","children":[]},{"level":2,"title":"请求、会话、应用程序和WebSocket作用域","slug":"请求、会话、应用程序和websocket作用域","link":"#请求、会话、应用程序和websocket作用域","children":[{"level":3,"title":"初始Web配置","slug":"初始web配置","link":"#初始web配置","children":[]},{"level":3,"title":"请求作用域（request）","slug":"请求作用域-request","link":"#请求作用域-request","children":[]},{"level":3,"title":"会话作用域（session）","slug":"会话作用域-session","link":"#会话作用域-session","children":[]},{"level":3,"title":"应用程序作用域（application）","slug":"应用程序作用域-application","link":"#应用程序作用域-application","children":[]},{"level":3,"title":"WebSocket作用域","slug":"websocket作用域","link":"#websocket作用域","children":[]},{"level":3,"title":"Bean Scope作为依赖项","slug":"bean-scope作为依赖项","link":"#bean-scope作为依赖项","children":[]},{"level":3,"title":"直接注入request/session引用","slug":"直接注入request-session引用","link":"#直接注入request-session引用","children":[]}]},{"level":2,"title":"自定义作用域","slug":"自定义作用域","link":"#自定义作用域","children":[{"level":3,"title":"创建自定义 Scope","slug":"创建自定义-scope","link":"#创建自定义-scope","children":[]},{"level":3,"title":"使用自定义 Scope","slug":"使用自定义-scope","link":"#使用自定义-scope","children":[]}]}],"git":{"createdTime":1719508475000,"updatedTime":1740855463000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1},{"name":"kai","email":"kkdlut@hotmail.com","commits":1}]},"readingTime":{"minutes":16.46,"words":4937},"filePathRelative":"md/spring-framework/core/beans-scope.md","localizedDate":"2024年4月3日","excerpt":"\\n<p>当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。\\n将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。</p>\\n<p>你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。\\n这种方法是强大且灵活的，因为你可以通过配置选择创建的对象的作用域，而不必在Java类级别上固定对象的作用域。\\nBean定义可以是多种作用域之一。Spring框架支持六种作用域，其中四种仅在使用Web感知（aware）的<code>ApplicationContext</code>时才可用。\\n你还可以创建<a href=\\"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">自定义作用域</a>。</p>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{an as comp,sn as data};
