import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-CARt6Xo2.js";const t={},p=e(`<h1 id="java-16-新特性-record类" tabindex="-1"><a class="header-anchor" href="#java-16-新特性-record类"><span>Java 16 新特性：record类</span></a></h1><p>Java 16 引入的<strong>记录类</strong>（Records Classes）是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>等，从而减少了开发者的样板代码。</p><h2 id="传统java-bean问题" tabindex="-1"><a class="header-anchor" href="#传统java-bean问题"><span>传统Java Bean问题</span></a></h2><p>在处理不可变数据时，传统的Java Bean存在“<mark>繁琐</mark>”和“<mark>冗长</mark>”的问题。 为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码， 包括<code>构造函数</code>、<code>访问器(getter/setter)</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>等。</p><p>例如，用于携带x和y坐标的类通常会演变成以下繁琐形式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Point</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> other<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">.</span>y <span class="token operator">==</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Point[x=%d, y=%d]&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="引入record类" tabindex="-1"><a class="header-anchor" href="#引入record类"><span>引入record类</span></a></h2><p><strong>语法如下</strong>：使用 <code>record</code><mark>关键字</mark>，指定<mark>类名称</mark>为 Point，定义<mark>参数列表</mark> x 和 y 作为组件</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>record申明的类，具备这些特点：</p><ol><li>它是一个<code>final</code>类</li><li>自动实现<code>equals</code>、<code>hashCode</code>、<code>toString</code>函数</li><li>成员变量均为<code>public</code>属性</li></ol><p>所以，对于之前写的Point类，它等价于一个这样的类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Record类声明，使用record关键字，名称为Point，带有两个参数x和y</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 自动生成成员变量（fields）</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token comment">// 2. 自动生成构造函数(constructor)</span>
    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 自动生成的访问方法</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> x <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> y <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 4. 自动生成equals和hashCode方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> equals <span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 实现相等性比较的逻辑</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> hashCode <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 生成哈希码的逻辑</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 5. 自动生成toString方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> toString <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Point{&quot;</span> <span class="token operator">+</span>
                <span class="token string">&quot;x=&quot;</span> <span class="token operator">+</span> x <span class="token operator">+</span>
                <span class="token string">&quot;, y=&quot;</span> <span class="token operator">+</span> y <span class="token operator">+</span>
                <span class="token char">&#39;}&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用record类，你可以更专注于业务逻辑而不是样板代码，提高了代码的可读性和可维护性。</p><h2 id="显示声明紧凑构造函数" tabindex="-1"><a class="header-anchor" href="#显示声明紧凑构造函数"><span>显示声明紧凑构造函数</span></a></h2><p>未显式声明构造函数时，系统会自动生成包含所有成员变量的隐式构造函数。 当显式声明紧凑构造函数可以<mark>省略形式参数列表</mark>、编译后在构造函数的末尾<mark>自动分配</mark>给相应的形式参数（this.x = x;）。</p><ul><li><p><strong>验证参数</strong>的紧凑构造函数</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token class-name">String</span> title<span class="token punctuation">,</span> <span class="token class-name">String</span> author<span class="token punctuation">,</span> <span class="token keyword">int</span> pageCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Book</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pageCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;页数必须大于零.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>规范</strong>的紧凑构造函数</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 记录类 Rational 表示有理数，包含分子（num）和分母（denom）两个成员变量</span>
<span class="token keyword">record</span> <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> denom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> gcd <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> denom<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 计算最大公约数</span>
        num <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>                 <span class="token comment">// 将分子除以最大公约数</span>
        denom <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>               <span class="token comment">// 将分母除以最大公约数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个声明等同于传统的构造函数形式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> denom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> demon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 逻辑代码</span>
        <span class="token keyword">int</span> gcd <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> denom<span class="token punctuation">)</span><span class="token punctuation">;</span>
        num <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>
        denom <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>
        <span class="token comment">// 赋值代码</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>denom <span class="token operator">=</span> denom<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>记录类<strong>语义一致性</strong></p><p>例如，考虑以下方式声明的记录类R：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token class-name">T1</span> c1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token class-name">Tn</span> cn<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果通过以下方式复制R的实例r1：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">R</span> r2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span><span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">cn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>则假设 r1 不是空引用，表达式 r1.equals(r2) 总是为 true。 这是因为记录类的隐式声明的 equals 方法保证了相同字段值的两个记录实例相等。</p><blockquote><p>Tips: 程序员需要谨慎确保显式声明的方法维持语义一致性</p></blockquote></li><li><p>避免不良风格的代码</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">SmallPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个不良风格的代码，违反了语义一致性的原则，访问器<code>x()</code>,<code>y()</code>方法调整类实例的状态； <strong>改进建议</strong>， 如果需要限制坐标值的范围，应该在构造函数或其他明确的位置处理。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">SmallPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 紧凑构造函数中限制坐标值的范围</span>
  <span class="token keyword">public</span> <span class="token class-name">SmallPoint</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="发展脉络" tabindex="-1"><a class="header-anchor" href="#发展脉络"><span>发展脉络</span></a></h2><p><code>record</code> 类最初在JDK 14预览版(JEP 359)提出，随后在JDK 15预览版(JEP 384)再次推出。 最终，它在JDK 16中(JEP 395)正式发布，成为Java语言的一项重要特性。</p>`,19),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","jep395-records.html.vue"]]),k=JSON.parse('{"path":"/md/java/features/Java16/jep395-records.html","title":"Java 16 新特性：record类","lang":"zh-CN","frontmatter":{"title":"Java 16 新特性：record类","shortTitle":null,"description":"Java 16 新特性：record类 Java 16 引入的记录类（Records Classes）是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如equals()、hashCode()和toString()等，从而减少了开发者的样板代码。 传统Java Bean问题 在处理不可变数据时，传...","icon":null,"cover":null,"author":"流浪码客","isOriginal":true,"sticky":false,"star":false,"date":"2023-12-29T00:00:00.000Z","category":"Java Features","tag":["java"],"order":395,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java/features/Java16/jep395-records.html"}],["meta",{"property":"og:title","content":"Java 16 新特性：record类"}],["meta",{"property":"og:description","content":"Java 16 新特性：record类 Java 16 引入的记录类（Records Classes）是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如equals()、hashCode()和toString()等，从而减少了开发者的样板代码。 传统Java Bean问题 在处理不可变数据时，传..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-16T11:19:57.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2023-12-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-16T11:19:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 16 新特性：record类\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-16T11:19:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"传统Java Bean问题","slug":"传统java-bean问题","link":"#传统java-bean问题","children":[]},{"level":2,"title":"引入record类","slug":"引入record类","link":"#引入record类","children":[]},{"level":2,"title":"显示声明紧凑构造函数","slug":"显示声明紧凑构造函数","link":"#显示声明紧凑构造函数","children":[]},{"level":2,"title":"发展脉络","slug":"发展脉络","link":"#发展脉络","children":[]}],"git":{"createdTime":1758021597000,"updatedTime":1758021597000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":3.85,"words":1155},"filePathRelative":"md/java/features/Java16/jep395-records.md","localizedDate":"2023年12月29日","excerpt":"\\n<p>Java 16 引入的<strong>记录类</strong>（Records Classes）是一种用于简化不可变数据管理的特殊类。\\n它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法，\\n如<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>等，从而减少了开发者的样板代码。</p>\\n<h2>传统Java Bean问题</h2>\\n<p>在处理不可变数据时，传统的Java Bean存在“<mark>繁琐</mark>”和“<mark>冗长</mark>”的问题。\\n为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码，\\n包括<code>构造函数</code>、<code>访问器(getter/setter)</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>等。</p>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{d as comp,k as data};
