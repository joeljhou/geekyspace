import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,e as t}from"./app-CARt6Xo2.js";const e={},p=t(`<h1 id="bean定义继承" tabindex="-1"><a class="header-anchor" href="#bean定义继承"><span>Bean定义继承</span></a></h1><p>一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。 一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。 使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。</p><p>如果你以编程方式使用<code>ApplicationContext</code>接口，子Bean定义由<code>ChildBeanDefinition</code>类表示。 大多数用户不会在这个层面上直接操作它们。相反，他们会在诸如<code>ClassPathXmlApplicationContext</code>之类的类中以声明性方式配置Bean定义。 当你使用基于XML的配置元数据时，可以通过使用<code>parent</code>属性指定父Bean来表示子Bean定义，将父Bean作为此属性的值。以下示例展示了如何这样做：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 抽象的父Bean定义 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritedTestBean<span class="token punctuation">&quot;</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.beans.TestBean<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>parent<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 设置name属性为parent --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 设置age属性为1 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 继承父Bean定义的子Bean --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritsWithDifferentClass<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.beans.DerivedTestBean<span class="token punctuation">&quot;</span></span>
		<span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritedTestBean<span class="token punctuation">&quot;</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>initialize<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>override<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 覆盖name属性为override --&gt;</span>
	<span class="token comment">&lt;!-- age属性的值1将从父Bean继承 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子Bean定义如果未指定Bean类，则会使用父定义中的Bean类，但也可以覆盖它。 在后一种情况下，子Bean类必须与父Bean类兼容（即，它必须接受父Bean的属性值）。</p><p>子Bean定义从父Bean继承作用域（Scope）、构造函数参数值、属性值和方法重写，并有添加新值的选项。 你指定的任何作用域、初始化方法、销毁（destroy）方法或静态（static）工厂方法设置都会覆盖相应的父设置。</p><p>剩余的设置始终来自于子Bean定义：依赖（depends on）、自动注入（autowire）模式、依赖检查、singleton以及懒加载（lazy init）。</p><p>在上面的示例中，通过使用<code>abstract</code>属性显式地将父Bean定义标记为抽象。 如果父定义没有指定类，则需要显式地将父Bean定义标记为抽象，如下面的示例所示：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 抽象的父Bean定义，未指定类 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritedTestBeanWithoutClass<span class="token punctuation">&quot;</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>parent<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- 继承父Bean定义的子Bean --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritsWithClass<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.beans.DerivedTestBean<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inheritedTestBeanWithoutClass<span class="token punctuation">&quot;</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>initialize<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>override<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 覆盖name属性为override --&gt;</span>
    <span class="token comment">&lt;!-- age 属性将继承父Bean定义中的值1 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>父Bean定义不能单独实例化，因为它是不完整的，并且也明确标记为<code>abstract</code>。 当一个定义是<code>abstract</code>的时候，它只能作为纯模板Bean定义使用，用作子定义的父定义。 尝试单独使用这样的<code>abstract</code>父Bean，通过将其作为另一个Bean的<code>ref</code>属性引用或者显式地使用<code>getBean()</code>方法调用父Bean的ID，都会返回错误。 同样，容器的内部<code>preInstantiateSingletons()</code>方法会忽略那些被定义为抽象的Bean定义。</p><div class="hint-container note"><p class="hint-container-title">注</p><p><code>ApplicationContext</code> 默认预设了所有的单例Bean。因此，重要的是（至少对于单例Bean来说）， 如果你有一个（父）Bean定义，你打算只作为模板使用，并且这个定义指定了一个类，你必须确保将<code>abstract</code>属性设置为 true，否则应用上下文将尝试预实化<code>abstract</code> Bean。</p></div>`,11),o=[p];function c(l,u){return n(),s("div",null,o)}const k=a(e,[["render",c],["__file","child-bean-definitions.html.vue"]]),d=JSON.parse('{"path":"/md/spring-framework/core/child-bean-definitions.html","title":"Bean定义继承","lang":"zh-CN","frontmatter":{"title":"Bean定义继承","author":"流浪码客","isOriginal":true,"date":"2024-04-10T00:00:00.000Z","category":"Spring","tag":"Spring Framework","description":"Bean定义继承 一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。 一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。 使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。 如果你以编程方式使用ApplicationCon...","head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/spring-framework/core/child-bean-definitions.html"}],["meta",{"property":"og:title","content":"Bean定义继承"}],["meta",{"property":"og:description","content":"Bean定义继承 一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。 一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。 使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。 如果你以编程方式使用ApplicationCon..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-01T18:57:43.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"Spring Framework"}],["meta",{"property":"article:published_time","content":"2024-04-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-01T18:57:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Bean定义继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-01T18:57:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[],"git":{"createdTime":1719508475000,"updatedTime":1740855463000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1},{"name":"kai","email":"kkdlut@hotmail.com","commits":1}]},"readingTime":{"minutes":2.97,"words":891},"filePathRelative":"md/spring-framework/core/child-bean-definitions.md","localizedDate":"2024年4月10日","excerpt":"\\n<p>一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。\\n一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。\\n使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。</p>\\n<p>如果你以编程方式使用<code>ApplicationContext</code>接口，子Bean定义由<code>ChildBeanDefinition</code>类表示。\\n大多数用户不会在这个层面上直接操作它们。相反，他们会在诸如<code>ClassPathXmlApplicationContext</code>之类的类中以声明性方式配置Bean定义。\\n当你使用基于XML的配置元数据时，可以通过使用<code>parent</code>属性指定父Bean来表示子Bean定义，将父Bean作为此属性的值。以下示例展示了如何这样做：</p>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{k as comp,d as data};
