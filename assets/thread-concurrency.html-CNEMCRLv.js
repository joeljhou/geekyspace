import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as d,c as a,a as t,b as o,d as e,e as n}from"./app-CARt6Xo2.js";const c={},g=n('<h1 id="java多线程与并发编程" tabindex="-1"><a class="header-anchor" href="#java多线程与并发编程"><span>Java多线程与并发编程</span></a></h1><blockquote><p>你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。</p></blockquote><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h2><ul><li><strong>基本概念 (Basic)</strong></li><li><strong>多线程 (Thread)</strong></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-executor">线程池 (Executor)</a></li><li><a href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-collections">并发容器 (Collections)</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-tools">同步工具 (Tools)</a></li><li><a href="#%E5%8E%9F%E5%AD%90%E5%AF%B9%E8%B1%A1-atomic">原子对象 (Atomic)</a></li></ul><figure><img src="http://img.geekyspace.cn/pictures/2025/image-20250217013332469.png" alt="Java多线程并发编程6大核心" tabindex="0" loading="lazy"><figcaption>Java多线程并发编程6大核心</figcaption></figure><h2 id="并发背后的故事" tabindex="-1"><a class="header-anchor" href="#并发背后的故事"><span>并发背后的故事</span></a></h2><p><strong>什么是并发？</strong> 并发就是指程序同时处理多个任务的能力。 并发编程的根源在于多任务情况下对资源访问的有效控制。</p><p><strong>你的程序在并发环境下一定是正确的吗？</strong></p>',8),h={href:"https://codecopy.cn/post/c51tdh",target:"_blank",rel:"noopener noreferrer"},u=n('<h2 id="你必须知道的概念" tabindex="-1"><a class="header-anchor" href="#你必须知道的概念"><span>你必须知道的概念</span></a></h2><p><strong>程序，进程与线程</strong></p><ol><li><strong>程序</strong>：程序是静态的概念，Windows下通常指<code>exe</code>文件。</li><li><strong>进程</strong>：进程是动态的概念，当你双击一个程序，操作系统会把它加载到内存中运行，进程说明程序在内存中的边界。</li><li><strong>线程</strong>：一个进程包含多个线程，线程是CPU调度的基本单位，每个线程都有自己的功能。</li></ol><p><strong>并行与并发</strong></p><ol><li><p><strong>🚗并行 (Parallelism)</strong>：<em>多核CPU同时处理</em></p><ul><li><strong>就像多车道高速公路:</strong> 多辆车可以同时在不同的车道上行驶，互不干扰。</li><li><strong>在计算机中:</strong> 多个处理器或多核CPU同时执行多个任务，真正同时进行。</li></ul></li><li><p><strong>🚚🚙🚗并发 (Concurrency)</strong>：<em>单核CPU交替执行</em></p><ul><li><strong>就像单车道上的多辆车:</strong> 虽然只有一条车道，但通过交替行驶，看起来像是同时前进。</li><li><strong>在计算机中:</strong> 单个处理器通过快速切换任务，给人同时处理的错觉，实际是交替执行。</li></ul></li></ol><p><strong>同步和异步</strong></p><ol><li><p><strong>⏳同步 (Sync)</strong>：<em>按顺序执行，干等着</em></p><ul><li><strong>就像银行柜台办理业务：</strong> 你去银行取钱，需要排队，前面的人不办完，你不能办。</li><li><strong>在编程中：</strong> 代码按顺序执行，每个任务必须等前一个任务完成后才能执行下一个。</li></ul></li><li><p><strong>🏃‍♂️异步 (Asyn)</strong>：<em>不等了，先去忙别的，等有结果再回来处理</em></p><ul><li><strong>就像去餐厅点餐：</strong> 你点完餐后不用等着，先去刷手机，等饭做好了，服务员再叫你来取。</li><li><strong>在编程中：</strong> 代码遇到耗时操作（比如网络请求）时不会等，而是先去执行别的任务，等操作完成后再回来处理结果。</li></ul></li></ol><p><strong>临界区</strong></p><ol><li><strong>🚧临时区：</strong> <em>公共资源与共享数据，同一时间只能有一个线程访问</em><ul><li><strong>就像公司的打印机</strong>：公司只有一台打印机（临界区），多个员工（线程）需要打印文件，每次只能一个员工使用。</li><li><strong>在编程中：</strong> 临时区是指对共享资源访问的代码片段，通过互斥锁（Mutex），信号量（Semaphore），原子操作（Atomic Operations）来实现。</li></ul></li></ol><p><strong>死锁、饥饿、活锁</strong></p><ol><li><p><strong>🛑死锁（Deadlock）：🔒</strong></p><ul><li><strong>就像公路上堵车：</strong> 谁也不让谁，大家都卡住</li><li><strong>在编程中：</strong> 两个或多个线程互相持有对方需要的资源，导致无法继续执行。</li></ul></li><li><p><strong>🍽️饥饿 (Starvation)：</strong></p><ul><li><strong>就像奶茶店排队：</strong> 总有人插队，有些人一直没机会买到奶茶。</li><li><strong>在编程中：</strong> 线程本身是有执行优先级的，如果优先级低的线程一直无法获取到CPU执行权，就会一直处于等待状态。</li></ul></li><li><p><strong>🔁活锁 (Livelock)：</strong></p><ul><li><strong>就像礼让路口：</strong> 你让我，我让你，谁也不走。</li><li><strong>在编程中：</strong> 是指多个线程（进程）互相礼让，不断进行状态调整，但始终无法完成任务。</li></ul></li></ol><p><strong>线程安全</strong></p><ol><li><p><strong>线程安全 (Thread-Safe)</strong> 理解： 多线程环境下，对共享资源的访问不会引起数据不一致。</p></li><li><p><strong>线程安全三大特性</strong></p><ol><li><p><strong>🏗️原子性 (Atomicity)</strong>：</p><ul><li><strong>就像银行转账：</strong> 要么扣钱和加钱都成功，要么都不成功。</li><li><strong>在编程中：</strong> 一个或多个操作要么全部执行成功，要么全部不执行。</li></ul></li><li><p><strong>👀可见性 (Visibility)</strong>：</p><ul><li><strong>就像聊天室：</strong> 你发的消息，其他人都能看到。</li><li><strong>在编程中：</strong> 一个线程对共享变量的修改，其他线程能立即看到。</li></ul></li><li><p><strong>🔀有序性 (Ordering)</strong>：程序执行的顺序按照代码的先后顺序执行。</p><ul><li><strong>就像排队买票：</strong> 先来的先买票，后来的后买票。</li><li><strong>在编程中：</strong> 程序按照代码的先后顺序执行，不会乱序 通过<code>volatile</code>，<code>synchronized</code>，<code>Lock</code>来实现线程安全。</li></ul></li></ol></li></ol><h2 id="java内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#java内存模型-jmm"><span>Java内存模型（JMM）</span></a></h2>',14),p={href:"https://www.bilibili.com/video/BV1Cu4m1A7ha",target:"_blank",rel:"noopener noreferrer"},m=n('<table><thead><tr><th><strong>概念</strong></th><th><strong>作用</strong></th><th><strong>比喻</strong></th></tr></thead><tbody><tr><td><strong>主内存（Main Memory）</strong></td><td>线程共享的内存</td><td>🏢 共享数据库</td></tr><tr><td><strong>工作内存（Working Memory）</strong></td><td>线程私有的内存</td><td>📖 每个人的小笔记本</td></tr><tr><td><strong>volatile</strong></td><td>保证可见性、有序性</td><td>📢 共享公告</td></tr><tr><td><strong>synchronized</strong></td><td>保证原子性、可见性、有序性</td><td>🔒 互斥锁</td></tr><tr><td><strong>happens-before 规则</strong></td><td>规定线程间的执行顺序</td><td>📜 规则手册</td></tr></tbody></table><h2 id="创建线程的三种方式" tabindex="-1"><a class="header-anchor" href="#创建线程的三种方式"><span>创建线程的三种方式</span></a></h2>',2),_={href:"https://codecopy.cn/post/cq3kmh",target:"_blank",rel:"noopener noreferrer"},f=t("ol",null,[t("li",null,[t("strong",null,"继承Thread类")]),t("li",null,[t("strong",null,"实现Runnable接口")]),t("li",null,[t("strong",null,"实现Callable接口")])],-1),y=t("h2",{id:"synchronized线程同步机制",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#synchronized线程同步机制"},[t("span",null,"Synchronized线程同步机制")])],-1),b={href:"https://codecopy.cn/post/bxd0nq",target:"_blank",rel:"noopener noreferrer"},A=t("ol",null,[t("li",null,[t("strong",null,"synchronized 代码块（锁定任意对象）")]),t("li",null,[t("strong",null,"synchronized 方法（锁定当前实例对象 this）")]),t("li",null,[t("strong",null,"synchronized 静态方法（锁定类的字节码对象 Class）")])],-1),v=t("h2",{id:"java线程的6种状态",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#java线程的6种状态"},[t("span",null,"Java线程的6种状态")])],-1),k={href:"https://codecopy.cn/post/s6z4y5",target:"_blank",rel:"noopener noreferrer"},C=t("h2",{id:"死锁的产生",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#死锁的产生"},[t("span",null,"死锁的产生")])],-1),E={href:"https://codecopy.cn/post/udd9hm",target:"_blank",rel:"noopener noreferrer"},x=n("<li><p><strong>死锁产生的原因：</strong></p><ul><li><strong>说人话就是互掐资源：</strong><ul><li>你要用空调遥控器才把电视遥控器还我，我要用电视遥控器才把空调遥控器还你。结果俩人干瞪眼，谁都动不了。</li></ul></li><li><strong>计算机中：</strong><ul><li>在多线程对公共资源（文件、数据）等进行操作时，彼此不释放自己的资源，而去试图操作其他线程的资源，而形成交叉引用，就会产生死锁。</li></ul></li></ul></li><li><p><strong>死锁的四个必要条件</strong>（同时满足就死锁）：</p><ul><li><strong>互斥条件</strong>（Mutual Exclusion）：资源一次只能被一个线程占用，不能共享。</li><li><strong>占有并等待条件</strong>（Hold and Wait）：线程拿着已有的资源不释放，但还想申请新资源。</li><li><strong>不可抢占条件</strong>（No Preemption）：资源不能强行夺走，只能等占有者主动释放。</li><li><strong>循环等待条件</strong>（Circular Wait）：线程之间形成环形依赖，每个线程都在等待下一个线程释放资源。</li></ul></li><li><p><strong>解决死锁的建议：</strong></p><ul><li>减少对公共资源的占用，或一次性申请所需的所有资源</li><li>用完资源及时释放，释放资源后再申请新资源</li><li>减少<code>synchornized</code>的使用，采用“副本”方式替代。</li></ul></li>",3),T=n('<h2 id="重新认识线程安全-threadsafe" tabindex="-1"><a class="header-anchor" href="#重新认识线程安全-threadsafe"><span>重新认识线程安全（ThreadSafe）</span></a></h2><ol><li><p><strong>线程安全定义</strong></p><ul><li>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过<strong>同步机制</strong>保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</li></ul></li><li><p><strong>通过<code>synchornized</code>，<code>Lock</code>，<code>Atomic</code>等方式实现线程安全。</strong></p></li><li><p><strong>线程安全与不安全的区别</strong></p><ul><li><strong>线程安全：</strong><ul><li>优点：可靠</li><li>缺点：执行速度慢</li><li>使用建议：在需要线程共享时使用</li></ul></li><li><strong>线程不安全：</strong><ul><li>优点：速度快</li><li>缺点：可能与预期不符</li><li>使用建议：在线程内部使用，无需线程间共享时使用</li></ul></li></ul></li></ol><h2 id="juc并发工具" tabindex="-1"><a class="header-anchor" href="#juc并发工具"><span>JUC并发工具</span></a></h2><h3 id="线程池-executor" tabindex="-1"><a class="header-anchor" href="#线程池-executor"><span>线程池（Executor）</span></a></h3>',4),J=n("<li><p><strong>并发工具包：</strong> （<code>java.util.concurrent</code>） 在 Java 5 之前，我们只能使用 <code>synchronized</code>、<code>wait</code>、<code>notify</code> 等低级 API 来管理线程，代码复杂且容易出错。<strong>从 Java 5 开始</strong>，JDK 提供了 <strong><code>java.util.concurrent</code></strong> 并发工具包，帮我们更方便地处理线程、任务调度、数据共享等问题。</p></li><li><p><strong>💡什么是线程池</strong>（Thread Pool） 线程池（Thread Pool）是一种管理多个线程的技术，它通过<strong>复用</strong>已创建的线程来执行多个任务，避免了线程的<strong>频繁创建和销毁</strong>，从而提高系统性能。</p><ul><li><strong>优点：</strong><ul><li>重用存在的线程，减少对象对象、消亡的开销</li><li>线程总数可控，提高资源的利用率</li><li>避免过多资源竞争，避免阻塞</li><li>提供额外功能，定时执行、定期执行、监控等。</li></ul></li></ul></li>",2),B={href:"https://codecopy.cn/post/rpat5a",target:"_blank",rel:"noopener noreferrer"},j=n("<ol><li><strong>可缓存线程池（<code>CachedThreadPool</code>）</strong><ul><li>特点：线程数动态伸缩，适合大量短任务（如日志处理、网络请求）。</li></ul></li><li><strong>定长线程池：<code>FixedThreadPool</code></strong><ul><li>特点：线程数固定，适合长期稳定任务。</li></ul></li><li><strong>单线程池：<code>SingleThreadExecutor</code></strong><ul><li>特点：单线程按顺序执行，适合日志、数据库操作等顺序任务。</li></ul></li><li><strong>调度线程池</strong>：<code>ScheduledThreadPool</code><ul><li>特点：定时或周期性任务，适用于心跳检测、定时任务。</li></ul></li></ol>",1),S=t("p",null,[t("strong",null,[o("✅推荐自定义 "),t("code",null,"ThreadPoolExecutor"),o("（避免 OOM）")])],-1),z={href:"https://www.bilibili.com/video/BV15m4y1o7gT",target:"_blank",rel:"noopener noreferrer"},w=t("h3",{id:"同步工具-tools",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#同步工具-tools"},[t("span",null,"同步工具 (Tools)")])],-1),M={href:"https://codecopy.cn/post/guuz4b",target:"_blank",rel:"noopener noreferrer"},P=n("<li><p><strong>CountDownLatch（倒计时锁）</strong></p><ul><li>允许一个或多个线程等待<strong>多个线程完成任务</strong>后再继续执行。</li><li>适用于 <strong>并发初始化多个资源</strong> 或 <strong>多个任务完成后统一汇总</strong>。</li></ul></li><li><p><strong>Semaphore（信号量）</strong></p><ul><li><strong>限制并发线程的数量</strong>，控制资源的访问。</li><li>适用于 <strong>限流</strong>、<strong>连接池</strong> 等场景。</li></ul></li><li><p><strong>CyclicBarrier（循环屏障）</strong></p><ul><li>让多个线程<strong>在某个时间点上同步执行</strong>。</li><li>适用于<strong>所有线程都到达后才能继续执行</strong>的场景。</li></ul></li>",3),F=t("p",null,[t("strong",null,"ReentrantLock（可重入锁）")],-1),I=t("li",null,"重入锁是指任意线程在获取到锁之后,再次获取该锁而不会被该锁所阻塞。",-1),L=t("li",null,"ReentrantLock设计的目标是用来替代synchronized关键字。",-1),R={href:"https://codecopy.cn/post/ua7j1p",target:"_blank",rel:"noopener noreferrer"},U=n("<p><strong>ReentrantLock 和 synchronized 的区别</strong></p><table><thead><tr><th>特征</th><th>synchronized（<mark>推荐</mark>）</th><th>reentrantLock</th></tr></thead><tbody><tr><td>底层原理</td><td>JVM实现</td><td>JDK实现</td></tr><tr><td>性能区别</td><td>低-&gt;高（JDK5+）</td><td>高</td></tr><tr><td>锁的释放</td><td>自动释放（编译器保证）</td><td>手动释放（finally保证）</td></tr><tr><td>编码程度</td><td>简单</td><td>复杂</td></tr><tr><td>锁的粒度</td><td>读写不区分</td><td>读锁、写锁</td></tr><tr><td>高级功能</td><td>无</td><td>公平锁、非公平锁唤醒Condition分组唤醒中断等待锁</td></tr></tbody></table>",2),N={start:"5"},W=t("p",null,[t("strong",null,"Condition（线程等待与唤醒）")],-1),D=n("<li><code>Condition</code> 是和 <code>ReentrantLock</code> 搭配使用的 <strong>等待/通知</strong> 机制。</li><li>设计的目标是用来替代传统的 <code>wait()</code>/<code>notify()</code>，但 <strong>更灵活</strong>，控制线程执行顺序！</li>",2),Z={href:"https://codecopy.cn/post/gkuf8f",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.bilibili.com/video/BV1YUp2eKEpa",target:"_blank",rel:"noopener noreferrer"},V={href:"https://codecopy.cn/post/4n2wwz",target:"_blank",rel:"noopener noreferrer"},H={href:"https://chatgpt.com/canvas/shared/67b198f0b0d081918e2f53b6acd74052",target:"_blank",rel:"noopener noreferrer"},q=n("<ol><li><strong>基本概念</strong>： CompletableFuture 是 Java 8 引入的异步编程工具，扩展了 Future，支持链式回调、任务组合和异常处理。 <ul><li>既实现了 <code>Future</code> 接口，又实现了 <code>CompletionStage</code> 接口。</li><li>支持非阻塞式异步任务，提高系统吞吐量。</li><li>提供丰富的任务组合方式，如串行执行、并行执行、结果合并等。</li><li>提供异常处理机制，能够在任务失败时执行回退逻辑。</li></ul></li><li><strong>异步任务创建</strong>：<code>supplyAsync()</code> 有返回值，<code>runAsync()</code> 无返回值。 <ul><li><code>completedFuture()</code>：已完成，用于测试或默认值。</li></ul></li><li><strong>串行执行</strong>：<code>thenApply()</code> 转换结果，<code>thenAccept()</code> 只消费，<code>thenRun()</code> 只执行任务。</li><li><strong>并行组合</strong>：<code>thenCombine()</code> 组合结果，<code>allOf()</code> 等待所有完成，<code>anyOf()</code> 选取最快的。</li><li><strong>异常处理</strong>：<code>exceptionally()</code> 处理异常默认值，<code>handle()</code> 处理异常并可返回新值，<code>whenComplete()</code> 记录异常但不改变结果。</li></ol>",1),K=n('<h3 id="并发容器-collections" tabindex="-1"><a class="header-anchor" href="#并发容器-collections"><span><strong>并发容器 (Collections)</strong></span></a></h3><p><strong>面试题：线程安全的类</strong></p><table><thead><tr><th><strong>类别</strong></th><th><strong>线程安全</strong></th><th><strong>线程不安全</strong></th></tr></thead><tbody><tr><td><strong>List</strong>（列表）</td><td><code>Vector</code></td><td><code>ArrayList</code>、<code>LinkedList</code></td></tr><tr><td><strong>Set</strong>（集合）</td><td>❌（默认都不安全）</td><td><code>HashSet</code>、<code>TreeSet</code></td></tr><tr><td><strong>Map</strong>（映射）</td><td><code>Hashtable</code></td><td><code>HashMap</code></td></tr><tr><td><strong>Properties</strong></td><td><code>Properties</code>（继承 <code>Hashtable</code>，线程安全）</td><td>❌</td></tr><tr><td><strong>String</strong></td><td><code>StringBuffer</code></td><td><code>StringBuilder</code></td></tr></tbody></table><p><strong>JUC下线程安全的并发容器</strong></p><ul><li><code>ArrayList</code> -&gt; CopyOnWriteArrayList - 写复制列表</li><li><code>HashSet</code> -&gt; CopyOnWriteArraySet - 写复制集合</li><li><code>HashMap</code> -&gt; <strong>ConcurrentHashMap</strong> - 分段锁映射</li></ul>',5),Q=t("h3",{id:"原子对象-atomic",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#原子对象-atomic"},[t("span",null,[t("strong",null,"原子对象 (Atomic)")])])],-1),Y=t("li",null,[t("strong",null,"原子性 (Atomicity)"),o("： "),t("ul",null,[t("li",null,[t("strong",null,"定义"),o("：一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。")])])],-1),G={href:"https://codecopy.cn/post/zgx6tt",target:"_blank",rel:"noopener noreferrer"},X=n("<ul><li><strong>乐观锁</strong>： <ul><li>每次不加锁，而是假设没有冲突而去完成某项操作。如果因为冲突失败，就重试，直到成功。</li></ul></li><li><strong>悲观锁</strong>： <ul><li>假设最坏情况，独占资源，确保不会被其它线程修改。例如 <code>synchronized</code>，数据库 <code>select... for update</code>。</li></ul></li></ul>",1),$=t("strong",null,[t("code",null,"Atomic"),o(" 包")],-1),tt=t("li",null,"提供无锁（lock-free）的原子类，确保并发数据安全，适用于高并发场景。",-1),ot=t("li",null,[t("strong",null,"原理"),o("：通过 "),t("code",null,"CAS"),o("（Compare And Swap）操作，保证数据的原子性。")],-1),et={href:"https://codecopy.cn/post/o904qw",target:"_blank",rel:"noopener noreferrer"},lt=n('<table><thead><tr><th><strong>分类</strong></th><th><strong>类名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>基本类型</strong></td><td><code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></td><td>提供基本类型的原子操作</td></tr><tr><td><strong>数组类型</strong></td><td><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code></td><td>对数组元素进行原子更新</td></tr><tr><td><strong>引用类型</strong></td><td><code>AtomicReference&lt;T&gt;</code>、<code>AtomicStampedReference&lt;T&gt;</code>、<code>AtomicMarkableReference&lt;T&gt;</code></td><td>适用于对象引用的原子更新，支持版本控制和标记</td></tr><tr><td><strong>字段更新器</strong></td><td><code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code></td><td>允许对 <code>volatile</code> 修饰的字段进行原子更新</td></tr></tbody></table><ol start="4"><li><strong>解决 ABA 问题</strong><ul><li>当变量从 <code>A → B → A</code> 变化，CAS 可能认为它未被修改，导致错误。</li><li>解决方案：使用 <code>AtomicStampedReference</code> 记录版本号。</li></ul></li></ol>',2);function nt(rt,it){const l=i("ExternalLinkIcon"),r=i("Mermaid");return d(),a("div",null,[g,t("ul",null,[t("li",null,[t("a",h,[o("🐟代码小抄-并发统计App Store下载次数"),e(l)])])]),u,t("p",null,[t("a",p,[o("bilibili-磊哥-什么是Java内存模型（JMM）？"),e(l)])]),m,t("ul",null,[t("li",null,[t("a",_,[o("🐟代码小抄-Java创建线程的三种方式"),e(l)]),f])]),y,t("ul",null,[t("li",null,[t("a",b,[o("🐟代码小抄-Synchronized 三种使用场景"),e(l)]),o("，对应不同锁对象： "),A])]),v,t("ul",null,[t("li",null,[t("a",k,[o("🐟代码小抄-Java线程的6种状态"),e(l)])])]),e(r,{id:"mermaid-451",code:"eJx9ks9LAkEUx+/+FYOnMRCho4dAcwlJNxDDQ0QstdWG7sa6FnaTEJRMhUwD6YeS5MUfJwMX8q+Z2fW/aGZ3p3Utgj3Mm/d5733fdzavCZoYk4QzVcgFrzZ9AFg3wI/bU6TPAeS5TMAPhDwgBzeLGhNz0TR7NQBT+zwfiSY4m2KRiy6fdNR7ATCa2Nve5WI25gQuZYyq6KsMYCYST8f5HZtyApcyxz3cmTE2HU9ysSNPhedqpbtewaM+qeBSyTgfSTMZbuwj8MHGIQgGt+imIAyM+cIY3qFKl9hAki5qMZRljKE/4OdXwpCP1tI884FA5vTWaA2pFFWDAcL85CjoOEG5RReVB6hZw6PBslUCMF+Uj89VRZZuxBNax9D1/vVP1GiTCtSs41Ifvd/bUjxjHEtcOdeCRNSEwIUiyTAAIO68mbMycZdOYvTfm8iKJp0WabF9imSz1l7rMz2PsWJEVhQvoSblRNLBkkHPSkFjalhIXfe0WJdj6Q39L+uXKPcdw0At0N1x9YP8yWhcw5NH3zczYRd0"}),C,t("ol",null,[t("li",null,[t("p",null,[t("a",E,[o("🐟代码小抄-Java死锁的案例"),e(l)])])]),x]),T,t("ol",null,[J,t("li",null,[t("p",null,[t("a",B,[o("🐟代码小抄-Executors线程池的4种创建方式"),e(l)])]),j]),t("li",null,[S,t("ul",null,[t("li",null,[t("a",z,[o("bilibili-老齐-阿里为什么要禁用Java内置线程池？"),e(l)])])])])]),w,t("p",null,[t("a",M,[o("🐟代码小抄-JUC同步工具实战：黑神话悟空开服场景"),e(l)]),o("，理解使用场景，掌握API")]),t("ol",null,[P,t("li",null,[F,t("ul",null,[I,L,t("li",null,[t("a",R,[o("🐟代码小抄-ReentrantLock三大特性&扩展功能"),e(l)])])])])]),U,t("ol",N,[t("li",null,[W,t("ul",null,[D,t("li",null,[t("a",Z,[o("🐟代码小抄-Condition结合ReentrantLock的应用场景"),e(l)])])])]),t("li",null,[t("p",null,[t("a",O,[o("bilibili-老齐-CompletableFuture多线程编排实践"),e(l)])]),t("ul",null,[t("li",null,[t("a",V,[o("🐟代码小抄-CompletableFuture使用"),e(l)])]),t("li",null,[t("a",H,[o("🤖CatGPT-CompletableFuture 多线程编排实践"),e(l)])])]),q])]),K,e(r,{id:"mermaid-1091",code:"eJx9k81Kw0AUhfc+RV7F6sJFxUpE1zGd2qFpJkySRZZCW1OoWNHSiFVbUCqCUhAjmqLvIk7SrPoKTn5tzNhV4N7znXNvblKHcrkuKCschxHS6IPjilDV5lOTmP3Z6H4+bYdFjvsaNLldIGoIJ4WrDreKsWAEwIJoDSnGlryHoQbSduDXuiC3x8S0c8bUpwjlGiinRjwICP+yRbpmVrghqFXaXRIXsWlaziREZFHHGMgaX4NKkBpDbzY5OZ29PtP5WOE7GIAkfFNQKOFaQzJpZN2DETVhXwJxLaqWMFIA1iBQKeY5Y7f9OTt6+BXn16QJzJnjXniilvv04p8fssbILxlDC0tmuW0d6HQO07du6I3+c4tOlWjd/tDrdfyzj+CVMbhIXZCQWIPyQUoN2kup8JBsyO1NPKfBgkoYIvoV5LjvqUWapvc+9i2HjK5Z6DqQBCPRE8d2+zZLxhuyWMVIRrqairsd9/EuK+Y1TONp8w8dlgt6pQIWf6GkDKUyra/8AMQWqDU="}),Q,t("ol",null,[Y,t("li",null,[t("a",G,[o("🐟代码小抄-乐观锁 vs 悲观锁"),e(l)]),X]),t("li",null,[$,t("ul",null,[tt,ot,t("li",null,[t("a",et,[o("🐟代码小抄-原子对象 (Atomic) 的使用"),e(l)])])])])]),lt])}const at=s(c,[["render",nt],["__file","thread-concurrency.html.vue"]]),ct=JSON.parse('{"path":"/md/java/thread/thread-concurrency.html","title":"Java多线程与并发编程","lang":"zh-CN","frontmatter":{"title":"Java多线程与并发编程","shortTitle":null,"description":"Java多线程与并发编程 你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。 目标 基本概念 (Basic) 多线程 (Thread) 线程池 (Executor) 并发容器 (Collections) 同步工具 (Tools) 原子对象 (Atomic) Java多线程并发编程6大核心Java多线程并发编程...","icon":null,"cover":null,"author":"流浪码客","isOriginal":true,"sticky":false,"star":false,"date":"2025-02-18T00:00:00.000Z","category":"并发编程","tag":["JUC"],"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java/thread/thread-concurrency.html"}],["meta",{"property":"og:title","content":"Java多线程与并发编程"}],["meta",{"property":"og:description","content":"Java多线程与并发编程 你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。 目标 基本概念 (Basic) 多线程 (Thread) 线程池 (Executor) 并发容器 (Collections) 同步工具 (Tools) 原子对象 (Atomic) Java多线程并发编程6大核心Java多线程并发编程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.geekyspace.cn/pictures/2025/image-20250217013332469.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-16T11:22:52.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:published_time","content":"2025-02-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-16T11:22:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java多线程与并发编程\\",\\"image\\":[\\"http://img.geekyspace.cn/pictures/2025/image-20250217013332469.png\\"],\\"datePublished\\":\\"2025-02-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-16T11:22:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":2,"title":"并发背后的故事","slug":"并发背后的故事","link":"#并发背后的故事","children":[]},{"level":2,"title":"你必须知道的概念","slug":"你必须知道的概念","link":"#你必须知道的概念","children":[]},{"level":2,"title":"Java内存模型（JMM）","slug":"java内存模型-jmm","link":"#java内存模型-jmm","children":[]},{"level":2,"title":"创建线程的三种方式","slug":"创建线程的三种方式","link":"#创建线程的三种方式","children":[]},{"level":2,"title":"Synchronized线程同步机制","slug":"synchronized线程同步机制","link":"#synchronized线程同步机制","children":[]},{"level":2,"title":"Java线程的6种状态","slug":"java线程的6种状态","link":"#java线程的6种状态","children":[]},{"level":2,"title":"死锁的产生","slug":"死锁的产生","link":"#死锁的产生","children":[]},{"level":2,"title":"重新认识线程安全（ThreadSafe）","slug":"重新认识线程安全-threadsafe","link":"#重新认识线程安全-threadsafe","children":[]},{"level":2,"title":"JUC并发工具","slug":"juc并发工具","link":"#juc并发工具","children":[{"level":3,"title":"线程池（Executor）","slug":"线程池-executor","link":"#线程池-executor","children":[]},{"level":3,"title":"同步工具 (Tools)","slug":"同步工具-tools","link":"#同步工具-tools","children":[]},{"level":3,"title":"并发容器 (Collections)","slug":"并发容器-collections","link":"#并发容器-collections","children":[]},{"level":3,"title":"原子对象 (Atomic)","slug":"原子对象-atomic","link":"#原子对象-atomic","children":[]}]}],"git":{"createdTime":1758021772000,"updatedTime":1758021772000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":12.07,"words":3622},"filePathRelative":"md/java/thread/thread-concurrency.md","localizedDate":"2025年2月18日","excerpt":"\\n<blockquote>\\n<p>你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。</p>\\n</blockquote>\\n<h2>目标</h2>\\n<ul>\\n<li><strong>基本概念 (Basic)</strong></li>\\n<li><strong>多线程 (Thread)</strong></li>\\n<li><a href=\\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0-executor\\">线程池 (Executor)</a></li>\\n<li><a href=\\"#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-collections\\">并发容器 (Collections)</a></li>\\n<li><a href=\\"#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-tools\\">同步工具 (Tools)</a></li>\\n<li><a href=\\"#%E5%8E%9F%E5%AD%90%E5%AF%B9%E8%B1%A1-atomic\\">原子对象 (Atomic)</a></li>\\n</ul>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{at as comp,ct as data};
