import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c as i,a as n,b as s,d as p,e as a}from"./app-CARt6Xo2.js";const c={},u=a('<h1 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制"><span>类加载机制</span></a></h1><h2 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h2><blockquote><p>类的生命周期将会经历<strong>加载</strong> （Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）七个阶段</p></blockquote><ul><li>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。</li><li>解析阶段不一定，某些情况下可以在初始化之后，以支持Java的运行时绑定（动态绑定）特性。</li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/202407260441081.png" alt="类的生命周期" tabindex="0" loading="lazy"><figcaption>类的生命周期</figcaption></figure><ul><li>注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。</li></ul><h2 id="class实例何时被创建" tabindex="-1"><a class="header-anchor" href="#class实例何时被创建"><span>Class实例何时被创建</span></a></h2><p>在Java虚拟机(JVM)规范中，类的<strong>加载</strong>过程是由JVM自行决定的，但<strong>初始化</strong>过程则必须严格按照规范执行。 （在初始化之前，类的加载、验证、准备阶段必然已经完成）。</p><h3 id="主动引用-六种情况" tabindex="-1"><a class="header-anchor" href="#主动引用-六种情况"><span>主动引用（六种情况）</span></a></h3><blockquote><p>在Java虚拟机规范中，“有且只有”以下六种情况会触发类的初始化，称为对一个类的<u><strong>主动引用</strong></u>：</p></blockquote>',10),r=a("<li>创建对象实例、访问静态字段（非常量）、调用静态方法 <ul><li>即遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这 4 种字节码指令。</li></ul></li><li><strong>反射调用</strong> 使用<code>java.lang.reflect</code>对类型（类和接口）进行反射调用</li><li>初始化子类时，先初始化父类</li><li><strong>启动主类</strong>，JVM启动时，先初始化包含<code>main()</code>方法的主类。</li>",4),d=n("strong",null,"JDK 1.7的动态语言支持",-1),k={href:"https://www.infoq.cn/article/jdk-dynamically-typed-language/",target:"_blank",rel:"noopener noreferrer"},g=n("li",null,[s("JDK 1.7 引入"),n("code",null,"java.lang.invoke.MethodHandle"),s(" 动态语言支持，解析静态字段/方法或构造方法时")],-1),m=n("li",null,[s("即解析的句柄属于"),n("code",null,"REF_getStatic"),s("、"),n("code",null,"REF_putStatic"),s("、"),n("code",null,"REF_invokeStatic"),s("或"),n("code",null,"REF_newInvokeSpecial"),s("四种情况时，会触发目标类初始化。")],-1),v=n("li",null,[n("strong",null,"接口默认方法"),s("初始化规则 "),n("ul",null,[n("li",null,[s("JDK 1.8 新增"),n("code",null,"default"),s("默认方法，若实现类初始化，则需要先初始化该接口。")])])],-1),h=a(`<h3 id="被动引用-不触发" tabindex="-1"><a class="header-anchor" href="#被动引用-不触发"><span>被动引用（不触发）</span></a></h3><blockquote><p>除了以上六种场景外，所有其他引用类的方式都不会触发初始化，称为<u><strong>被动引用</strong></u>。</p></blockquote><ul><li><strong>例1：通过子类引用父类的静态字段，不会导致子类初始化，只有父类会被初始化</strong><ul><li>子类是否加载和验证，取决于虚拟机的具体实现。</li><li>在HotSpot虚拟机（JDK 1.8 亲测）中，使用<code>-XX:+TraceClassLoading</code>观察到此操作会导致子类加载。</li></ul></li><li><strong>例2：通过数组定义来引用类，不会触发此类的初始化</strong><ul><li>例如，<code>MyClass[] sca = new MyClass[10];</code>，不会初始化<code>MyClass</code>类</li><li>但这段代码触发了另一个名为<code>[L包名.MyClass</code>的类的初始化阶段。它是由虚拟机自动生成的、继承自<code>java.lang.Object</code> 的子类，由字节码指令<code>newarray</code>触发。这个类表示<code>MyClass</code>的一维数组，包含数组应有的属性和方法（如<code>public</code>的<code>length</code> 属性和<code>clone()</code>方法）。</li><li>Java语言对数组的访问比C/C++更安全，因为这个类包装了数组元素的访问，C/C++中直接翻译为对数组指针的移动。 在Java语言里，发生数组越界时会抛出<code>java.lang.ArrayIndexOutOfBoundsException</code>异常，避免非法内存访问。</li></ul></li><li><strong>例3：引用常量不会触发定义常量的类的初始化</strong><ul><li>因为常量在编译阶段就会被存入调用类的常量池中。</li></ul></li></ul><h3 id="接口和类-加载与初始化-的差异" tabindex="-1"><a class="header-anchor" href="#接口和类-加载与初始化-的差异"><span>接口和类“加载与初始化”的差异</span></a></h3><p><strong>相同点</strong></p><ul><li>类 &amp; 接口都经历：加载 → 验证 → 准备 → 解析 → <strong>初始化（<code>&lt;clinit&gt;()</code>）</strong></li></ul><p><strong>差异</strong></p><ul><li>接口不能使用<code>static{}</code>语句块，但编译器仍会生成<code>&lt;clinit&gt;()</code>方法用于初始化静态变量。</li><li>类在初始化时，其父类必须先初始化。</li><li>接口在初始化时不要求父接口初始化，只有在真正使用到父接口的常量等成员时才会触发其初始化。</li></ul><h2 id="类加载的过程" tabindex="-1"><a class="header-anchor" href="#类加载的过程"><span>类加载的过程</span></a></h2><p>Java类加载过程主要分为<strong>加载</strong>、<strong>连接</strong>（验证、准备、解析）、<strong>初始化</strong>三个阶段。</p><h3 id="加载-loading" tabindex="-1"><a class="header-anchor" href="#加载-loading"><span>加载（Loading）</span></a></h3><blockquote><ol><li>通过类的全限定名<strong>读取类的二进制字节流</strong>。</li><li>并将字节流所代表的 静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li><li>在<strong>堆</strong>内存中生成<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的的访问入口。</li></ol></blockquote><ul><li><strong>类文件来源：</strong><ul><li>通常包括本地文件系统、压缩文件（如JAR、WAR）、网络、数据库、加密文件（防止反编译）、运行时动态生成，以及由其他文件生成（如JSP应用生成的Class文件）。</li></ul></li><li><strong>数组类加载：</strong><ul><li>数组类本身不通过类加载器创建，而是由Java虚拟机直接在内存中构建出来。但数组类的元素类型最终还是靠类加载器来完成加载。</li></ul></li></ul><img src="http://img.geekyspace.cn/pictures/2025/image-20250302011909381.png" alt="image-20250302011909381" style="zoom:60%;"><h3 id="连接-linking" tabindex="-1"><a class="header-anchor" href="#连接-linking"><span>连接（Linking）</span></a></h3><p>分为三个阶段：</p><ul><li><strong>验证</strong>（Verify）：确保字节码符合虚拟机要求</li><li><strong>准备</strong>（Prepare）：为字段赋予初始值</li><li><strong>解析</strong>（Resolve）：符号引用转换为直接引用</li></ul><blockquote><p><strong>验证</strong>（Verify）是连接阶段的第一阶段，目的是确保字节码的正确性和安全性，包括文件格式验证、元数据验证、字节码验证和符号引用验证四个阶段。</p></blockquote><p>验证阶段大致上会完成下面四个阶段的检验动作：</p><ol><li><strong>文件格式验证：</strong> 检查字节流是否符合Class文件的格式规范。</li><li><strong>元数据验证：</strong> 对类的元数据信息进行语义校验，确保其符合Java语言的语法和语意规则。</li><li><strong>字节码验证：</strong> 通过数据流分析和控制流分析，确保字节码指令的合法性和逻辑正确性。</li><li><strong>符号引用验证：</strong> 在解析阶段之前，检查符号引用是否能被正确解析。</li></ol><figure><img src="http://img.geekyspace.cn/pictures/2025/image-20250302022044718.png" alt="验证阶段" tabindex="0" loading="lazy"><figcaption>验证阶段</figcaption></figure><blockquote><p><strong>准备</strong>（Prepare）阶段为类中的静态变量分配内存并设置初始值。</p></blockquote><p>静态变量的内存分配发生在<strong>方法区</strong>中。</p><ul><li>在 JDK 7及之前，HotSpot使用<strong>永久代</strong>（PerGen）来实现方法区，存放在堆内存中。</li><li>在 JDK 8及之后，永久代被移除，取而代之的是<strong>元空间</strong>（Metaspace），存放在操作系统本地内存中。</li></ul><img src="http://img.geekyspace.cn/pictures/2025/image-20250302023259231.png" alt="准备阶段" style="zoom:60%;"><blockquote><p><strong>解析</strong>（Prepare）阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><ul><li><strong>符号引用（Symbolic References）：</strong> 字符串形式表示的对目标的逻辑引用</li><li><strong>直接引用（Direct References）：</strong> 是直接定位到目标内存位置的指针、偏移量或句柄。</li></ul><p>解析动作主要针对<u>类或接口</u>、<u>字段</u>、<u>类方法</u>、<u>接口方法</u>、<u>方法类型</u>、<u>方法句柄</u>和<u>调用点限定符</u>这 7 类符号引用进行。</p><h3 id="初始化-initialization" tabindex="-1"><a class="header-anchor" href="#初始化-initialization"><span>初始化（Initialization）</span></a></h3><blockquote><p>类加载过程的最后一个阶段，负责执行类构造器方法 <code>&lt;clinit&gt;</code>。</p></blockquote><ul><li><strong>自动生成：</strong> 由javac编译自动生成<code>&lt;clinit&gt;</code>，是所有静态变量赋值和静态代码块的集合。</li><li><strong>非法前向引用：</strong> 静态语句块中只能访问定义在其之前的变量。</li><li>父类的 <code>&lt;clinit&gt;</code> 方法会先于子类的 <code>&lt;clinit&gt;</code> 方法执行。</li><li>如果一个类没有静态语句块和静态变量的赋值操作，那么编译器可能不会生成 <code>&lt;clinit&gt;</code> 方法。</li><li><code>+TraceClassLoading</code> 查看类加载过程</li><li>多线程环境下，类的初始化可能会出现并发问题，JVM会保证<code>&lt;clinit&gt;</code>方法的线程安全执行。</li></ul><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h2><blockquote><p>加载阶段“通过一个类的全限定名来获取描述该类的二进制字节流”，这个动作的代码被称为“类加载器”（Class Loader）。</p></blockquote><h3 id="类与类加载器" tabindex="-1"><a class="header-anchor" href="#类与类加载器"><span>类与类加载器</span></a></h3><p>一个类在JVM中由其完全限定名和对应的类加载器共同确定唯一性。 即使两个类具有相同的完全限定名，由不同的类加载器加载的，JVM也会将它们视为两个“不相等”的类。</p><ul><li>“不相等” 包括Class对象的<code>equals</code>方法，<code>isAssignableFrom()</code>方法，<code>isInstance()</code>方法的返回结果。</li></ul><p><strong>不同的类加载器对instanceof关键字运算的结果的影响</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 类加载器与instanceof关键字演示
 *
 * <span class="token keyword">@author</span> zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个自定义的类加载器</span>
        <span class="token class-name">ClassLoader</span> myLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取类名对应的文件名（去除包名，只保留类名）</span>
                    <span class="token class-name">String</span> fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.class&quot;</span><span class="token punctuation">;</span>
                    <span class="token comment">// 从当前类路径中加载Class文件</span>
                    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 如果找不到文件，则调用父类加载器加载</span>
                        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token class-name">Object</span> obj <span class="token operator">=</span> myLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;org.fenixsoft.classloading.ClassLoaderTest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading<span class="token punctuation">.</span></span>ClassLoaderTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>class org.fenixsoft.classloading.ClassLoaderTest
<span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型"><span>双亲委派模型</span></a></h3><p>双亲委派模型是Java类加载机制的一种设计模式 ，用于确保类的唯一性和安全性。 它规定，类加载器在接收到类加载请求时，首先将该请求委派给父类加载器处理。 如果父类加载器无法完成加载，子类加载器才会尝试加载该类。</p><figure><img src="https://img.geekyspace.cn/pictures/2024/202408100244787.png" alt="类加载器双亲委派模型（JDK 8及之前）" tabindex="0" loading="lazy"><figcaption>类加载器双亲委派模型（JDK 8及之前）</figcaption></figure><ul><li>从Java虚拟机的角度，类加载器分为两类： <ul><li>启动类加载器（Bootstrap ClassLoader）：这是Java虚拟机的一部分，使用<code>C++</code>实现，负责加载核心类库，如<code>rt.jar</code>中的类。这个类加载器不可被Java程序直接引用。</li><li>其他类加载器：这些是由Java实现的类加载器，继承自<code>java.lang.ClassLoader</code>，并且独立存在于虚拟机之外。</li></ul></li><li>从Java开发人员的角度，可以细分为三层类加载器： <ul><li><strong>启动类加载器</strong>（Bootstrap ClassLoader）：加载<code>&lt;JAVA_HOME&gt;\\lib</code>目录中的核心类库。</li><li><strong>扩展类加载器</strong>（Extension ClassLoader）：加载<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录或通过java.ext.dirs指定路径中的扩展类库。</li><li><strong>应用程序类加载器</strong>（Application ClassLoader）：加载用户类路径（ClassPath）上的所有类库，通常是程序的默认类加载器。</li></ul></li></ul><p><strong>双亲委派模型的实现</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先，检查请求的类是否已经被加载过了</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果该类还未被加载</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果存在父类加载器</span>
                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 让父类加载器尝试加载该类</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果没有父类加载器，尝试用引导类加载器加载</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果父类加载器抛出 ClassNotFoundException</span>
            <span class="token comment">// 说明父类加载器无法完成加载请求，继续在本加载器中寻找</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 在父类加载器无法加载时</span>
            <span class="token comment">// 调用本加载器的 findClass 方法来加载类</span>
            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment">// 返回加载的类</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="破坏双亲委派模型" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派模型"><span>破坏双亲委派模型</span></a></h3><p>双亲委派模型并不是强制性约束的模型，直到Java模块化出现为止，出现过3次较大规模“被破坏”的情况。</p><p><strong>第 1 次被破坏：</strong></p><p>在JDK 1.2之前，由于没有双亲委派模型的约束，开发者可以直接覆盖 <code>loadClass()</code> 方法。 为了兼容现有代码并引导开发者遵循双亲委派模型，JDK 1.2引入了 <code>findClass()</code> 方法，建议开发者重写该方法而非直接覆盖 <code>loadClass()</code>。</p><ul><li><strong>loadClass()：</strong> 双亲委派模型的实现，父类加载异常时，调用 <code>findClass()</code> 方法进行加载。</li><li><strong>findClass()：</strong> 自定义类加载器具体实现。</li></ul><hr><p><strong>第 2 次被破坏：</strong></p><p>由于基础类型有时需调用用户代码，如JNDI（Java命名和目录接口）加载SPI（服务提供者接口）代码，这打破了双亲委派模型的层次结构来逆向使用类加载器。</p><ul><li>Java引入一个不太优雅的设计：线程上下文类加载器，来实现SPI加载。当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断。</li><li>为了消除这种极不优雅的实现方式，在JDK 6时，引入了 <code>java.util.ServiceLoader</code>，以 <code>META-INF/services</code> 中的配置信息，辅以责任链模式，提供了更合理的SPI加载方式。</li></ul><hr><p><strong>第 3 次被破坏：</strong></p><p>由于用户对程序动态性的追求，如代码热替换（Hot Swap）和模块热部署（Hot Deployment），导致双亲委派模型在OSGi中再次“被破坏”。 这种“动态性”在大型系统或企业级软件中尤其重要，因为频繁重启生产系统可能会被视为生产事故。</p><ul><li><strong>OSGi中的类加载器机制：</strong><ul><li>每个OSGi模块（Bundle）都有一个独立的类加载器。更换 Bundle 时，同时替换其类加载器，实现代码热替换。</li></ul></li><li><strong>类加载顺序：</strong><ul><li>以 <code>java.*</code> 开头的类由父类加载器加载。</li><li>委派列表内的类由父类加载器加载。</li><li>Import 列表中的类由 Export 该类的 Bundle 加载器加载。</li><li>当前 Bundle 的 ClassPath 中的类由自己的类加载器加载。</li><li>Fragment Bundle 中的类由对应的类加载器加载。</li><li>Dynamic Import 列表中的类由对应 Bundle 的类加载器加载。</li><li>若以上均失败，则类加载失败。</li></ul></li></ul>`,59);function b(f,y){const t=o("ExternalLinkIcon");return l(),i("div",null,[u,n("ol",null,[r,n("li",null,[d,n("ul",null,[n("li",null,[n("a",k,[s("周志明-解析 JDK 7 的动态类型语言支持"),p(t)])]),g,m])]),v]),h])}const x=e(c,[["render",b],["__file","class-loading-mechanism.html.vue"]]),J=JSON.parse('{"path":"/md/java/jvm/part3/class-loading-mechanism.html","title":"类加载机制","lang":"zh-CN","frontmatter":{"title":"类加载机制","shortTitle":null,"description":"类加载机制 类的生命周期 类的生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。 解析阶段不一...","icon":null,"cover":null,"author":"流浪码客","isOriginal":true,"sticky":false,"star":false,"date":"2024-07-20T00:00:00.000Z","category":"JVM","tag":["jvm"],"order":7.3,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java/jvm/part3/class-loading-mechanism.html"}],["meta",{"property":"og:title","content":"类加载机制"}],["meta",{"property":"og:description","content":"类加载机制 类的生命周期 类的生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。 解析阶段不一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/202407260441081.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-16T11:18:00.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-07-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-16T11:18:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类加载机制\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/202407260441081.png\\",\\"http://img.geekyspace.cn/pictures/2025/image-20250302022044718.png\\",\\"https://img.geekyspace.cn/pictures/2024/202408100244787.png\\"],\\"datePublished\\":\\"2024-07-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-16T11:18:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[]},{"level":2,"title":"Class实例何时被创建","slug":"class实例何时被创建","link":"#class实例何时被创建","children":[{"level":3,"title":"主动引用（六种情况）","slug":"主动引用-六种情况","link":"#主动引用-六种情况","children":[]},{"level":3,"title":"被动引用（不触发）","slug":"被动引用-不触发","link":"#被动引用-不触发","children":[]},{"level":3,"title":"接口和类“加载与初始化”的差异","slug":"接口和类-加载与初始化-的差异","link":"#接口和类-加载与初始化-的差异","children":[]}]},{"level":2,"title":"类加载的过程","slug":"类加载的过程","link":"#类加载的过程","children":[{"level":3,"title":"加载（Loading）","slug":"加载-loading","link":"#加载-loading","children":[]},{"level":3,"title":"连接（Linking）","slug":"连接-linking","link":"#连接-linking","children":[]},{"level":3,"title":"初始化（Initialization）","slug":"初始化-initialization","link":"#初始化-initialization","children":[]}]},{"level":2,"title":"类加载器","slug":"类加载器","link":"#类加载器","children":[{"level":3,"title":"类与类加载器","slug":"类与类加载器","link":"#类与类加载器","children":[]},{"level":3,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[]},{"level":3,"title":"破坏双亲委派模型","slug":"破坏双亲委派模型","link":"#破坏双亲委派模型","children":[]}]}],"git":{"createdTime":1758021480000,"updatedTime":1758021480000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":11.3,"words":3390},"filePathRelative":"md/java/jvm/part3/class-loading-mechanism.md","localizedDate":"2024年7月20日","excerpt":"\\n<h2>类的生命周期</h2>\\n<blockquote>\\n<p>类的生命周期将会经历<strong>加载</strong> （Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）七个阶段</p>\\n</blockquote>\\n<ul>\\n<li>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。</li>\\n<li>解析阶段不一定，某些情况下可以在初始化之后，以支持Java的运行时绑定（动态绑定）特性。</li>\\n</ul>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{x as comp,J as data};
