import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as l,c as r,a as e,b as t,d as c,w as s,e as i}from"./app-CARt6Xo2.js";const p={},d=e("h1",{id:"堆中对象分配、布局和访问的全过程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#堆中对象分配、布局和访问的全过程"},[e("span",null,"堆中对象分配、布局和访问的全过程")])],-1),h=e("blockquote",null,[e("p",null,"本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。")],-1),m=e("h2",{id:"对象的创建",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#对象的创建"},[e("span",null,"对象的创建")])],-1),g=e("p",null,[t("在Java中，创建对象通常使用"),e("code",null,"new"),t("关键字，而在JVM中，创建对象的过程如下：")],-1),u=e("p",null,[e("strong",null,"1、类加载检查")],-1),_=e("code",null,"new",-1),v=i('<p><strong>2、分配内存</strong></p><p>JVM为新对象分配内存，其大小在类加载完成时确认，<strong>内存分配的方式：</strong></p><ol><li><strong>指针碰撞：</strong> 适用于规整的堆内存，将内存分为已使用和未使用两部分，通过移动指针分配内存。</li><li><strong>空闲列表：</strong> 适用于不规整的堆内存，JVM维护一个空闲列表，从中找到合适的内存块进行分配。</li></ol><p>使用压缩整理功能的收集器（如Serial、ParNew）通常采用指针碰撞分配，而基于标记-清除（Sweep）算法的CMS收集器使用空闲列表分配。</p><p><strong>线程安全的内存分配方式：</strong></p><ul><li><strong>同步处理：</strong> 通过同步操作或CAS加重试机制确保原子性。</li><li><strong>线程本地分配缓冲（TLAB）：</strong> 每个线程在Java堆中预先分配一小块内存，分配时在<code>TLAB</code>中进行， 只有<code>TLAB</code>耗尽分配新的<code>TLAB</code>时才才需同步。 <ul><li>通过<code>-XX:+UseTLAB</code>参数来启用<code>TLAB</code>。</li></ul></li></ul><p><strong>3、初始化零值（不包括对象头）</strong></p><p>JVM将分配的内存空间（不包括对象头）初始化为零值，确保对象字段在未显式初始化时可直接使用。</p><p><strong>4、设置对象头</strong></p><p>JVM设置对象头，包括：</p><ul><li><strong>Mark Word：</strong> 存储对象的哈希码（调用<code>Object::hashCode()</code>时计算）、GC分代年龄、锁信息等。</li><li><strong>类元数据指针：</strong> 指向对象所属类的元数据，确定对象是哪个类的实例。</li></ul><p><strong>5、执行<code>&lt;init&gt;</code>方法</strong></p><p>至此，在JVM层面，一个新的对象已经产生了。 但从Java程序视角，对象创建才刚刚开始，所有的字段都还为零值。 只有构造方法<code>&lt;init&gt;</code>执行后，对象才按照程序员的意图完成初始化，成为一个真正可用的对象。</p><h2 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局"><span>对象的内存布局</span></a></h2><h2 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位"><span>对象的访问定位</span></a></h2>',15);function J(f,B){const o=n("RouteLink");return l(),r("div",null,[d,h,m,g,u,e("p",null,[t("JVM首先检查"),_,t("指令所引用的类是否已加载、连接和初始化。 如果没有，会先执行"),c(o,{to:"/md/jvm/part3/class-loading-mechanism.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"},{default:s(()=>[t("类加载过程")]),_:1}),t("。")]),v])}const V=a(p,[["render",J],["__file","heap-object-flow.html.vue"]]),M=JSON.parse('{"path":"/md/java/jvm/part2/heap-object-flow.html","title":"堆中对象分配、布局和访问的全过程","lang":"zh-CN","frontmatter":{"title":"堆中对象分配、布局和访问的全过程","shortTitle":null,"description":"堆中对象分配、布局和访问的全过程 本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。 对象的创建 在Java中，创建对象通常使用new关键字，而在JVM中，创建对象的过程如下： 1、类加载检查 JVM首先检查new指令所引用的类是否已加载、连接和初始化。 如果没有，会先执行。 2、分配内存 JVM为新对象分配内存，其大小在类...","icon":null,"cover":null,"author":"流浪码客","isOriginal":true,"sticky":false,"star":false,"date":"2024-08-10T00:00:00.000Z","category":"JVM","tag":["jvm"],"order":2.3,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java/jvm/part2/heap-object-flow.html"}],["meta",{"property":"og:title","content":"堆中对象分配、布局和访问的全过程"}],["meta",{"property":"og:description","content":"堆中对象分配、布局和访问的全过程 本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。 对象的创建 在Java中，创建对象通常使用new关键字，而在JVM中，创建对象的过程如下： 1、类加载检查 JVM首先检查new指令所引用的类是否已加载、连接和初始化。 如果没有，会先执行。 2、分配内存 JVM为新对象分配内存，其大小在类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-16T11:18:00.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-08-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-16T11:18:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆中对象分配、布局和访问的全过程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-16T11:18:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"对象的创建","slug":"对象的创建","link":"#对象的创建","children":[]},{"level":2,"title":"对象的内存布局","slug":"对象的内存布局","link":"#对象的内存布局","children":[]},{"level":2,"title":"对象的访问定位","slug":"对象的访问定位","link":"#对象的访问定位","children":[]}],"git":{"createdTime":1758021480000,"updatedTime":1758021480000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":2.13,"words":640},"filePathRelative":"md/java/jvm/part2/heap-object-flow.md","localizedDate":"2024年8月10日","excerpt":"\\n<blockquote>\\n<p>本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。</p>\\n</blockquote>\\n<h2>对象的创建</h2>\\n<p>在Java中，创建对象通常使用<code>new</code>关键字，而在JVM中，创建对象的过程如下：</p>\\n<p><strong>1、类加载检查</strong></p>\\n<p>JVM首先检查<code>new</code>指令所引用的类是否已加载、连接和初始化。\\n如果没有，会先执行<a href=\\"/md/jvm/part3/class-loading-mechanism.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B\\" target=\\"_blank\\">类加载过程</a>。</p>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{V as comp,M as data};
