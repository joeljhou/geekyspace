import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as s,c,a as e,b as l,d as a,w as g,e as i}from"./app-CARt6Xo2.js";const p={},u=i('<h1 id="java虚拟机概述" tabindex="-1"><a class="header-anchor" href="#java虚拟机概述"><span>Java虚拟机概述</span></a></h1><blockquote><p><strong>Java虚拟机</strong>（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。 它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。 JVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Write Once, Run Anywhere”。</p></blockquote><h2 id="跨平台开发的通用平台" tabindex="-1"><a class="header-anchor" href="#跨平台开发的通用平台"><span>跨平台开发的通用平台</span></a></h2><p>随着发展，JVM不再是Java独享的Moment，越来越多的语言开始在JVM上运行，使JVM逐渐演变成一个<strong>跨平台开发的通用平台</strong>。</p><figure><img src="https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png" alt="jvm-class" tabindex="0" loading="lazy"><figcaption>jvm-class</figcaption></figure><ul><li>JVM本质上只关心<code>.class</code>的字节码文件，而不关心源代码是用什么语言编写的。</li><li>通过Oracle TCK（Technology Compatibility Kit）测试，就是合格的Java虚拟机。</li></ul><h2 id="java虚拟机家族" tabindex="-1"><a class="header-anchor" href="#java虚拟机家族"><span>Java虚拟机家族</span></a></h2><p><strong>虚拟机始祖：Sun Classic/Exact VM（Sun/Oracle公司）</strong></p><ul><li><strong>Classic VM：</strong><ul><li>1996年1月23日，Sun发布JDK 1.0，正式商用，最早的Java虚拟机实现</li><li>直到JDK 1.4，才完全退出商用虚拟机的历史舞台</li><li><mark>纯解释器</mark>，可外挂即时编译器（JIT），<strong>缺点</strong>是只能<u>二选一</u></li></ul></li><li><strong>Exact VM：</strong><ul><li>在JDK 1.2时，在Solaris平台发布，是Classic VM的改进版</li><li>因准确式内存管理（Exact Memory Management）而得名，是垃圾收集时准确判断堆上数据的前提</li><li>它的编译执行系统已经具备现代高性能虚拟机雏形 <ul><li>如热点探测、两级即时编译器、<mark>编译器与解释器混合工作</mark>模式等</li></ul></li><li><strong>缺点</strong>是<u>只能在Solaris平台上运行</u></li></ul></li></ul><p><strong>武林盟主：HotSpot VM（Sun/Oracle公司）</strong></p>',10),d=e("strong",null,"HotSpot VM",-1),h=e("li",null,"最初由Longview Technologies公司开发，后被Sun公司收购",-1),J=e("li",null,"从JDK 1.3至今（2024），HotSpot VM成为默认虚拟机，目前使用最广泛",-1),m=e("li",null,[l("HotSpot VM集成了Sun以上两款虚拟机优点（准确式内存管理，热点代码探测技术...） "),e("ul",null,[e("li",null,[e("strong",null,"优点"),l("是"),e("u",null,"同时支持解释执行和即时编译执行"),l("，在响应速度和执行速度上取得平衡")])])],-1),v=e("li",null,"Oracle收购Sun以后，建立HotRockit项目，把BEA JRocki优秀特性融合到HotSpot之中",-1),M=i("<p><strong>小家碧玉：Mobile/Embedded VM（Sun/Oracle公司）</strong></p><p>专门为移动设备和嵌入式设备设计的Java虚拟机（JavaME）</p><ul><li><strong>KVM（Kilobyte Virtual Machine）</strong>: <ul><li>用于早期的移动设备，但智能手机市场已被Android和iOS主导</li></ul></li><li><strong>CDC（Connected Device Configuration）</strong>: <ul><li>用于功能更强的嵌入式设备，但面临自家Java SE Embedded（eJDK）的竞争</li><li>由于Java SE的普及，CDC市场快速萎缩，Oracle基本砍掉了CDC-HI项目，将其划归Java SE Embedded</li></ul></li></ul><p><strong>天下第二：BEA JRockit/IBM J9 VM</strong></p>",4),_=e("li",null,[e("strong",null,"BEA JRockit"),l(": "),e("ul",null,[e("li",null,"最初由BEA Systems开发，后被Oracle收购，永远停留在R28（JDK 6版JRockit代号）"),e("li",null,[e("mark",null,"专注于服务器"),l("硬件和服务端应用场景，不关注启动速度，不包含解释器实现")]),e("li",null,"以其出色的垃圾收集器和性能和诊断工具（如Java Mission Control）著称")])],-1),f=e("strong",null,"IBM J9 VM",-1),V=e("li",null,"全称“IBM Technology for Java Virtual Machine”，简称IT4J，但普遍称为J9",-1),k=e("li",null,"作为通用型JVM，其市场定位接近HotSpot，主要优势在IBM产品上",-1),y={href:"https://www.eclipse.org/openj9/",target:"_blank",rel:"noopener noreferrer"},b=e("li",null,[l("模块化设计优于HotSpot "),e("ul",null,[e("li",null,"核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）构成了IBM OMR项目"),e("li",null,"可以在其他语言平台如Ruby、Python中快速组装成相应的功能")])],-1),w=i("<p><strong>软硬合璧：BEA Liquid VM/Azul VM（Zing）</strong></p><ul><li><p><strong>BEA Liquid VM</strong>:</p><ul><li>也被称为JRockit VE（Virtual Edition，VE），专为BEA WebLogic实时运行环境设计</li><li>BEA公司开发的JRockit虚拟机虚拟化版本，可直接运行在自家Hypervisor系统上</li><li>不需要操作系统支持，自身实现了必要的操作系统功能（如线程调度、文件系统、网络支持等）</li><li>直接控制硬件，避免内核态/用户态切换，最大限度发挥硬件性能，提升Java程序执行效率</li><li>随着JRockit虚拟机终止开发，Liquid VM项目也停止了</li></ul></li><li><p><strong>Azul VM</strong>:</p><ul><li>适用于Azul Systems专有硬件Vega产品线，在HotSpot基础改进</li><li>采用PGC和C4收集器，停顿时间可控，每个Azul VM实例可管理数十个CPU和数百GB内存</li></ul></li><li><p><strong>Zing VM</strong>:</p><ul><li>2010年起，Azul公司重心转向软件，发布Zing虚拟机，基于HotSpot某旧版代码分支</li><li>低延迟，配备PGC和C4垃圾收集器 <ul><li>支持TB级别Java堆内存，暂停时间不超过10毫秒</li><li>HotSpot直到JDK 11和JDK 12的ZGC和Shenandoah收集器才达到类似目标，但效果仍不及C4</li></ul></li><li>Zing的ReadyNow（快速预热、启动）！ <ul><li>利用之前收集的性能监控数据，使虚拟机在启动后快速达到高性能水平</li><li>减少从解释执行到即时编译的等待时间</li></ul></li><li>易于监控（ZVision/ZVRobot工具） <ul><li>方便用户监控JVM运行状态，包括代码热点、对象分配监控、锁竞争监控等</li></ul></li></ul></li></ul><p><strong>挑战者：Apache Harmony/Google Android Dalvik VM</strong></p><ul><li><p><strong>Apache Harmony</strong>:</p><ul><li>一个开源的Java SE实现项目，旨在提供兼容Java SE的JVM及类库。虽然项目已停止，但其代码和理念影响深远</li><li>Apache软件基金会开源项目，兼容JDK 5和JDK 6，提供自己的虚拟机和Java类库API。</li><li>没有通过TCK认证，无法正式称为“Java虚拟机”</li><li>曾对Java生态系统构成巨大挑战，导致Apache基金会退出JCP组织</li><li>随Sun公司开源OpenJDK，Harmony项目的优势逐渐减弱</li><li>主要贡献（如Java类库代码）被吸纳进IBM JDK 7和Google Android SDK</li></ul></li><li><p><strong>Google Android Dalvik VM</strong>:</p><ul><li>Android平台核心虚拟机，名字来源于冰岛的小渔村Dalvik</li><li>非Java虚拟机，使用寄存器架构，不直接执行Java Class文件，而是执行DEX文件</li><li>通过Class文件转化为DEX文件，支持Java语法和API，推动Android迅速发展</li><li>Android 2.2引入即时编译器，提升性能</li><li>Android 4.4开始引入提前编译（Ahead of Time Compilation，AOT）的ART虚拟机</li><li>Android 5.0开始ART全面替代Dalvik虚拟机</li></ul></li></ul><p><strong>没有成功，但并非失败：Microsoft JVM及其他</strong></p><ul><li><strong>Microsoft JVM</strong>: <ul><li>微软开发的Java虚拟机，曾用于早期的Windows平台。但由于与Sun的法律纠纷，微软最终停止了其开发</li><li>为支持Internet Explorer 3中的Java Applets，开发Microsoft JVM，仅限Windows平台</li><li>被认为是当时Windows系统下性能最好的Java虚拟机，1997年和1998年连续获得《PC Magazine》“编辑选择奖”</li><li>1997年被Sun公司控告侵犯商标、不正当竞争，最终微软赔偿2000万美元，并承诺停止开发和逐步移除其Java虚拟机</li><li>虽然微软的Java虚拟机未能长期发展，但其短暂的成功对当时Java的推广起到了积极作用。</li></ul></li></ul><p><strong>百家争鸣</strong></p>",7),C=e("li",null,"KVM：为小型设备设计的轻量级Java虚拟机",-1),A=e("li",null,"Java Card VM：支持智能卡和小型嵌入式设备的Java虚拟机",-1),j=e("li",null,"Squawk VM：针对嵌入式系统和传感器网络的Java虚拟机",-1),S=e("li",null,"JavaInJava：用Java自身编写的Java虚拟机",-1),E=e("li",null,"Maxine VM：由Java编写、用于研究和实验的Java虚拟机",-1),x=e("li",null,"Jikes RVM： IBM开源的高性能研究虚拟机",-1),D=e("li",null,"IKVM.NET：在.NET平台上运行Java代码的虚拟机",-1),T={href:"http://jamvm.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},B={href:"http://www.cacaovm.org/",target:"_blank",rel:"noopener noreferrer"},R={href:"http://www.sablevm.org/",target:"_blank",rel:"noopener noreferrer"},I={href:"http://www.kaffe.org/",target:"_blank",rel:"noopener noreferrer"},K={href:"http://jelatine.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},z={href:"http://www.harbaum.org/till/nanovm/index.shtml",target:"_blank",rel:"noopener noreferrer"},H={href:"https://github.com/codehaus/mrp",target:"_blank",rel:"noopener noreferrer"},O={href:"http://moxie.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},L=i('<h2 id="java虚拟机架构" tabindex="-1"><a class="header-anchor" href="#java虚拟机架构"><span>Java虚拟机架构</span></a></h2><p>理解总体知识点在全局上与知识体系之间的对应关系</p><figure><img src="https://img.geekyspace.cn/pictures/2024/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="Java虚拟机架构" tabindex="0" loading="lazy"><figcaption>Java虚拟机架构</figcaption></figure><p>从整体上看，JVM 由三个不同的组件组成：</p><ol><li><strong>类加载子系统（Class Loader SubSystem）</strong>：主要负责将类<code>.class</code>加载到内存中</li><li><strong>运行时数据区（Runtime Data Area）</strong>：管理JVM运行时所需的数据结构</li><li><strong>执行引擎（Execution Engine）</strong>：负责执行字节码指令，将其转换为机器代码，供机器理解</li></ol><figure><img src="https://img.geekyspace.cn/pictures/2024/image-39.png" alt="JVM三大组件" tabindex="0" loading="lazy"><figcaption>JVM三大组件</figcaption></figure><hr><h3 id="类加载子系统" tabindex="-1"><a class="header-anchor" href="#类加载子系统"><span>类加载子系统</span></a></h3><p>第一个组件 <mark><strong>类加载过程</strong></mark> 分为三个阶段：加载、链接和初始化。</p><p><strong>1、加载（Loading）</strong>：将类的字节码文件加载到内存中，并生成 JVM 运行时的类表示</p><ul><li><strong>启动类加载器（Bootstrap Class Loader）：</strong><ul><li>负责加载Java的核心类库，如<code>java.lang</code>、<code>java.net</code>、<code>java.util</code>、<code>java.io</code>等</li><li>这些类库位于<code>$JAVA_HOME/jre/lib</code>目录中，例如<code>rt.jar</code></li></ul></li><li><strong>扩展类加载器（Extension Class Loader）：</strong><ul><li>Bootstrap类加载器的子类，同时也是Application类加载器的父类。</li><li>它负责加载位于<code>$JAVA_HOME/jre/lib/ext</code>目录中的Java标准库的扩展</li></ul></li><li><strong>系统类加载器（Application Class Loader）：</strong><ul><li>Extension类加载器的子类，加载位于类路径上的类文件，默认情况下，类路径为应用程序的目录</li><li>可通过添加命令行选项<code>-classpath</code>或<code>-cp</code>来修改类路径</li></ul></li></ul><p><strong>2、链接（Linking）</strong>：将类的二进制数据合并到JVM的运行时状态中，分为以下三个步骤：</p><ul><li><strong>验证（Verify）</strong>：通过一组约束或规则检查<code>.class</code>文件的正确性，验证失败抛出<code>VerifyException</code></li><li><strong>准备（Prepare）</strong>：为类或接口的静态字段分配内，存并设置默认初始值</li><li><strong>解析（Resolve）</strong>：将符号引用替换为常量池中存在的直接引用</li></ul><p><strong>3、初始化（Initialization）</strong>：执行类的静态初始化块和静态变量的初始化</p><figure><img src="https://img.geekyspace.cn/pictures/2024/image-40.png" alt="类加载三个阶段" tabindex="0" loading="lazy"><figcaption>类加载三个阶段</figcaption></figure><hr><h3 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h3><p>第二个组件 <mark><strong>运行时数据区域</strong></mark> 内含有五个数据区域：</p><ul><li><em>线程共享区</em>： <ul><li><strong><u>方法区</u></strong>（Method Area）：存储已加载的类信息、常量池、静态变量和即时编译后的代码</li><li><strong>堆（Heap Area）</strong>：存储对象实例和数组（即<code>new</code>出来的对象） <ul><li>GC管理的主要区域，分为新生代和老年代</li></ul></li></ul></li><li><em>线程隔离区</em>： <ul><li><strong><u>虚拟机栈</u>（Virtual Machine Stack）</strong>：存储局部变量、操作数栈（用于计算）、栈帧和方法调用信息</li><li><strong>程序计数器（PC寄存器，Program Counter Register）</strong>：存储当前线程执行的字节码指令的地址，以便线程切换时能恢复</li><li><strong>本地方法栈（Native Method Stack）</strong>：用于执行本地方法（即 JNI 调用的C/C++代码）</li></ul></li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/image-32.png" alt="运行时数据区" tabindex="0" loading="lazy"><figcaption>运行时数据区</figcaption></figure><hr><h3 id="执行引擎" tabindex="-1"><a class="header-anchor" href="#执行引擎"><span>执行引擎</span></a></h3><p>第三个组件 <mark><strong>执行引擎</strong></mark> 包含解释器、编译器和垃圾回收区：</p><ul><li><strong>解释器（Interpreter）</strong>：<strong>逐行</strong>解释执行字节码指令，速度较慢，但实现简单</li><li><strong>即时编译器（JIT Compiler，Just-In-Time Compiler）</strong>：将<strong>热点代码</strong>（经常执行的字节码）编译成机器码，以提高执行效率</li><li><strong>垃圾回收器（Garbage Collector）</strong>：自动管理和回收堆中的无用对象，防止内存泄漏</li></ul><figure><img src="https://img.geekyspace.cn/pictures/2024/image-33.png" alt="执行引擎" tabindex="0" loading="lazy"><figcaption>执行引擎</figcaption></figure><p>这些部分共同组成了JVM的核心功能，使得Java程序可以跨平台运行，并且具有良好的性能和安全性</p>',26),P={href:"https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/",target:"_blank",rel:"noopener noreferrer"};function N(Z,G){const n=o("RouteLink"),t=o("ExternalLinkIcon");return s(),c("div",null,[u,e("ul",null,[e("li",null,[d,e("ul",null,[h,J,m,v,e("li",null,[l("2014年JDK 8时期，HotSpot移除掉"),a(n,{to:"/md/jvm/part2/runtime-data-areas.html#%E6%96%B9%E6%B3%95%E5%8C%BA"},{default:g(()=>[l("永久代")]),_:1}),l("，吸收了JRockit的Java Mission Control监控工具等功能")])])])]),M,e("ul",null,[_,e("li",null,[f,l(": "),e("ul",null,[V,k,e("li",null,[l("由IBM开发，2017年开源为"),e("a",y,[l("OpenJ9"),a(t)]),l("，现由Eclipse基金会维护")]),b])])]),w,e("ul",null,[C,A,j,S,E,x,D,e("li",null,[l("JamVM："),e("a",T,[l("http://jamvm.sourceforge.net/"),a(t)])]),e("li",null,[l("CacaoVM："),e("a",B,[l("http://www.cacaovm.org/"),a(t)])]),e("li",null,[l("SableVM："),e("a",R,[l("http://www.sablevm.org/"),a(t)])]),e("li",null,[l("Kaffe："),e("a",I,[l("http://www.kaffe.org/"),a(t)])]),e("li",null,[l("Jelatine JVM："),e("a",K,[l("http://jelatine.sourceforge.net/"),a(t)])]),e("li",null,[l("NanoVM："),e("a",z,[l("http://www.harbaum.org/till/nanovm/index.shtml"),a(t)])]),e("li",null,[l("MRP："),e("a",H,[l("https://github.com/codehaus/mrp"),a(t)])]),e("li",null,[l("Moxie JVM："),e("a",O,[l("http://moxie.sourceforge.net/"),a(t)])])]),L,e("ul",null,[e("li",null,[l("参考："),e("a",P,[l("Siben Nayak—《面向初学者的Java虚拟机架构》"),a(t)])])])])}const X=r(p,[["render",N],["__file","overview.html.vue"]]),$=JSON.parse('{"path":"/md/java/jvm/part1/overview.html","title":"Java虚拟机概述","lang":"zh-CN","frontmatter":{"title":"Java虚拟机概述","shortTitle":null,"description":"Java虚拟机概述 Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。 它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。 JVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Writ...","icon":null,"cover":null,"author":"流浪码客","isOriginal":true,"sticky":false,"star":false,"date":"2024-07-19T00:00:00.000Z","category":"JVM","tag":["jvm"],"order":1.4,"head":[["meta",{"property":"og:url","content":"https://www.geekyspace.cn/md/java/jvm/part1/overview.html"}],["meta",{"property":"og:title","content":"Java虚拟机概述"}],["meta",{"property":"og:description","content":"Java虚拟机概述 Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。 它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。 JVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Writ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-16T11:18:00.000Z"}],["meta",{"property":"article:author","content":"流浪码客"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-07-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-16T11:18:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java虚拟机概述\\",\\"image\\":[\\"https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png\\",\\"https://img.geekyspace.cn/pictures/2024/0082zybply1gc6fz21n8kj30u00wpn5v.jpg\\",\\"https://img.geekyspace.cn/pictures/2024/image-39.png\\",\\"https://img.geekyspace.cn/pictures/2024/image-40.png\\",\\"https://img.geekyspace.cn/pictures/2024/image-32.png\\",\\"https://img.geekyspace.cn/pictures/2024/image-33.png\\"],\\"datePublished\\":\\"2024-07-19T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-16T11:18:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"流浪码客\\"}]}"]]},"headers":[{"level":2,"title":"跨平台开发的通用平台","slug":"跨平台开发的通用平台","link":"#跨平台开发的通用平台","children":[]},{"level":2,"title":"Java虚拟机家族","slug":"java虚拟机家族","link":"#java虚拟机家族","children":[]},{"level":2,"title":"Java虚拟机架构","slug":"java虚拟机架构","link":"#java虚拟机架构","children":[{"level":3,"title":"类加载子系统","slug":"类加载子系统","link":"#类加载子系统","children":[]},{"level":3,"title":"运行时数据区","slug":"运行时数据区","link":"#运行时数据区","children":[]},{"level":3,"title":"执行引擎","slug":"执行引擎","link":"#执行引擎","children":[]}]}],"git":{"createdTime":1758021480000,"updatedTime":1758021480000,"contributors":[{"name":"joeljhou","email":"joeljhou336@gmail.com","commits":1}]},"readingTime":{"minutes":9.55,"words":2864},"filePathRelative":"md/java/jvm/part1/overview.md","localizedDate":"2024年7月19日","excerpt":"\\n<blockquote>\\n<p><strong>Java虚拟机</strong>（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。\\n它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。\\nJVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Write Once, Run Anywhere”。</p>\\n</blockquote>\\n<h2>跨平台开发的通用平台</h2>\\n<p>随着发展，JVM不再是Java独享的Moment，越来越多的语言开始在JVM上运行，使JVM逐渐演变成一个<strong>跨平台开发的通用平台</strong>。</p>","copyright":{"author":"流浪码客"},"autoDesc":true}');export{X as comp,$ as data};
