<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://www.geekyspace.cn/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.geekyspace.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title></title>
    <link>https://www.geekyspace.cn/</link>
    <description></description>
    <language>zh-CN</language>
    <pubDate>Sat, 11 Oct 2025 10:18:57 GMT</pubDate>
    <lastBuildDate>Sat, 11 Oct 2025 10:18:57 GMT</lastBuildDate>
    <generator>@vuepress/plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Flutter</category>
    <category>DataBase</category>
    <category>Kotlin</category>
    <category>并发编程</category>
    <category>Java Features</category>
    <category>JVM</category>
    <category>Java</category>
    <category>包管理器</category>
    <category>Blog</category>
    <category>Docker</category>
    <category>程序人生</category>
    <category>开发工具</category>
    <category>软件安装</category>
    <category>Spring Boot</category>
    <category>Spring Data</category>
    <category>激活</category>
    <category>Spring</category>
    <item>
      <title>Flutter入门指南</title>
      <link>https://www.geekyspace.cn/md/flutter/flutter-guide.html</link>
      <guid>https://www.geekyspace.cn/md/flutter/flutter-guide.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Flutter入门指南</source>
      <description>Flutter是一个跨端的平台开发框架</description>
      <category>Flutter</category>
      <pubDate>Fri, 26 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>Flutter 是 Google 推出的跨平台 UI 框架，使用 <strong>Dart</strong> 语言，可一次开发同时运行在 <strong>Android / iOS / Web / 桌面端</strong>。</p>
</blockquote>
<ul>
<li>核心理念：<strong>一切皆为组件（Widget）</strong>。</li>
</ul>
<h2>环境搭建</h2>
<h3>安装 Flutter SDK</h3>
<ul>
<li><a href="https://docs.flutter.cn/release/archive?tab=macos" target="_blank" rel="noopener noreferrer">SDK 归档列表</a></li>
<li><a href="https://docs.flutter.cn/community/china/" target="_blank" rel="noopener noreferrer">国内镜像加速配置</a></li>
</ul>
<p><strong>解压与环境变量配置</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 假设解压路径为 ~/Development/sdk/flutter</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/Development/sdk/flutter/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token comment"># 国内镜像</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">PUB_HOSTED_URL</span><span class="token operator">=</span><span class="token string">"https://pub.flutter-io.cn"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">FLUTTER_STORAGE_BASE_URL</span><span class="token operator">=</span><span class="token string">"https://storage.flutter-io.cn"</span>

<span class="token comment"># 配置生效</span>
<span class="token builtin class-name">source</span> ~/.zshrc
</code></pre></div><p><strong>检查安装是否成功</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>flutter <span class="token parameter variable">--version</span>
dart <span class="token parameter variable">--version</span>
</code></pre></div><p><strong>环境诊断命令：<code>flutter doctor</code></strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ flutter doctor

Doctor summary <span class="token punctuation">(</span>查看详细信息，请运行 flutter doctor -v<span class="token punctuation">)</span>:
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Flutter <span class="token punctuation">(</span>稳定通道, 版本 <span class="token number">3.35</span>.4, 运行于 macOS <span class="token number">15.6</span>.1 24G90 darwin-arm64, 语言环境 zh-Hans-CN<span class="token punctuation">)</span>
<span class="token punctuation">[</span>✗<span class="token punctuation">]</span> Android 工具链 - 用于开发 Android 设备
    ✗ 无法找到 Android SDK。
      请从 https://developer.android.com/studio/index.html 安装 Android Studio
      首次启动会协助你安装 Android SDK 组件。
      （或者访问 https://flutter.dev/to/macos-android-setup 获取详细说明）。
      如果 Android SDK 已安装在自定义路径，请使用
      <span class="token variable"><span class="token variable">`</span>flutter config --android-sdk<span class="token variable">`</span></span> 更新该路径。

<span class="token punctuation">[</span>✗<span class="token punctuation">]</span> Xcode - 用于开发 iOS 和 macOS
    ✗ Xcode 安装不完整；iOS 和 macOS 开发需要完整安装。
      下载地址: https://developer.apple.com/xcode/
      或通过 App Store 安装 Xcode。
      安装完成后运行：
        <span class="token function">sudo</span> xcode-select <span class="token parameter variable">--switch</span> /Applications/Xcode.app/Contents/Developer
        <span class="token function">sudo</span> xcodebuild <span class="token parameter variable">-runFirstLaunch</span>
    ✗ 未安装 CocoaPods。
        CocoaPods 是 iOS 或 macOS 平台的包管理工具。
        没有 CocoaPods，插件无法在 iOS 或 macOS 上正常工作。
        更多信息请见 https://flutter.dev/to/platform-plugins
        安装说明请见 https://guides.cocoapods.org/using/getting-started.html<span class="token comment">#installation</span>
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Chrome - 用于 Web 开发
<span class="token punctuation">[</span><span class="token operator">!</span><span class="token punctuation">]</span> Android Studio <span class="token punctuation">(</span>未安装<span class="token punctuation">)</span>
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> IntelliJ IDEA Ultimate 版本 <span class="token punctuation">(</span><span class="token number">2025.1</span>.3<span class="token punctuation">)</span>
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> VS Code 版本 <span class="token punctuation">(</span><span class="token number">1.104</span>.2<span class="token punctuation">)</span>
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> 已连接设备 <span class="token punctuation">(</span><span class="token number">2</span> 个可用<span class="token punctuation">)</span>
<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> 网络资源

<span class="token operator">!</span> Doctor 在 <span class="token number">3</span> 个类别中发现问题。
</code></pre></div><h3>安装 Android Studio</h3>
<p><mark>搭建<u>安卓</u>环境</mark></p>
<ol>
<li><a href="https://developer.android.com/studio?hl=zh-cn" target="_blank" rel="noopener noreferrer">下载 Android Studio</a></li>
<li>安装 Dart 和 Flutter 插件</li>
<li>安装 SDK Command-line Tools</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202510071608696.png" alt="安装 SDK Command-line Tools" tabindex="0" loading="lazy"><figcaption>安装 SDK Command-line Tools</figcaption></figure>
<ol start="4">
<li>接受 Android SDK 许可证</li>
</ol>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ flutter doctor --android-licenses
<span class="token comment"># 根据提示逐条输入 y 接受许可证</span>
</code></pre></div><h3>安装 XCode</h3>
<p><mark>搭建<u>iOS/macOS</u>环境</mark></p>
<ul>
<li>通过 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener noreferrer">App Store安装 Xcode</a></li>
<li>安装完成后，在终端执行：</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 指定 Xcode 路径（支持安装多个）</span>
<span class="token function">sudo</span> xcode-select <span class="token parameter variable">--switch</span> /Applications/Xcode.app/Contents/Developer
<span class="token comment"># 首次启动初始化（确保命令行工具可用）</span>
<span class="token function">sudo</span> xcodebuild <span class="token parameter variable">-runFirstLaunch</span>
</code></pre></div><h3>安装 CocoaPods</h3>
<p>CocoaPods 是 iOS/macOS 平台的依赖管理工具，用于管理 Flutter 插件的本地依赖。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 1. 安装 ruby（Mac系统自带，但建议使用 brew 安装新版）</span>
brew <span class="token function">install</span> ruby
<span class="token comment"># 配置 ruby 环境变量</span>
<span class="token builtin class-name">echo</span> <span class="token string">'export PATH="/opt/homebrew/opt/ruby/bin:$PATH"'</span> <span class="token operator">&gt;&gt;</span> ~/.zshrc
<span class="token builtin class-name">source</span> ~/.zshrc
<span class="token comment"># 验证 ruby 是否安装成功</span>
ruby <span class="token parameter variable">--version</span>

<span class="token comment"># 2. 安装 CocoaPods</span>
gem <span class="token function">install</span> cocoapods
<span class="token comment"># 配置 gems 环境变量</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"/opt/homebrew/lib/ruby/gems/3.4.0/bin:<span class="token environment constant">$PATH</span>"</span>
<span class="token builtin class-name">source</span> ~/.zshrc
</code></pre></div><h2>常用命令</h2>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 🌟 检查环境</span>
flutter doctor                      <span class="token comment"># 检查 SDK、IDE、工具链</span>
flutter doctor <span class="token parameter variable">-v</span>                   <span class="token comment"># 显示详细信息</span>
<span class="token comment"># 🌟 设备管理</span>
flutter devices                     <span class="token comment"># 列出已连接设备/模拟器</span>
flutter emulators                   <span class="token comment"># 查看可用模拟器</span>
flutter emulators <span class="token parameter variable">--launch</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>     <span class="token comment"># 启动指定模拟器</span>
<span class="token comment"># 🌟 运行项目</span>
flutter run                         <span class="token comment"># 在默认设备运行</span>
flutter run <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>device_id<span class="token operator">&gt;</span>          <span class="token comment"># 指定设备运行</span>
flutter run <span class="token parameter variable">-d</span> all                  <span class="token comment"># 所有设备同时运行</span>
<span class="token comment"># 🌟 管理依赖</span>
flutter pub get                     <span class="token comment"># 下载依赖（pubspec.yaml 中的包）</span>
flutter pub upgrade                 <span class="token comment"># 升级依赖</span>
<span class="token comment"># 🌟 清理与构建</span>
flutter clean                       <span class="token comment"># 清理缓存和临时文件</span>
flutter build apk                   <span class="token comment"># 构建 Android APK</span>
flutter build apk <span class="token parameter variable">--debug</span>           <span class="token comment"># 构建调试 APK</span>
flutter build apk --split-per-abi   <span class="token comment"># 按 CPU 架构分包，减小 APK 大小</span>
<span class="token comment"># 🌟 代码检查与格式化</span>
flutter analyze                     <span class="token comment"># 静态分析代码</span>
flutter <span class="token function">format</span> <span class="token builtin class-name">.</span>                    <span class="token comment"># 格式化项目代码</span>
<span class="token comment"># 🌟 iOS 模拟器（仅 macOS）</span>
<span class="token function">open</span> <span class="token parameter variable">-a</span> Simulator                   <span class="token comment"># 启动 Xcode iOS 模拟器</span>
flutter run <span class="token parameter variable">-d</span> ios                  <span class="token comment"># 在 iOS 模拟器运行</span>
</code></pre></div><h2>组件（Widget）</h2>
<h3>理解 Flutter 应用</h3>
<ul>
<li><a href="https://codecopy.cn/post/19cdjq" target="_blank" rel="noopener noreferrer">🐟代码小抄-理解 Flutter 应用</a>
<ul>
<li>1️⃣ StatelessWidget —— 无状态组件</li>
<li>2️⃣ StatefulWidget —— 有状态组件</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://github.com/joeljhou/hello_flutter" target="_blank" rel="noopener noreferrer">joeljhou/hello_flutter: 一个面向初学者的 Flutter 示例项目，展示基础控件、布局和样式。适合学习 Flutter 基础知识并快速上手开发简单应用。</a></li>
</ul>
<h3>StatefulWidget 生命周期</h3>
<p><img src="http://img.geekyspace.cn/pictures/2025/202510081301653.png" alt="StatefulWidget 生命周期" loading="lazy">
StatefulWidget 的生命周期可分为 <strong>4 个阶段</strong>：</p>
<ol>
<li><strong>初始化阶段</strong>：<code>createState()</code> → <code>initState()</code></li>
<li><strong>依赖变化与首次构建阶段</strong>：<code>didChangeDependencies()</code> → <code>build()</code></li>
<li><strong>状态更新阶段</strong>：<code>setState()</code>、<code>didUpdateWidget()</code>、<code>reassemble()</code></li>
<li><strong>销毁阶段</strong>：<code>deactivate()</code> → <code>dispose()</code></li>
</ol>
<p><strong>🧩 各阶段方法说明</strong></p>
<ol>
<li><code>createState()</code>
<ul>
<li>当 StatefulWidget 第一次被创建时调用</li>
<li>用于创建对应的 <code>State</code> 实例</li>
</ul>
</li>
<li><code>initState()</code>
<ul>
<li>State 初始化时调用（仅执行一次）</li>
<li>常用于：
<ul>
<li>初始化变量</li>
<li>发起网络请求 / 初始化数据</li>
</ul>
</li>
<li>⚠️ 不要在此直接调用 <code>BuildContext</code> 相关操作（如 <code>Provider.of</code>）</li>
</ul>
</li>
<li><code>didChangeDependencies()</code>
<ul>
<li>当依赖的对象（如 <code>InheritedWidget</code>）发生变化时调用</li>
<li>在 <code>initState()</code> 之后 <strong>会被调用一次</strong></li>
<li>通常用于依赖外部数据的初始化</li>
</ul>
</li>
<li><code>build()</code>
<ul>
<li>返回要渲染的界面</li>
<li>可能会被调用多次（如 <code>setState()</code>、父组件重建）</li>
<li>⚠️ 避免在此执行耗时或带副作用的操作</li>
</ul>
</li>
<li><code>reassemble()</code>
<ul>
<li><strong>仅在 Debug 模式下热重载（Hot Reload）</strong> 时调用</li>
<li>用于调试时更新状态</li>
</ul>
</li>
<li><code>didUpdateWidget()</code>
<ul>
<li>当父组件重建并传入新的配置时调用</li>
<li>Flutter 通过 <code>Widget.canUpdate</code> 判断是否需要调用此方法</li>
<li>调用后一定会触发 <code>build()</code> 重新渲染</li>
</ul>
</li>
<li><code>setState()</code>
<ul>
<li>用于触发状态更新并重新调用 <code>build()</code></li>
<li>只更新当前组件，不影响父组件</li>
</ul>
</li>
<li><code>deactivate()</code>
<ul>
<li>当组件从 Widget 树中<strong>暂时移除</strong>时调用</li>
<li>有可能会再次被插入（如路由切换）</li>
</ul>
</li>
<li><code>dispose()</code>
<ul>
<li>当组件 <strong>永久从树中移除</strong> 时调用</li>
<li>用于：
<ul>
<li>释放资源（如 <code>Controller</code>、<code>Stream</code>、<code>Timer</code>）</li>
<li>取消订阅、关闭动画等</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>Widget/UI布局/交互</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202510082217670.png" alt="基础Widget/UI布局/交互" tabindex="0" loading="lazy"><figcaption>基础Widget/UI布局/交互</figcaption></figure>
<h2>页面跳转（Navigator）</h2>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202510100153600.png" alt="页面跳转" tabindex="0" loading="lazy"><figcaption>页面跳转</figcaption></figure>
<h2>网络请求和序列化数据</h2>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202510100156407.png" alt="网络请求和序列化数据" tabindex="0" loading="lazy"><figcaption>网络请求和序列化数据</figcaption></figure>
<h2>参考：</h2>
<ul>
<li><a href="https://docs.flutter.dev/" target="_blank" rel="noopener noreferrer">Flutter 开发文档</a> | <a href="https://docs.flutter.cn/" target="_blank" rel="noopener noreferrer">Flutter 中文开发文档</a></li>
<li><a href="https://docs.flutter.cn/install/manual" target="_blank" rel="noopener noreferrer">手动安装Flutter</a> | <a href="https://docs.flutter.cn/install/troubleshoot#cmdline-tools-component-is-missing" target="_blank" rel="noopener noreferrer">安装常见问题</a></li>
<li><a href="https://docs.flutter.cn/tools/android-studio" target="_blank" rel="noopener noreferrer">在 Android Studio 或 IntelliJ 里开发 Flutter 应用</a></li>
<li><a href="https://www.bilibili.com/video/BV1p14y1T79R/" target="_blank" rel="noopener noreferrer">女程序猿带你从0开始学Flutter：认识Flutter</a></li>
<li><a href="https://github.com/joeljhou/hello_flutter" target="_blank" rel="noopener noreferrer">一个面向初学者的 Flutter 示例项目</a></li>
</ul>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/202510071608696.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL 必知必会</title>
      <link>https://www.geekyspace.cn/md/database/mysql/</link>
      <guid>https://www.geekyspace.cn/md/database/mysql/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">MySQL 必知必会</source>
      <description>MySQL 必知必会 开启一个新的专栏，介绍 MySQL 的一些必知必会的内容。</description>
      <category>DataBase</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>开启一个新的专栏，介绍 MySQL 的一些必知必会的内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 程序员快速掌握 Kotlin</title>
      <link>https://www.geekyspace.cn/md/java/kotlin/kotlin-quick-for-java.html</link>
      <guid>https://www.geekyspace.cn/md/java/kotlin/kotlin-quick-for-java.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 程序员快速掌握 Kotlin</source>
      <description>Java 程序员快速掌握 Kotlin 数据类型 下面是 Java 和 Kotlin 数据类型的对比与 Kotlin 示例讲解： 1️⃣ 基本类型（Primitive Types） Java：有原生类型（int、double）和包装类型（Integer、Double）。 Kotlin：所有基本类型都是对象，没有 primitive/wrapper 区分...</description>
      <category>Kotlin</category>
      <pubDate>Sun, 21 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>数据类型</h2>
<p>下面是 Java 和 Kotlin 数据类型的对比与 Kotlin 示例讲解：</p>
<p><strong>1️⃣ 基本类型（Primitive Types）</strong></p>
<ul>
<li><strong>Java</strong>：有原生类型（<code>int</code>、<code>double</code>）和包装类型（<code>Integer</code>、<code>Double</code>）。</li>
<li><strong>Kotlin</strong>：所有基本类型都是对象，没有 primitive/wrapper 区分。</li>
</ul>
<div class="language-kotlin" data-ext="kt" data-title="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> a<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">10</span>      <span class="token comment">// 显式声明</span>
<span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token number">20</span>           <span class="token comment">// 类型推断为 Int</span>
<span class="token keyword">val</span> pi <span class="token operator">=</span> <span class="token number">3.14</span>        <span class="token comment">// 类型推断为 Double</span>
<span class="token keyword">val</span> flag<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">val</span> ch<span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">'A'</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Int: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">a</span></span><span class="token string">, Double: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">pi</span></span><span class="token string">, Boolean: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">flag</span></span><span class="token string">, Char: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">ch</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>什么是数据库？</title>
      <link>https://www.geekyspace.cn/md/database/mysql/overview/what-is-database.html</link>
      <guid>https://www.geekyspace.cn/md/database/mysql/overview/what-is-database.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">什么是数据库？</source>
      <description>什么是数据库？ 数据库的定义 这个术语的用法很多，对于程序员来说，数据库是一个有组织的数据集合，由 数据库管理系统 (DBMS) 来管理。在计算机系统中，数据、DBMS 和相关应用程序统称为数据库系统，简称数据库。 理解数据库的一种最简单的办法是将其想象为一个文件柜。 此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。 什么是SQL？ S...</description>
      <category>DataBase</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>数据库的定义</h2>
<blockquote>
<p>这个术语的用法很多，对于程序员来说，数据库是一个<strong>有组织的数据集合</strong>，由 <a href="https://www.oracle.com/cn/database/what-is-database/#WhatIsDBMS" target="_blank" rel="noopener noreferrer">数据库管理系统 (DBMS)</a> 来管理。在计算机系统中，<u>数据、DBMS 和相关应用程序</u>统称为<strong>数据库系统</strong>，简称数据库。</p>
</blockquote>
<ul>
<li>理解数据库的一种最简单的办法是将其想象为一个<strong>文件柜</strong>。</li>
<li>此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。</li>
</ul>
<h2>什么是SQL？</h2>
<blockquote>
<p><strong>SQL</strong>（Structured Query Language，<strong>结构化查询语言</strong>）是一种专门<strong>与<a href="https://www.oracle.com/cn/database/what-is-database/#relational" target="_blank" rel="noopener noreferrer">关系数据库</a>通信的编程语言</strong>。 可以使用 SQL 语句从数据库中<u>存储、更新、删除、搜索和检索信息</u>。您还可以使用 SQL 来维护和优化数据库性能。</p>
</blockquote>
<p><strong>历史背景</strong></p>
<ol>
<li>SQL 最初由 IBM 在 20 世纪 70 年代开发，用于关系数据库操作。</li>
<li>Oracle 是主要贡献者之一，推动了 SQL 的 ANSI 标准化。</li>
<li>随着 SQL 的广泛应用，IBM、Oracle、Microsoft 等公司相继扩张其数据库业务。</li>
<li>时至今日，SQL 仍是主流数据库的标准语言，但新兴语言和技术也逐渐出现。</li>
</ol>
<h2>数据库的类型</h2>
<ol>
<li>关系数据库</li>
<li>非关系型数据库</li>
</ol>
<h2>序</h2>
<ul>
<li><a href="https://www.oracle.com/cn/database/what-is-database" target="_blank" rel="noopener noreferrer">什么是数据库？ | Oracle 中国</a></li>
<li><a href="https://aws.amazon.com/cn/what-is/database" target="_blank" rel="noopener noreferrer">什么是数据库？- 云数据库简介 - AWS</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java多线程与并发编程</title>
      <link>https://www.geekyspace.cn/md/java/thread/thread-concurrency.html</link>
      <guid>https://www.geekyspace.cn/md/java/thread/thread-concurrency.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java多线程与并发编程</source>
      <description>Java多线程与并发编程 你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。 目标 基本概念 (Basic) 多线程 (Thread) 线程池 (Executor) 并发容器 (Collections) 同步工具 (Tools) 原子对象 (Atomic) Java多线程并发编程6大核心Java多线程并发编程...</description>
      <category>并发编程</category>
      <pubDate>Tue, 18 Feb 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>你聊一聊多线程以及并发你是如何实现的，以往在实际工作中，遇到高并发的环境采用那些方案进行处理。</p>
</blockquote>
<h2>目标</h2>
<ul>
<li><strong>基本概念 (Basic)</strong></li>
<li><strong>多线程 (Thread)</strong></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-executor">线程池 (Executor)</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-collections">并发容器 (Collections)</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-tools">同步工具 (Tools)</a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E5%AF%B9%E8%B1%A1-atomic">原子对象 (Atomic)</a></li>
</ul>
<figure><img src="http://img.geekyspace.cn/pictures/2025/image-20250217013332469.png" alt="Java多线程并发编程6大核心" tabindex="0" loading="lazy"><figcaption>Java多线程并发编程6大核心</figcaption></figure>
<h2>并发背后的故事</h2>
<p><strong>什么是并发？</strong>
并发就是指程序同时处理多个任务的能力。
并发编程的根源在于多任务情况下对资源访问的有效控制。</p>
<p><strong>你的程序在并发环境下一定是正确的吗？</strong></p>
<ul>
<li><a href="https://codecopy.cn/post/c51tdh" target="_blank" rel="noopener noreferrer">🐟代码小抄-并发统计App Store下载次数</a></li>
</ul>
<h2>你必须知道的概念</h2>
<p><strong>程序，进程与线程</strong></p>
<ol>
<li><strong>程序</strong>：程序是静态的概念，Windows下通常指<code>exe</code>文件。</li>
<li><strong>进程</strong>：进程是动态的概念，当你双击一个程序，操作系统会把它加载到内存中运行，进程说明程序在内存中的边界。</li>
<li><strong>线程</strong>：一个进程包含多个线程，线程是CPU调度的基本单位，每个线程都有自己的功能。</li>
</ol>
<p><strong>并行与并发</strong></p>
<ol>
<li>
<p><strong>🚗并行 (Parallelism)</strong>：<em>多核CPU同时处理</em></p>
<ul>
<li><strong>就像多车道高速公路:</strong> 多辆车可以同时在不同的车道上行驶，互不干扰。</li>
<li><strong>在计算机中:</strong> 多个处理器或多核CPU同时执行多个任务，真正同时进行。</li>
</ul>
</li>
<li>
<p><strong>🚚🚙🚗并发 (Concurrency)</strong>：<em>单核CPU交替执行</em></p>
<ul>
<li><strong>就像单车道上的多辆车:</strong> 虽然只有一条车道，但通过交替行驶，看起来像是同时前进。</li>
<li><strong>在计算机中:</strong> 单个处理器通过快速切换任务，给人同时处理的错觉，实际是交替执行。</li>
</ul>
</li>
</ol>
<p><strong>同步和异步</strong></p>
<ol>
<li>
<p><strong>⏳同步 (Sync)</strong>：<em>按顺序执行，干等着</em></p>
<ul>
<li><strong>就像银行柜台办理业务：</strong> 你去银行取钱，需要排队，前面的人不办完，你不能办。</li>
<li><strong>在编程中：</strong> 代码按顺序执行，每个任务必须等前一个任务完成后才能执行下一个。</li>
</ul>
</li>
<li>
<p><strong>🏃‍♂️异步 (Asyn)</strong>：<em>不等了，先去忙别的，等有结果再回来处理</em></p>
<ul>
<li><strong>就像去餐厅点餐：</strong> 你点完餐后不用等着，先去刷手机，等饭做好了，服务员再叫你来取。</li>
<li><strong>在编程中：</strong> 代码遇到耗时操作（比如网络请求）时不会等，而是先去执行别的任务，等操作完成后再回来处理结果。</li>
</ul>
</li>
</ol>
<p><strong>临界区</strong></p>
<ol>
<li><strong>🚧临时区：</strong> <em>公共资源与共享数据，同一时间只能有一个线程访问</em>
<ul>
<li><strong>就像公司的打印机</strong>：公司只有一台打印机（临界区），多个员工（线程）需要打印文件，每次只能一个员工使用。</li>
<li><strong>在编程中：</strong> 临时区是指对共享资源访问的代码片段，通过互斥锁（Mutex），信号量（Semaphore），原子操作（Atomic Operations）来实现。</li>
</ul>
</li>
</ol>
<p><strong>死锁、饥饿、活锁</strong></p>
<ol>
<li>
<p><strong>🛑死锁（Deadlock）：🔒</strong></p>
<ul>
<li><strong>就像公路上堵车：</strong> 谁也不让谁，大家都卡住</li>
<li><strong>在编程中：</strong> 两个或多个线程互相持有对方需要的资源，导致无法继续执行。</li>
</ul>
</li>
<li>
<p><strong>🍽️饥饿 (Starvation)：</strong></p>
<ul>
<li><strong>就像奶茶店排队：</strong> 总有人插队，有些人一直没机会买到奶茶。</li>
<li><strong>在编程中：</strong> 线程本身是有执行优先级的，如果优先级低的线程一直无法获取到CPU执行权，就会一直处于等待状态。</li>
</ul>
</li>
<li>
<p><strong>🔁活锁 (Livelock)：</strong></p>
<ul>
<li><strong>就像礼让路口：</strong> 你让我，我让你，谁也不走。</li>
<li><strong>在编程中：</strong> 是指多个线程（进程）互相礼让，不断进行状态调整，但始终无法完成任务。</li>
</ul>
</li>
</ol>
<p><strong>线程安全</strong></p>
<ol>
<li>
<p><strong>线程安全 (Thread-Safe)</strong> 理解： 多线程环境下，对共享资源的访问不会引起数据不一致。</p>
</li>
<li>
<p><strong>线程安全三大特性</strong></p>
<ol>
<li>
<p><strong>🏗️原子性 (Atomicity)</strong>：</p>
<ul>
<li><strong>就像银行转账：</strong> 要么扣钱和加钱都成功，要么都不成功。</li>
<li><strong>在编程中：</strong> 一个或多个操作要么全部执行成功，要么全部不执行。</li>
</ul>
</li>
<li>
<p><strong>👀可见性 (Visibility)</strong>：</p>
<ul>
<li><strong>就像聊天室：</strong> 你发的消息，其他人都能看到。</li>
<li><strong>在编程中：</strong> 一个线程对共享变量的修改，其他线程能立即看到。</li>
</ul>
</li>
<li>
<p><strong>🔀有序性 (Ordering)</strong>：程序执行的顺序按照代码的先后顺序执行。</p>
<ul>
<li><strong>就像排队买票：</strong> 先来的先买票，后来的后买票。</li>
<li><strong>在编程中：</strong> 程序按照代码的先后顺序执行，不会乱序
通过<code>volatile</code>，<code>synchronized</code>，<code>Lock</code>来实现线程安全。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2>Java内存模型（JMM）</h2>
<p><a href="https://www.bilibili.com/video/BV1Cu4m1A7ha" target="_blank" rel="noopener noreferrer">bilibili-磊哥-什么是Java内存模型（JMM）？</a></p>
<p>| <strong>概念</strong>                   | <strong>作用</strong>        | <strong>比喻</strong>      |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/image-20250217013332469.png" type="image/png"/>
    </item>
    <item>
      <title>Java新版本特性（持续连载）</title>
      <link>https://www.geekyspace.cn/md/java/features/</link>
      <guid>https://www.geekyspace.cn/md/java/features/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java新版本特性（持续连载）</source>
      <description>Java 8-21：前沿特性解读系列（持续连载），截至2023年9月中旬，Java已达到第21版本。 尽管如此，众多开发者仍停滞在Java 8的认知水平。为填补这一差距，我们推出专栏，聚焦分享最新Java知识。</description>
      <category>Java Features</category>
      <pubDate>Wed, 20 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>为了帮助大家跟上最新的技术潮流，计划启动一个专栏，重点分享Java领域的前沿知识。
这个专栏将详细解读从<strong>Java 8 - 最新版本</strong>的各种有趣的新特性。
会持续不断地发布相关内容，希望大家能够关注并收藏起来，跟随我们一起深入了解Java的最新进展！</p>
<p>详细了解Java Enhancement Proposals（JEPs）及其最新动态</p>
<ul>
<li>🚀 访问官方网站：<a href="https://openjdk.java.net/jeps/" target="_blank" rel="noopener noreferrer">OpenJDK JEPs</a></li>
<li>❄️ 参考howtodoinjava博客：<a href="https://howtodoinjava.com/series/java-versions-features/" target="_blank" rel="noopener noreferrer">Java Versions and Features</a></li>
</ul>
<h2>Java 23(in development)</h2>
<h2>Java 22(GA 2024/03/19)</h2>
<ul>
<li>423:    Region Pinning for G1</li>
<li>447:    Statements before super(...) (Preview)</li>
<li>454:    Foreign Function &amp; Memory API</li>
<li>456:    Unnamed Variables &amp; Patterns</li>
<li>457:    Class-File API (Preview)</li>
<li>458:    Launch Multi-File Source-Code Programs</li>
<li>459:    String Templates (Second Preview)</li>
<li>460:    Vector API (Seventh Incubator)</li>
<li>461:    Stream Gatherers (Preview)</li>
<li>462:    Structured Concurrency (Second Preview)</li>
<li>463:    Implicitly Declared Classes and Instance Main Methods (Second Preview)</li>
<li>464:    Scoped Values (Second Preview)</li>
</ul>
<h2>Java 21(GA 2023/09/19)</h2>
<ul>
<li><a href="Java21/jep430-string-templates">430:    String Templates (Preview)</a></li>
<li><a href="Java21/jep431-sequenced-collections">431:    Sequenced Collections</a></li>
<li><a href="Java21/jep439-generational-zgc">439:    Generational ZGC</a></li>
<li><a href="Java21/jep440-record-partterns">440:    Record Patterns</a></li>
<li><a href="Java21/jep441-pattern-matching-for-switch">441:    Pattern Matching for switch</a></li>
<li>442:    Foreign Function &amp; Memory API (Third Preview)</li>
<li>443:    Unnamed Patterns and Variables (Preview)</li>
<li><a href="Java21/jep444-virtual-threads">444:    Virtual Threads</a></li>
<li>445:    Unnamed Classes and Instance Main Methods (Preview)</li>
<li>446:    Scoped Values (Preview)</li>
<li>448:    Vector API (Sixth Incubator)</li>
<li>449:    Deprecate the Windows 32-bit x86 Port for Removal</li>
<li>451:    Prepare to Disallow the Dynamic Loading of Agents</li>
<li>452:    Key Encapsulation Mechanism API</li>
<li>453:    Structured Concurrency (Preview)</li>
</ul>
<h2>Java 20(GA 2023/03/21)</h2>
<ul>
<li>429:    Scoped Values (Incubator)</li>
<li>432:    Record Patterns (Second Preview)</li>
<li>433:    Pattern Matching for switch (Fourth Preview)</li>
<li>434:    Foreign Function &amp; Memory API (Second Preview)</li>
<li>436:    Virtual Threads (Second Preview)</li>
<li>437:    Structured Concurrency (Second Incubator)</li>
<li>438:    Vector API (Fifth Incubator)</li>
</ul>
<h2>Java 19(GA 2022/09/20)</h2>
<ul>
<li>405:    Record Patterns (Preview)</li>
<li>422:    Linux/RISC-V Port</li>
<li>424:    Foreign Function &amp; Memory API (Preview)</li>
<li>425:    Virtual Threads (Preview)</li>
<li>426:    Vector API (Fourth Incubator)</li>
<li>427:    Pattern Matching for switch (Third Preview)</li>
<li>428:    Structured Concurrency (Incubator)</li>
</ul>
<h2>Java 18(GA 2022/03/22)</h2>
<ul>
<li><a href="Java18/jep400-utf8-by-default">400:    UTF-8 by Default</a></li>
<li><a href="Java18/jep408-simple-web-server">408:    Simple Web Server</a></li>
<li><a href="Java18/jep413-code-snippets-in-api-documentation">413:    Code Snippets in Java API Documentation</a></li>
<li>416:    Reimplement Core Reflection with Method Handles</li>
<li>417:    Vector API (Third Incubator)</li>
<li>418:    Internet-Address Resolution SPI</li>
<li>419:    Foreign Function &amp; Memory API (Second Incubator)</li>
<li>420:    Pattern Matching for switch (Second Preview)</li>
<li>421:    Deprecate Finalization for Removal</li>
</ul>
<h2>Java 17(GA 2021/09/14)</h2>
<ul>
<li>306:    Restore Always-Strict Floating-Point Semantics</li>
<li>356:    Enhanced Pseudo-Random Number Generators</li>
<li>382:    New macOS Rendering Pipeline</li>
<li>391:    macOS/AArch64 Port</li>
<li>398:    Deprecate the Applet API for Removal</li>
<li>403:    Strongly Encapsulate JDK Internals</li>
<li><a href="Java17/jep406-pattern-matching-for-switch-preview">406:    Pattern Matching for switch (Preview)</a></li>
<li>407:    Remove RMI Activation</li>
<li><a href="Java17/jep409-sealed-classes">409:    Sealed Classes</a></li>
<li>410:    Remove the Experimental AOT and JIT Compiler</li>
<li>411:    Deprecate the Security Manager for Removal</li>
<li>412:    Foreign Function &amp; Memory API (Incubator)</li>
<li>414:    Vector API (Second Incubator)</li>
<li>415:    Context-Specific Deserialization Filters</li>
</ul>
<h2>Java 16(GA 2021/03/16)</h2>
<ul>
<li>338:    Vector API (Incubator)</li>
<li>347:    Enable C++14 Language Features</li>
<li>357:    Migrate from Mercurial to Git</li>
<li>369:    Migrate to GitHub</li>
<li>376:    ZGC: Concurrent Thread-Stack Processing</li>
<li>380:    Unix-Domain Socket Channels</li>
<li>386:    Alpine Linux Port</li>
<li>387:    Elastic Metaspace</li>
<li>388:    Windows/AArch64 Port</li>
<li>389:    Foreign Linker API (Incubator)</li>
<li>390:    Warnings for Value-Based Classes</li>
<li>392:    Packaging Tool</li>
<li>393:    Foreign-Memory Access API (Third Incubator)</li>
<li><a href="Java16/jep394-pattern-matching-for-instanceof">394:    Pattern Matching for instanceof</a></li>
<li><a href="Java16/jep395-records">395:    Records</a></li>
<li>396:    Strongly Encapsulate JDK Internals by Default</li>
<li>397:    Sealed Classes (Second Preview)</li>
</ul>
<h2>Java 15(GA 2020/09/15)</h2>
<ul>
<li>339:    Edwards-Curve Digital Signature Algorithm (EdDSA)</li>
<li>360:    Sealed Classes (Preview)</li>
<li><a href="Java15/jep371-hidden-classes">371:    Hidden Classes</a></li>
<li>372:    Remove the Nashorn JavaScript Engine</li>
<li>373:    Reimplement the Legacy DatagramSocket API</li>
<li>374:    Disable and Deprecate Biased Locking</li>
<li>375:    Pattern Matching for instanceof (Second Preview)</li>
<li>377:    ZGC: A Scalable Low-Latency Garbage Collector</li>
<li><a href="Java15/jep378-text-blocks">378:    Text Blocks</a></li>
<li>379:    Shenandoah: A Low-Pause-Time Garbage Collector</li>
<li>381:    Remove the Solaris and SPARC Ports</li>
<li>383:    Foreign-Memory Access API (Second Incubator)</li>
<li>384:    Records (Second Preview)</li>
<li>385:    Deprecate RMI Activation for Removal</li>
</ul>
<h2>Java 14(GA 2020/03/17)</h2>
<ul>
<li>305:    Pattern Matching for instanceof (Preview)</li>
<li>343:    Packaging Tool (Incubator)</li>
<li>345:    NUMA-Aware Memory Allocation for G1</li>
<li>349:    JFR Event Streaming</li>
<li>352:    Non-Volatile Mapped Byte Buffers</li>
<li>358:    Helpful NullPointerExceptions</li>
<li>359:    Records (Preview)</li>
<li><a href="Java14/jep361-switch-expressions">361:    Switch Expressions (Standard)</a></li>
<li>362:    Deprecate the Solaris and SPARC Ports</li>
<li>363:    Remove the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>364:    ZGC on macOS</li>
<li>365:    ZGC on Windows</li>
<li>366:    Deprecate the ParallelScavenge + SerialOld GC Combination</li>
<li>367:    Remove the Pack200 Tools and API</li>
<li>368:    Text Blocks (Second Preview)</li>
<li>370:    Foreign-Memory Access API (Incubator)</li>
</ul>
<h2>Java 13(GA 2019/09/17)</h2>
<ul>
<li>350: Dynamic CDS Archives</li>
<li>351: ZGC: Uncommit Unused Memory</li>
<li>353: Reimplement the Legacy Socket API</li>
<li>354: Switch Expressions (Preview)</li>
<li>355: Text Blocks (Preview)</li>
</ul>
<h2>Java 12(GA 2019/03/19)</h2>
<ul>
<li>189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</li>
<li>230: Microbenchmark Suite</li>
<li>325: Switch Expressions (Preview)</li>
<li>334: JVM Constants API</li>
<li>340: One AArch64 Port, Not Two</li>
<li>341: Default CDS Archives</li>
<li>344: Abortable Mixed Collections for G1</li>
<li>346: Promptly Return Unused Committed Memory from G1</li>
</ul>
<h2>Java 11(GA 2018/09/25)</h2>
<ul>
<li>181: Nest-Based Access Control</li>
<li>309: Dynamic Class-File Constants</li>
<li>315: Improve Aarch64 Intrinsics</li>
<li>318: Epsilon: A No-Op Garbage Collector</li>
<li><a href="Java11/jep320-remove-JavaEE-CORBA">320: Remove the Java EE and CORBA Modules</a></li>
<li>321: HTTP Client (Standard)</li>
<li>323: Local-Variable Syntax for Lambda Parameters</li>
<li>324: Key Agreement with Curve25519 and Curve448</li>
<li>327: Unicode 10</li>
<li>328: Flight Recorder</li>
<li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li>
<li>330: Launch Single-File Source-Code Programs</li>
<li>331: Low-Overhead Heap Profiling</li>
<li>332: Transport Layer Security (TLS) 1.3</li>
<li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li>
<li>335: Deprecate the Nashorn JavaScript Engine</li>
<li>336: Deprecate the Pack200 Tools and API</li>
</ul>
<h2>Java 10(GA 2018/03/20)</h2>
<ul>
<li><a href="Java10/jep286-local-variable-type-inference">286: Local-Variable Type Inference</a></li>
<li>296: Consolidate the JDK Forest into a Single Repository</li>
<li>304: Garbage-Collector Interface</li>
<li>307: Parallel Full GC for G1</li>
<li>310: Application Class-Data Sharing</li>
<li>312: Thread-Local Handshakes</li>
<li>313: Remove the Native-Header Generation Tool (Javah)</li>
<li>314: Additional Unicode Language-Tag Extensions</li>
<li>316: Heap Allocation on Alternative Memory Devices</li>
<li>317: Experimental Java-Based JIT Compiler</li>
<li>319: Root Certificates</li>
<li>322: Time-Based Release Versioning</li>
</ul>
<h2>Java 9(GA 2017/09/21)</h2>
<ul>
<li>102: Process API Updates</li>
<li>110: HTTP 2 Client</li>
<li>143: Improve Contended Locking</li>
<li>158: Unified JVM Logging</li>
<li>165: Compiler Control</li>
<li>193: Variable Handles</li>
<li>197: Segmented Code Cache</li>
<li>199: Smart Java Compilation, Phase Two</li>
<li>200: The Modular JDK</li>
<li>201: Modular Source Code</li>
<li>211: Elide Deprecation Warnings on Import Statements</li>
<li>212: Resolve Lint and Doclint Warnings</li>
<li>213: Milling Project Coin</li>
<li>214: Remove GC Combinations Deprecated in JDK 8</li>
<li>215: Tiered Attribution for javac</li>
<li>216: Process Import Statements Correctly</li>
<li>217: Annotations Pipeline 2.0</li>
<li>219: Datagram Transport Layer Security (DTLS)</li>
<li>220: Modular Run-Time Images</li>
<li>221: Simplified Doclet API</li>
<li><a href="Java9/jep222-jshell">222: jshell: The Java Shell (Read-Eval-Print Loop)</a></li>
<li>223: New Version-String Scheme</li>
<li>224: HTML5 Javadoc</li>
<li>225: Javadoc Search</li>
<li>226: UTF-8 Property Files</li>
<li>227: Unicode 7.0</li>
<li>228: Add More Diagnostic Commands</li>
<li>229: Create PKCS12 Keystores by Default</li>
<li>231: Remove Launch-Time JRE Version Selection</li>
<li>232: Improve Secure Application Performance</li>
<li>233: Generate Run-Time Compiler Tests Automatically</li>
<li>235: Test Class-File Attributes Generated by javac</li>
<li>236: Parser API for Nashorn</li>
<li>237: Linux/AArch64 Port</li>
<li>238: Multi-Release JAR Files</li>
<li>240: Remove the JVM TI hprof Agent</li>
<li>241: Remove the jhat Tool</li>
<li>243: Java-Level JVM Compiler Interface</li>
<li>244: TLS Application-Layer Protocol Negotiation Extension</li>
<li>245: Validate JVM Command-Line Flag Arguments</li>
<li>246: Leverage CPU Instructions for GHASH and RSA</li>
<li>247: Compile for Older Platform Versions</li>
<li>248: Make G1 the Default Garbage Collector</li>
<li>249: OCSP Stapling for TLS</li>
<li>250: Store Interned Strings in CDS Archives</li>
<li>251: Multi-Resolution Images</li>
<li>252: Use CLDR Locale Data by Default</li>
<li>253: Prepare JavaFX UI Controls &amp; CSS APIs for Modularization</li>
<li>254: Compact Strings</li>
<li>255: Merge Selected Xerces 2.11.0 Updates into JAXP</li>
<li>256: BeanInfo Annotations</li>
<li>257: Update JavaFX/Media to Newer Version of GStreamer</li>
<li>258: HarfBuzz Font-Layout Engine</li>
<li>259: Stack-Walking API</li>
<li>260: Encapsulate Most Internal APIs</li>
<li>261: Module System</li>
<li>262: TIFF Image I/O</li>
<li>263: HiDPI Graphics on Windows and Linux</li>
<li>264: Platform Logging API and Service</li>
<li>265: Marlin Graphics Renderer</li>
<li>266: More Concurrency Updates</li>
<li>267: Unicode 8.0</li>
<li>268: XML Catalogs</li>
<li><a href="Java9/jep269-convenience-factory-methods-for-collections">269: Convenience Factory Methods for Collections</a></li>
<li>270: Reserved Stack Areas for Critical Sections</li>
<li>271: Unified GC Logging</li>
<li>272: Platform-Specific Desktop Features</li>
<li>273: DRBG-Based SecureRandom Implementations</li>
<li>274: Enhanced Method Handles</li>
<li>275: Modular Java Application Packaging</li>
<li>276: Dynamic Linking of Language-Defined Object Models</li>
<li>277: Enhanced Deprecation</li>
<li>278: Additional Tests for Humongous Objects in G1</li>
<li>279: Improve Test-Failure Troubleshooting</li>
<li>280: Indify String Concatenation</li>
<li>281: HotSpot C++ Unit-Test Framework</li>
<li>282: jlink: The Java Linker</li>
<li>283: Enable GTK 3 on Linux</li>
<li>284: New HotSpot Build System</li>
<li>285: Spin-Wait Hints</li>
<li>287: SHA-3 Hash Algorithms</li>
<li>288: Disable SHA-1 Certificates</li>
<li>289: Deprecate the Applet API</li>
<li>290: Filter Incoming Serialization Data</li>
<li>291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>292: Implement Selected ECMAScript 6 Features in Nashorn</li>
<li>294: Linux/s390x Port</li>
<li>295: Ahead-of-Time Compilation</li>
<li>297: Unified arm32/arm64 Port</li>
<li>298: Remove Demos and Samples</li>
<li>299: Reorganize Documentation</li>
</ul>
<h2>Java 8(GA 2014/03/18)</h2>
]]></content:encoded>
    </item>
    <item>
      <title>Java 10 新特性：局部变量类型推断</title>
      <link>https://www.geekyspace.cn/md/java/features/Java10/jep286-local-variable-type-inference.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java10/jep286-local-variable-type-inference.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 10 新特性：局部变量类型推断</source>
      <description>Java 10 新特性：局部变量类型推断 Java 10 引入了一项新的语言特性，即局部变量类型推断（Local-Variable Type Inference）， 它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。 语法 局部变量类型推断的语法非常简单，只需要将 var 关键字作为局部变量的类型即可。 示例 相比传统的方式和 Java ...</description>
      <category>Java Features</category>
      <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 10 引入了一项新的语言特性，即<strong>局部变量类型推断</strong>（Local-Variable Type Inference），
它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。</p>
<h2>语法</h2>
<p>局部变量类型推断的语法非常简单，只需要将 <code>var</code> 关键字作为局部变量的类型即可。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 自动推断 ArrayList&lt;String&gt;</span>
<span class="token keyword">var</span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 自动推断 Stream&lt;String&gt;</span>
</code></pre></div><h2>示例</h2>
<p>相比传统的方式和 Java 7 的钻石操作符（Diamond Operator），Java 10 的局部变量类型推断使得代码更加精炼：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 传统方式（等号两边都需要）</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Java7的钻石操作符（Diamond Operator）（只需要在左边申明类型即可）</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Java10的局部变量类型推断（类型在等号右边决定）</span>
<span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在使用 var 进行局部变量类型推断时，需要注意以下几点：</p>
<ol>
<li>必须在声明的同时进行初始化</li>
<li>仅限于局部变量，不能用于定义成员变量、方法参数和返回类型</li>
<li>每次只能定义一个变量，不能复合声明多个变量</li>
</ol>
<p>通过使用局部变量类型推断，我们能够在不失代码可读性的前提下，减少了冗余的类型声明，使得代码更加简洁清晰。
这一特性尤其在Lambda表达式、集合初始化等场景下表现突出，提高了代码的书写效率。
在实际项目中，合理运用局部变量类型推断，将有助于代码的维护和阅读。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</title>
      <link>https://www.geekyspace.cn/md/java/features/Java11/jep320-remove-JavaEE-CORBA.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java11/jep320-remove-JavaEE-CORBA.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</source>
      <description>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX Java 11 中移除了 Java EE 和 CORBA 模块，同时 JavaFX 也被剥离，但仍可作为独立模块使用。 Java9 弃用过程 在 Java 9 中，Java EE 和 CORBA 模块被标记为 @Deprecated，为开发者提供了适应期。 Java11 彻底删...</description>
      <category>Java Features</category>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 11 中移除了 <code>Java EE</code> 和 <code>CORBA</code> 模块，同时 <code>JavaFX</code> 也被剥离，但仍可作为独立模块使用。</p>
<h2>Java9 弃用过程</h2>
<p>在 Java 9 中，<code>Java EE</code> 和 <code>CORBA</code> 模块被标记为 @Deprecated，为开发者提供了适应期。</p>
<h2>Java11 彻底删除</h2>
<p>Java 11 完全删除了以下九个模块：</p>
<ul>
<li>java.xml.ws（包含 JAX-WS、SAAJ 和 Web 服务元数据）</li>
<li>java.xml.bind（JAXB）</li>
<li>java.activation(JAF)</li>
<li>java.xml.ws.annotation（常用注解）</li>
<li>java.corba（CORBA）</li>
<li>java.transaction(JTA)</li>
<li>java.se.ee (以上6个模块的聚合模块)</li>
<li>jdk.xml.ws (JAX-WS 工具)</li>
<li>jdk.xml.bind (JAXB 工具)</li>
</ul>
<p>删除后的影响：</p>
<ul>
<li>源代码从 OpenJDK 存储库中删除</li>
<li>在 JDK 运行时映像中将不包含这些类</li>
<li>相关工具将不再可用:
<ul>
<li>wsgen and wsimport (来自 jdk.xml.ws)</li>
<li>schemagen and xjc (来自 jdk.xml.bind)</li>
<li>idlj, orbd, servertool, and tnamesrv (来自 java.corba)</li>
</ul>
</li>
<li>JNDI CosNaming 提供者 (来自 java.corba) 将不再可用</li>
<li>不再有命令行标志能够启用它们，就像 JDK 9 上的 --add-modules 一样</li>
</ul>
<h2>JavaFX 移除</h2>
<p><code>JavaFX</code> 在 Java 11 中被移除，但仍可以作为独立模块使用。
开发者需要额外的配置和依赖，以在项目中继续使用 JavaFX 技术。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 14 新特性：switch表达式增强</title>
      <link>https://www.geekyspace.cn/md/java/features/Java14/jep361-switch-expressions.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java14/jep361-switch-expressions.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 14 新特性：switch表达式增强</source>
      <description>Java 14 新特性：switch表达式增强 Java 14(JEP 361)引入了 switch 表达式的新特性，其中包括了 &amp;quot;箭头标签（case ... -&amp;gt;）&amp;quot; 和 yield 语句的增强， 同时支持 Lambda 语法，使得代码更加灵活、简洁，并为未来的模式匹配(JEP 305)特性做好了准备。 传统的switch语句 首先，让我们回顾一下传...</description>
      <category>Java Features</category>
      <pubDate>Mon, 25 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 14(JEP 361)引入了 switch 表达式的新特性，其中包括了 "<strong>箭头标签</strong>（<code>case ... -&gt;</code>）" 和 <code>yield</code> 语句的增强，
同时支持 <code>Lambda</code> 语法，使得代码更加灵活、简洁，并为未来的<strong>模式匹配</strong>(JEP 305)特性做好了准备。</p>
<h2>传统的switch语句</h2>
<p>首先，让我们回顾一下传统的switch语句，它们在处理多个条件时可能显得有些冗长：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">FRIDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">SUNDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">SATURDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>传统的 switch 语句存在以下问题：</p>
<ol>
<li>设计受到C和C++等低级语言的影响，且默认支持fall through语义</li>
<li>过多的<code>break</code>语句使得代码显得冗长</li>
</ol>
<h2>switch表达式增强</h2>
<h3>箭头标签（case L -&gt;）</h3>
<ol>
<li>引入了一种新的开关标签"<code>case L -&gt;</code>"，用于表示只有一个分支的情况</li>
<li>允许每种情况下有多个常量，用逗号分隔</li>
<li>标签右侧的代码仅限于表达式、块或抛出异常throw语句</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span> <span class="token constant">SUNDAY</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span>                <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">SATURDAY</span>     <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span>              <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>局部变量独立作用域</h3>
<p>在 Java 14 中，允许在每个分支中声明局部变量，避免块中变量命名冲突和误用。</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>switch (day) {
    case MONDAY:
    case TUESDAY:
        int temp = ...     // 'temp'的作用域延续到 }
        break;
    case WEDNESDAY:
    case THURSDAY:
        int temp2 = ...    // 不能将此变量命名为'temp'
        break;
    default:
        int temp3 = ...    // 不能将此变量命名为'temp'
}
</code></pre></div><h3>switch表达式</h3>
<p>Switch 表达式被引入，允许将 <code>switch</code> 语句用作表达式，通过 <code>Lambda</code> 语法，根据输入值返回不同的结果。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 根据输入值`k`的不同，返回不同的字符串，并通过`System.out.println`打印结果</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">howMany</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span>  <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token string">"one"</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span>  <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token string">"two"</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token string">"many"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Switch表达式的常见形式如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">L1</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">L2</span> <span class="token operator">-&gt;</span> e2<span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> e3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote>
<p>Switch表达式是多态表达式（poly expression）。</p>
<p>多态性是指在编译时不确定具体类型，而在运行时确定类型的特性。</p>
</blockquote>
<h3>yield语句返回值</h3>
<p>允许在switch表达式中使用<code>yield</code>语句，而不是使用<code>break</code>语句，用于返回一个值，结束switch表达式的执行。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> numLetters <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span> <span class="token constant">SUNDAY</span> <span class="token operator">-&gt;</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span>                <span class="token operator">-&gt;</span> <span class="token number">7</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">SATURDAY</span>     <span class="token operator">-&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token function">performComplexCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在这里进行一些复杂的计算</span>
        <span class="token keyword">yield</span> temp<span class="token punctuation">;</span>                              <span class="token comment">// 使用yield返回计算结果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2>发展脉络</h2>
<p>追溯JEP 361的发展历程：从JDK 12预览版(JEP 325)到JDK 13预览版(JEP 354)，
虽然部分功能在早期版本中已经出现，但建议在 JDK 14 及以后的版本中使用，以获得更好的稳定性和支持。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：隐藏类（Hidden Classes）</title>
      <link>https://www.geekyspace.cn/md/java/features/Java15/jep371-hidden-classes.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java15/jep371-hidden-classes.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 15 新特性：隐藏类（Hidden Classes）</source>
      <description>Java 15 新特性：隐藏类（Hidden Classes） 隐藏类（Hidden Classes） 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用， 需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性： 动态生成内部类：隐藏类天生为框架设计，在运行时生成内部类 反射访问限制：隐藏类只能通过反射访问，不能直接被其他...</description>
      <category>Java Features</category>
      <pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p><strong>隐藏类</strong>（Hidden Classes） 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用，
需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性：</p>
<ul>
<li><strong>动态生成内部类</strong>：隐藏类天生为框架设计，在运行时生成内部类</li>
<li><strong>反射访问限制</strong>：隐藏类只能通过反射访问，不能直接被其他类的字节码访问</li>
<li><strong>独立加载和卸载</strong>：隐藏类可以独立于其他类加载和卸载</li>
<li><strong>框架扩展性</strong>：适用于需要在运行时生成类的框架，提高语言的灵活性和效率</li>
</ul>
<h2>原理</h2>
<h2>框架中应用</h2>
<p><a href="https://bugs.openjdk.org/browse/JDK-8220607" target="_blank" rel="noopener noreferrer">https://bugs.openjdk.org/browse/JDK-8220607</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：文本块（Text Blocks）</title>
      <link>https://www.geekyspace.cn/md/java/features/Java15/jep378-text-blocks.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java15/jep378-text-blocks.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 15 新特性：文本块（Text Blocks）</source>
      <description>Java 15 新特性：文本块（Text Blocks） Java 15(JEP 378)引入了文本块（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。 文本块通过引入三个双引号的胖分隔符（&amp;quot;&amp;quot;&amp;quot;）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。 快速上手 HTML示...</description>
      <category>Java Features</category>
      <pubDate>Wed, 27 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 15(JEP 378)引入了<strong>文本块</strong>（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。
文本块通过引入三个双引号的<strong>胖分隔符</strong>（<code>"""</code>）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。</p>
<h2>快速上手</h2>
<p><strong>HTML示例</strong></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 使用“一维”字符串文字</span>
<span class="token class-name">String</span> html <span class="token operator">=</span> <span class="token string">"&lt;html&gt;\n"</span> <span class="token operator">+</span>
              <span class="token string">"    &lt;body&gt;\n"</span> <span class="token operator">+</span>
              <span class="token string">"        &lt;p&gt;Hello, world&lt;/p&gt;\n"</span> <span class="token operator">+</span>
              <span class="token string">"    &lt;/body&gt;\n"</span> <span class="token operator">+</span>
              <span class="token string">"&lt;/html&gt;\n"</span><span class="token punctuation">;</span>

<span class="token comment">// 使用“二维”文本块</span>
<span class="token class-name">String</span> html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
              &lt;html&gt;
                  &lt;body&gt;
                      &lt;p&gt;Hello, world&lt;/p&gt;
                  &lt;/body&gt;
              &lt;/html&gt;
              """</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>SQL示例</strong></p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">// 使用“一维”字符串文字</span>
String query <span class="token operator">=</span> <span class="token string">"SELECT \"EMP_ID\", \"LAST_NAME\" FROM \"EMPLOYEE_TB\"\n"</span> <span class="token operator">+</span>
               <span class="token string">"WHERE \"CITY\" = 'INDIANAPOLIS'\n"</span> <span class="token operator">+</span>
               <span class="token string">"ORDER BY \"EMP_ID\", \"LAST_NAME\";\n"</span><span class="token punctuation">;</span>

<span class="token comment">// 使用“二维”文本块</span>
String query <span class="token operator">=</span> <span class="token string">"""
               SELECT "</span>EMP_ID<span class="token string">", "</span>LAST_NAME<span class="token string">" FROM "</span>EMPLOYEE_TB<span class="token string">"
               WHERE "</span>CITY<span class="token string">" = 'INDIANAPOLIS'
               ORDER BY "</span>EMP_ID<span class="token string">", "</span>LAST_NAME<span class="token string">";
               """</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>Polyglot语言示例</strong></p>
<div class="language-polyglot" data-ext="polyglot" data-title="polyglot"><pre class="language-polyglot"><code>// 使用“一维”字符串文字
ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
Object obj = engine.eval("function hello() {\n" +
                         "    print('\"Hello, world\"');\n" +
                         "}\n" +
                         "\n" +
                         "hello();\n");

// 使用“二维”文本块
ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
Object obj = engine.eval("function hello() {\n" +
                         "    print('\"Hello, world\"');\n" +
                         "}\n" +
                         "\n" +
                         "hello();\n");
</code></pre></div><h2>编译时处理</h2>
<p>文本块是String类型的常量表达式，类似于字符串字面量。然而，与字符串字面值不同，文本块的内容在编译时经历三个步骤的处理：<mark>行终止符的规范化</mark>、<mark>附带白色空间的移除</mark>和<mark>解释转义序列</mark>：</p>
<ol>
<li>转换内容的行终止符
<ul>
<li>行终止符从CR（\u000D）和CRLF（\u000D\u000A）规范化为<code>LF（\u000A）</code></li>
</ul>
</li>
<li>删除内容周围附带的白色空间（用于匹配Java源代码的缩进）</li>
<li>解释内容中的转义序列，执行解释作为最后一步开发人员可以编写转义序列，如\n，而不会被前面的步骤修改或删除</li>
</ol>
<p>处理后的内容以<code>CONSTANT_String_info</code>形式记录在<strong>类文件的常量池</strong>中，运行时，文本块被计算为String的实例。</p>
<h2>新增转义序列</h2>
<p>为了更精细地控制<mark>换行符</mark>和<mark>空格</mark>的处理，引入了两个新的转义序列：\ &lt;line-terminator&gt; 和 \s。</p>
<h3>换行符 \ &lt;line-terminator&gt;</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 传统方式</span>
<span class="token class-name">String</span> literal <span class="token operator">=</span> <span class="token string">"Lorem ipsum dolor sit amet, consectetur adipiscing "</span> <span class="token operator">+</span>
                 <span class="token string">"elit, sed do eiusmod tempor incididunt ut labore "</span> <span class="token operator">+</span>
                 <span class="token string">"et dolore magna aliqua."</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 \ &lt;line-terminator\&gt;</span>
<span class="token class-name">String</span> text <span class="token operator">=</span> <span class="token string">""</span>"
              <span class="token class-name">Lorem</span> ipsum dolor sit amet<span class="token punctuation">,</span> consectetur adipiscing \
              elit<span class="token punctuation">,</span> sed <span class="token keyword">do</span> eiusmod tempor incididunt ut labore \
              et dolore magna aliqua<span class="token punctuation">.</span>\
              <span class="token string">""</span>"<span class="token punctuation">;</span>
</code></pre></div><blockquote>
<p>Tips： 因为字符和传统字符串不允许嵌入换行符，所以\ &lt;line-terminator&gt; 转义序列只适用于文本块</p>
</blockquote>
<h3>单个空格 \s</h3>
<p>新的 \s 转义序列简单地转换为单个空格（\u0020）</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 使用 \s 保持固定长度</span>
<span class="token class-name">String</span> colors <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
    red  \s
    green\s
    blue \s
    """</span><span class="token punctuation">;</span>
</code></pre></div><p>转义序列直到去除无意义的空格后才被解释，\s 可以作为栅栏，防止尾随空格被去除。
在这个示例中，每行末尾使用 \s 可以确保每行长度恰好为六个字符。</p>
<h2>文本块连接</h2>
<p>文本块的连接是引入的一个方便的特性，使得字符串的拼接变得更加简洁。
在连接时，相邻的文本块将自动合并，无需显式使用加号连接操作符。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 字符串和文本块连接</span>
<span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token string">"public void print(Object o) {"</span> <span class="token operator">+</span>
              <span class="token triple-quoted-string string">"""
                  System.out.println(Objects.toString(o));
              }
              """</span><span class="token punctuation">;</span>
                      
<span class="token comment">// 相邻的文本块将自动合并，无需显式使用加号连接操作符</span>
<span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
              public void print(Object o) {
              """</span>
              <span class="token triple-quoted-string string">"""
                  System.out.println(Objects.toString(o));
              }
              """</span><span class="token punctuation">;</span>
</code></pre></div><p>在上述示例中，两个相邻的文本块会自动连接，形成一个整体的字符串。
这种自动连接的特性让代码更加清晰，减少了冗余的拼接操作。</p>
<h2>文本块新方法</h2>
<p>文本块引入了一些新方法，以便更方便地处理多行字符串：</p>
<ul>
<li><code>String::stripIndent()</code>：去除多行字符串的前导空格</li>
<li><code>String::translateEscapes()</code>：转义多行字符串中的转义字符</li>
<li><code>String::formatted()</code>：在文本块中使用占位符进行值替换</li>
<li><code>String::lines()：</code>：将多行字符串拆分为行的流，方便逐行处理。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：instanceof 模式匹配</title>
      <link>https://www.geekyspace.cn/md/java/features/Java16/jep394-pattern-matching-for-instanceof.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java16/jep394-pattern-matching-for-instanceof.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 16 新特性：instanceof 模式匹配</source>
      <description>Java 16 新特性：instanceof 模式匹配 Java 16 引入了instanceof模式匹配的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的局部类型转换。 instanceof 基础用法 这个强制转换通常是在 instanceof 检查之后 的第一件事，所以为什么不围绕它优化一下语法呢？ instanceof 增强用法 若 ...</description>
      <category>Java Features</category>
      <pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 16 引入了<code>instanceof</code><strong>模式匹配</strong>的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的<strong>局部类型转换</strong>。</p>
<h2>instanceof 基础用法</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> someString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>  <span class="token comment">// 强制类型转换</span>
    <span class="token comment">// ... </span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个<strong>强制转换</strong>通常是在 <code>instanceof</code> 检查之后 的第一件事，所以为什么不围绕它优化一下语法呢？</p>
<h2>instanceof 增强用法</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> someString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这里 someString 超出了作用域</span>
</code></pre></div><ol>
<li>若 <code>instanceof</code> 检查成功，将自动将变量转换为指定类型</li>
<li>定义的变量实质上是一个<strong>局部变量</strong>，只在if语句的范围内可见</li>
</ol>
<h2>常见用法建议</h2>
<p>不仅如此！使用模式匹配，我们可以更灵活地应用条件测试。</p>
<ul>
<li>
<p>利用已定义的 obj，在不需要额外嵌套的情况下判断字符串是否以“Awesome”开头</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 以前</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>someObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> someObject<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"Awesome"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在</span>
<span class="token keyword">return</span> someObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span> someString <span class="token operator">&amp;&amp;</span> someString<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"Awesome"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>
<p>甚至在 equals 方法中，代码会更加简洁</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 以前</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现在</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">==</span> i<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
</ul>
<p>多么不同！现在代码简洁而直观。</p>
<h2>发展脉络</h2>
<p>该功能经历了2个预览版本（JDK 14中的JEP 305、JDK 15中的JEP 375），最终定稿于JDK 16中的JEP 394。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：record类</title>
      <link>https://www.geekyspace.cn/md/java/features/Java16/jep395-records.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java16/jep395-records.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 16 新特性：record类</source>
      <description>Java 16 新特性：record类 Java 16 引入的记录类（Records Classes）是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如equals()、hashCode()和toString()等，从而减少了开发者的样板代码。 传统Java Bean问题 在处理不可变数据时，传...</description>
      <category>Java Features</category>
      <pubDate>Fri, 29 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 16 引入的<strong>记录类</strong>（Records Classes）是一种用于简化不可变数据管理的特殊类。
它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法，
如<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>等，从而减少了开发者的样板代码。</p>
<h2>传统Java Bean问题</h2>
<p>在处理不可变数据时，传统的Java Bean存在“<mark>繁琐</mark>”和“<mark>冗长</mark>”的问题。
为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码，
包括<code>构造函数</code>、<code>访问器(getter/setter)</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>等。</p>
<p>例如，用于携带x和y坐标的类通常会演变成以下繁琐形式：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Point</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> other<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">.</span>y <span class="token operator">==</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Point[x=%d, y=%d]"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>引入record类</h2>
<p><strong>语法如下</strong>：使用 <code>record</code><mark>关键字</mark>，指定<mark>类名称</mark>为 Point，定义<mark>参数列表</mark> x 和 y 作为组件</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>record申明的类，具备这些特点：</p>
<ol>
<li>它是一个<code>final</code>类</li>
<li>自动实现<code>equals</code>、<code>hashCode</code>、<code>toString</code>函数</li>
<li>成员变量均为<code>public</code>属性</li>
</ol>
<p>所以，对于之前写的Point类，它等价于一个这样的类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Record类声明，使用record关键字，名称为Point，带有两个参数x和y</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 自动生成成员变量（fields）</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token comment">// 2. 自动生成构造函数(constructor)</span>
    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 自动生成的访问方法</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> x <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> y <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 4. 自动生成equals和hashCode方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> equals <span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 实现相等性比较的逻辑</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> hashCode <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 生成哈希码的逻辑</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 5. 自动生成toString方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> toString <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Point{"</span> <span class="token operator">+</span>
                <span class="token string">"x="</span> <span class="token operator">+</span> x <span class="token operator">+</span>
                <span class="token string">", y="</span> <span class="token operator">+</span> y <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过使用record类，你可以更专注于业务逻辑而不是样板代码，提高了代码的可读性和可维护性。</p>
<h2>显示声明紧凑构造函数</h2>
<p>未显式声明构造函数时，系统会自动生成包含所有成员变量的隐式构造函数。
当显式声明紧凑构造函数可以<mark>省略形式参数列表</mark>、编译后在构造函数的末尾<mark>自动分配</mark>给相应的形式参数（this.x = x;）。</p>
<ul>
<li>
<p><strong>验证参数</strong>的紧凑构造函数</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token class-name">String</span> title<span class="token punctuation">,</span> <span class="token class-name">String</span> author<span class="token punctuation">,</span> <span class="token keyword">int</span> pageCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Book</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pageCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"页数必须大于零."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
<li>
<p><strong>规范</strong>的紧凑构造函数</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 记录类 Rational 表示有理数，包含分子（num）和分母（denom）两个成员变量</span>
<span class="token keyword">record</span> <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> denom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> gcd <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> denom<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 计算最大公约数</span>
        num <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>                 <span class="token comment">// 将分子除以最大公约数</span>
        denom <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>               <span class="token comment">// 将分母除以最大公约数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个声明等同于传统的构造函数形式：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> denom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> demon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 逻辑代码</span>
        <span class="token keyword">int</span> gcd <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> denom<span class="token punctuation">)</span><span class="token punctuation">;</span>
        num <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>
        denom <span class="token operator">/=</span> gcd<span class="token punctuation">;</span>
        <span class="token comment">// 赋值代码</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>denom <span class="token operator">=</span> denom<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
<li>
<p>记录类<strong>语义一致性</strong></p>
<p>例如，考虑以下方式声明的记录类R：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token class-name">T1</span> c1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token class-name">Tn</span> cn<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>如果通过以下方式复制R的实例r1：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">R</span> r2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span><span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> r1<span class="token punctuation">.</span><span class="token function">cn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>则假设 r1 不是空引用，表达式 r1.equals(r2) 总是为 true。
这是因为记录类的隐式声明的 equals 方法保证了相同字段值的两个记录实例相等。</p>
<blockquote>
<p>Tips: 程序员需要谨慎确保显式声明的方法维持语义一致性</p>
</blockquote>
</li>
<li>
<p>避免不良风格的代码</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">SmallPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个不良风格的代码，违反了语义一致性的原则，访问器<code>x()</code>,<code>y()</code>方法调整类实例的状态；
<strong>改进建议</strong>， 如果需要限制坐标值的范围，应该在构造函数或其他明确的位置处理。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">SmallPoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 紧凑构造函数中限制坐标值的范围</span>
  <span class="token keyword">public</span> <span class="token class-name">SmallPoint</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
</ul>
<h2>发展脉络</h2>
<p><code>record</code> 类最初在JDK 14预览版(JEP 359)提出，随后在JDK 15预览版(JEP 384)再次推出。
最终，它在JDK 16中(JEP 395)正式发布，成为Java语言的一项重要特性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 17 新特性：switch模式匹配（Preview）</title>
      <link>https://www.geekyspace.cn/md/java/features/Java17/jep406-pattern-matching-for-switch-preview.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java17/jep406-pattern-matching-for-switch-preview.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 17 新特性：switch模式匹配（Preview）</source>
      <description>Java 17 新特性：switch模式匹配（Preview） 当case标签可以有模式时，有如下四个主要的设计问题，我们一一来看： 增强类型检查 switch表达式和语句的完整性 模式变量声明的作用域 处理null 模式匹配设计 增强类型检查 通过扩展switch模式匹配的case标签，现在支持除了原始数据类型（char、byte、short 或 i...</description>
      <category>Java Features</category>
      <pubDate>Sat, 30 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>当case标签可以有模式时，有如下四个主要的设计问题，我们一一来看：</p>
<ol>
<li>增强类型检查</li>
<li>switch表达式和语句的完整性</li>
<li>模式变量声明的作用域</li>
<li>处理null</li>
</ol>
<h2>模式匹配设计</h2>
<h3>增强类型检查</h3>
<p>通过扩展<code>switch</code>模式匹配的<code>case</code>标签，现在支持除了<strong>原始数据类型</strong>（<code>char</code>、<code>byte</code>、<code>short</code> 或 <code>int</code>）之外，
相应的<strong>包装类</strong>（<code>Character</code>、<code>Byte</code>、<code>Short</code> 或 <code>Integer</code>）、<code>String</code> 以及<code>Enum</code>类型等<strong>任何引用类型</strong>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> <span class="token constant">RED</span><span class="token punctuation">,</span> <span class="token constant">GREEN</span><span class="token punctuation">,</span> <span class="token constant">BLUE</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">typeTester</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token keyword">null</span>     <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Color</span> c  <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Enum，颜色具有 "</span> <span class="token operator">+</span> <span class="token class-name">Color</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token string">" 个值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Point</span> p  <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Record Class: "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ia <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Array，长度为"</span> <span class="token operator">+</span> ia<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span>       <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"其他情况"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote>
<p><strong>注意⚠️：要避免模式标签支配</strong>（编译异常）</p>
<p>如果一个模式标签在switch块中被先前的模式标签支配, 或者存在多个全匹配的标签（default 和 total类型模式）, 则会产生编译时错误。</p>
</blockquote>
<ul>
<li>例1: 模式 <code>case CharSequence cs</code> 支配 <code>case String s</code> ,因为 String 是 CharSequence 的子类</li>
<li>例2: 总模式的情况，如 <code>case p</code> 支配 <code>case null</code> 模式,因为总模式匹配所有值，包括null</li>
<li>例3: 模式 <code>case p</code> 支配 <code>case p &amp;&amp; e</code> ,因为满足第一个模式的值也满足第二个模式</li>
<li>例4: 模式 <code>case String s</code> 支配了带条件的模式 <code>case String s &amp;&amp; s.length() &gt; 0</code></li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">switch</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">CharSequence</span> cs <span class="token operator">-&gt;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一个长度为"</span> <span class="token operator">+</span> cs<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"的序列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-&gt;</span>    <span class="token comment">// 编译错误 - 模式被前一个模式支配</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一个字符串："</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>switch表达式和语句的完整性</h3>
<p>通常情况下，通过添加<code>default</code>标签，可以确保<code>switch</code>块的完整性。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printType</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Integer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Other"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果switch表达式的类型是<strong>密封类</strong>(<a href="https://openjdk.org/jeps/409" target="_blank" rel="noopener noreferrer">JEP 409</a>)，
则类型覆盖检查会考虑密封类的permits子句，以确保switch块的完整性。</p>
<p>以下是一个密封接口Animal的示例，包括Dog和Cat两个允许的子类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">sealed</span> <span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token keyword">permits</span> <span class="token class-name">Dog</span><span class="token punctuation">,</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getSound</span><span class="token punctuation">(</span><span class="token class-name">Animal</span> animal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>animal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Dog</span> d <span class="token operator">-&gt;</span> <span class="token string">"Woof!"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Cat</span> c <span class="token operator">-&gt;</span> <span class="token string">"Meow!"</span><span class="token punctuation">;</span>
        <span class="token comment">// no default needed!</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，由于编译器知道只有Dog和Cat是可能的类型，所以可以不需要<code>default</code>标签。
同样，对于枚举类，每个常量都有一个子句，也不需要default标签。</p>
<h3>模式变量声明的作用域</h3>
<p><code>instanceof</code>(<a href="https://openjdk.org/jeps/394" target="_blank" rel="noopener noreferrer">JEP 394</a>)进行<strong>模式匹配</strong>，
<strong>模式变量</strong>的作用域限定在<code>匹配的条件表达式</code>和相应的<code>then</code>块中。 如果匹配失败，模式变量在<code>else</code>块中不可见。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Not a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>switch</code>语句的<code>case</code>标签进行<strong>模式匹配</strong>，有以下两条规则：</p>
<ol>
<li>
<p><code>-&gt;</code>形式：作用域包括箭头右侧的表达式、块或 throw 语句</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Character</span> c <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">charValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Ding!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Character"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-&gt;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Invalid Integer argument of value "</span> <span class="token operator">+</span> i<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
<li>
<p><code>:</code>形式，则其作用域包括语句组的块语句，直到遇到下一个<code>switch</code>标签或其他控制流语句</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Character</span> c<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">charValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Ding "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">charValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Tab "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"character"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
</ol>
<h3>处理null</h3>
<p>引入新的<code>null</code>标签，用于明确处理选择表达式为<code>null</code>的情况</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// test(null) 不再抛出NullPointerException，而是打印 "null!"</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token keyword">null</span>     <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span>       <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Something else"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由空标签产生的新标签形式， JDK 16中，<code>switch</code>块支持两种风格，</p>
<ol>
<li><code>:</code> 形式，允许<code>fallthrough</code>，多个标签通常写为<code>case l1: case l2:</code></li>
<li><code>-&gt;</code>形式，不允许<code>fallthrough</code>，多个标签写为<code>case l1, l2-&gt;</code></li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 处理 null 和 String 标签，使用 : 形式</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token keyword">null</span><span class="token operator">:</span> <span class="token keyword">case</span> <span class="token class-name">String</span> s<span class="token operator">:</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String, including null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">break</span><span class="token punctuation">;</span>
   <span class="token comment">// 更多的 cases...</span>

<span class="token punctuation">}</span>

<span class="token comment">// 结合 null case 和 default 标签，使用 -&gt; 形式</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 更多的 cases...</span>
   <span class="token keyword">case</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">default</span> <span class="token operator">-&gt;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The rest (including null)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>保护模式和括号模式</h2>
<p>为了增强代码的可读性并避免歧义，引入了两种新的模式匹配技术：</p>
<ul>
<li>保护模式 (guarded patterns)，允许在模式匹配成功后添加一个布尔表达式</li>
<li>括号模式 (parenthesized patterns)，将模式放在括号中，避免歧义，控制顺序</li>
</ul>
<p>在成功匹配模式后，我们经常会进一步测试匹配结果。这会导致代码变得繁琐，例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">String</span> s<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<strong>保护模式</strong>，写成<code>p &amp;&amp; e</code>改进上面的代码，使其更加简洁</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s                    <span class="token operator">-&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote>
<p>JDK 17中还加入了<strong>括号模式</strong>，以避免解析歧义。支持括号内写入<code>(p)</code> 其中p是一个模式。在JDK 21中，括号模式被移除。</p>
</blockquote>
<h2>启用预览功能</h2>
<p>Preview阶段的功能并不是默认开启的，需要在编译和运行时启用。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">java</span> --enable-preview <span class="token parameter variable">--source</span> <span class="token number">17</span> PatternMatching.java
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 17 新特性：sealed类</title>
      <link>https://www.geekyspace.cn/md/java/features/Java17/jep409-sealed-classes.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java17/jep409-sealed-classes.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 17 新特性：sealed类</source>
      <description>Java 17 新特性：sealed类 Java 17 中引入了密封类（Sealed Classes），它是一种限制的类和接口， 可以控制哪些类继承或实现它，保证在编译时就能够确定类的继承关系，提高代码的可读性和可维护性。 密封类语法 密封类的声明使用关键字 sealed，并通过 permits 关键字声明允许继承或实现的类。 密封类对其允许的子类施加...</description>
      <category>Java Features</category>
      <pubDate>Sun, 31 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 17 中引入了<strong>密封类</strong>（Sealed Classes），它是一种限制的类和接口，
可以控制哪些类继承或实现它，保证在编译时就能够确定类的继承关系，提高代码的可读性和可维护性。</p>
<h2>密封类语法</h2>
<p>密封类的声明使用关键字 <code>sealed</code>，并通过 <code>permits</code> 关键字声明允许继承或实现的类。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 密封类</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类名 <span class="token keyword">permits</span> 子类名<span class="token number">1</span><span class="token punctuation">,</span> 子类名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类的成员</span>
<span class="token punctuation">}</span>

<span class="token comment">// 密封接口</span>
<span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">interface</span> 接口名 <span class="token keyword">extends</span> 父接口名 <span class="token keyword">permits</span> 子类名<span class="token number">1</span><span class="token punctuation">,</span> 子类名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
  <span class="token comment">// 接口的成员</span>
<span class="token punctuation">}</span>
</code></pre></div><p>密封类对其允许的子类施加了三个约束：</p>
<ol>
<li>密封类及其允许的子类必须属于同一个模块或同一包（对于未命名模块）</li>
<li>每个允许的子类必须直接扩展密封类</li>
<li>每个允许的子类必须使用修饰符描述其继承关系：
<ul>
<li><code>final</code>：表示该类不能被继承（记录类隐式声明为 <code>final</code>）</li>
<li><code>sealed</code>：表示该类可以被继承，但只能被允许的子类继承</li>
<li><code>non-sealed</code>：表示该类可以被继承，且可以被任意类继承</li>
</ul>
</li>
</ol>
<h2>历史限制继承手段</h2>
<p>对于继承能力的限制，Java 语言已经提供了以下几种手段：</p>
<ol>
<li><code>final</code>修饰类，这样类就无法被继承了</li>
<li>构造函数声明为<code>private</code>或<code>package-private</code>，则只能在同一类或同一包中创建该类的子类</li>
</ol>
<h2>发展脉络</h2>
<p>该功能经历了2个预览版本（JDK 15中的JEP 360、JDK 16中的JEP 397），最终定稿于JDK 17中的JEP 409。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 18 新特性：指定UTF-8为默认字符集</title>
      <link>https://www.geekyspace.cn/md/java/features/Java18/jep400-utf8-by-default.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java18/jep400-utf8-by-default.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 18 新特性：指定UTF-8为默认字符集</source>
      <description>Java 18 新特性：指定UTF-8为默认字符集 在Java 18中，将UTF-8指定为标准Java API 的默认字符集， 以提高Java程序在不同实现、操作系统、区域设置和配置下的一致性。 目标 使Java程序在依赖默认字符集的代码上更加可预测和可移植 明确标准Java API在何处使用默认字符集 在标准Java API中统一使用UTF-8，除了...</description>
      <category>Java Features</category>
      <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>在Java 18中，将<code>UTF-8</code>指定为标准Java API 的默认字符集，
以提高Java程序在不同实现、操作系统、区域设置和配置下的一致性。</p>
<h2>目标</h2>
<ul>
<li>使Java程序在依赖默认字符集的代码上更加可预测和<strong>可移植</strong></li>
<li>明确标准Java API在何处使用默认字符集</li>
<li>在标准Java API中统一使用UTF-8，除了控制台I/O</li>
</ul>
<p>尽管这项工作可能会发现新的便利方法可能会使现有的API更易于使用，但这一更改并不是要弃用或删除依赖默认字符集的标准Java API。</p>
<h2>动机</h2>
<p>默认情况下，Java API 会根据<strong>运行时环境</strong>（操作系统、用户的区域设置等）选择默认字符集。
为了提高 Java API 的一致性并降低潜在的兼容性问题，我们建议将所有 Java API 统一使用 <code>UTF-8</code> 作为默认字符集。
尽管这一变更可能对迁移到 JDK 18 的程序产生兼容性影响，但我们提供了一个 <code>COMPAT</code> 选项，允许恢复到之前的行为，即默认字符集取决于环境。</p>
<h2>描述</h2>
<h3>兼容性危害示例</h3>
<p>在MacOS上以<code>UTF-8</code>编码的日语文本文件在Windows上以美英或日语区域设置读取时被损坏</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FileReader</span><span class="token punctuation">(</span>“hello<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> “こんにちは” <span class="token punctuation">(</span>macOS<span class="token punctuation">)</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FileReader</span><span class="token punctuation">(</span>“hello<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> “ã<span class="token operator">?</span>“ã‚“ã<span class="token operator">?</span>«ã<span class="token operator">?</span>¡ã<span class="token operator">?</span> ” <span class="token punctuation">(</span><span class="token class-name">Windows</span> <span class="token punctuation">(</span>en<span class="token operator">-</span><span class="token constant">US</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FileReader</span><span class="token punctuation">(</span>“hello<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> “縺ォ縺。縺ッ” <span class="token punctuation">(</span><span class="token class-name">Windows</span> <span class="token punctuation">(</span>ja<span class="token operator">-</span><span class="token constant">JP</span><span class="token punctuation">)</span>
</code></pre></div><h3>查询默认字符集</h3>
<p>通过方法 <code>java.nio.charset.Charset.defaultCharset()</code> 可以获取默认字符集。</p>
<p>另外，使用以下命令可以快速查看当前 JDK 的默认字符集：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>java <span class="token operator">-</span><span class="token class-name">XshowSettings</span><span class="token operator">:</span>properties <span class="token operator">-</span>version <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">|</span> grep file<span class="token punctuation">.</span>encoding
</code></pre></div><p>如果想在所有 Java 版本上获取从环境中确定的字符集，可以使用以下代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 获取native.encoding系统属性（在Java 18及更高版本上赋值）</span>
<span class="token class-name">String</span> encoding <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"native.encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用三元运算符选择字符集，如果encoding不为null，则使用指定字符集，否则使用默认字符集</span>
<span class="token class-name">Charset</span> cs <span class="token operator">=</span> <span class="token punctuation">(</span>encoding <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用指定字符集创建 FileReader 对象，打开名为 "file.txt" 的文件</span>
<span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> cs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>兼容使用默认字符集API（迁移）</h3>
<p>多个标准 Java API 使用默认字符集，包括：</p>
<ul>
<li>在 java.io 包中，InputStreamReader、FileReader、OutputStreamWriter、FileWriter 和 PrintStream
提供了构造函数，用于创建使用默认字符集进行编码或解码的读取器、写入器和打印流</li>
<li>在 java.util 包中，Formatter 和 Scanner 提供了构造函数，使用默认字符集进行操作</li>
<li>在 java.net 包中，URLEncoder 和 URLDecoder 提供了使用默认字符集的已弃用方法</li>
</ul>
<p>我们将更新所有使用 Charset.defaultCharset() 进行交叉引用的标准 Java API 的规范。
这些 API 包括上述提到的 API，但不包括 System.out 和 System.err，它们的字符集将由 Console.charset() 指定。</p>
<h3>file.encoding 和 native.encoding 系统属性</h3>
<p><code>file.encoding</code> 是 Java 虚拟机的系统属性，用于指定默认的字符编码</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">java</span> <span class="token parameter variable">-Dfile.encoding</span><span class="token operator">=</span>COMPAT   <span class="token comment"># COMPAT 模式, 默认字符集取决于环境</span>
<span class="token function">java</span> <span class="token parameter variable">-Dfile.encoding</span><span class="token operator">=</span>UTF-8    <span class="token comment"># UTF-8 模式, 默认字符集为UTF-8</span>
</code></pre></div><p><code>native.encoding</code> 在Java 17 中引入，该属性提供了底层主机环境的字符编码名称</p>
<p>Java内部使用了三个字符集相关的系统属性，它们目前未指定且不受支持。这里简要记录一下：</p>
<ol>
<li><code>sun.stdout.encoding</code></li>
<li><code>sun.stderr.encoding</code></li>
<li><code>sun.jnu.encoding</code>：</li>
</ol>
<blockquote>
<p>Tips：对于JDK(8-17)：强烈建议开发人员使用<code>java -Dfile.encoding=UTF-8</code>指定默认字符集为UTF-8启动程序</p>
</blockquote>
<h3>源文件编码</h3>
<p>Java语言允许源代码使用<code>UTF-16</code>编码方式表达<code>Unicode</code>字符，并且这不受默认字符集UTF-8的影响。
但是，<code>javac</code>编译器会受到影响，因为它需要将源代码转换为平台默认的字符集，除非通过<code>-encoding</code>选项进行配置</p>
<p>如果源文件以非UTF-8编码保存并在较早的JDK上进行编译，然后在JDK 18或更高版本上重新编译，可能会导致问题。
例如，如果非UTF-8源文件中的字符串文字包含非ASCII字符，则在JDK 18或更高版本中，除非使用<code>-encoding</code>选项，否则这些文字可能会被<code>javac</code>错误解释。</p>
<p>在使用UTF-8作为默认字符集的JDK上编译之前，强烈建议开发人员通过在当前JDK（8-17）上使用javac -encoding UTF-8 ... 进行编译来检查字符集问题。
另外，喜欢以非UTF-8编码保存源文件的开发人员可以通过将JDK 17及更高版本上的<code>-encoding</code>选项设置为<code>native.encoding</code>系统属性的值，防止javac假定UTF-8。</p>
<h3>旧版默认字符集（US-ASCII）</h3>
<p>在JDK 17及更早版本中，名称<code>default</code>会被识别为<code>US-ASCII</code>字符集的别名。</p>
<p>在JDK 18中，默认字符集<code>UTF-8</code>，保留<code>default</code>作为<code>US-ASCII</code>的别名将会非常混乱，于是重新定义<code>default</code>不再是<code>US-ASCII</code>的别名。</p>
<p>Java程序使用枚举常量StandardCharsets.US_ASCII来明确其开发人员意图，而不是向Charset.forName(...)传递字符串。</p>
<p>因此，在JDK 18中，<code>Charset.forName("default")</code>将抛出 UnsupportedCharsetException。
这将为开发人员提供检测到这种惯用法并迁移到US-ASCII或Charset.defaultCharset()结果的机会。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 18 新特性：简单Web服务器</title>
      <link>https://www.geekyspace.cn/md/java/features/Java18/jep408-simple-web-server.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java18/jep408-simple-web-server.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 18 新特性：简单Web服务器</source>
      <description>Java 18 新特性：简单Web服务器 Java 18 引入了简单Web服务器（Simple Web Server），一个专为教育或非正式任务设计的最小HTTP服务器，为单个目录层次结构提供服务。 基于JDK中的com.sun.net.httpserver包实现，旨在简化服务器的创建和请求处理过程。 主要特点： 不能替代成熟的商业服务器，如Jetty...</description>
      <category>Java Features</category>
      <pubDate>Tue, 02 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 18 引入了<strong>简单Web服务</strong>器（Simple Web Server），一个专为教育或非正式任务设计的最小HTTP服务器，为单个目录层次结构提供服务。
基于JDK中的<code>com.sun.net.httpserver</code>包实现，旨在简化服务器的创建和请求处理过程。</p>
<p>主要特点：</p>
<ul>
<li>不能替代成熟的商业服务器，如<code>Jetty</code>、<code>Nginx</code> 和 <code>Apache Tomcat</code>等</li>
<li>不提供身份验证、访问控制或加密等安全功能</li>
<li>仅支持HTTP/1.1，不支持HTTPS</li>
<li>仅支持GET、HEAD请求，否则返回 501 Not Implemented 或 405 Not Allowed</li>
</ul>
<h2>命令行工具</h2>
<p>为了开始使用简单Web服务器，您需要准备一个<code>index.html</code>文件，并执行以下步骤：</p>
<ol>
<li>打开终端。</li>
<li>输入命令：<code>jwebserver</code>。</li>
</ol>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ jwebserver
</code></pre></div><p>默认情况下，服务器将绑定到本地回环地址，并在端口8000上提供服务。看到类似以下的输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Binding to loopback by default. For all interfaces use <span class="token string">"-b 0.0.0.0"</span> or <span class="token string">"-b ::"</span><span class="token builtin class-name">.</span>
Serving /cwd and its subdirectories on <span class="token number">127.0</span>.0.1 port <span class="token number">8000</span>
URL: http://127.0.0.1:8000/
</code></pre></div><p>尝试访问一下 <code>http://127.0.0.1:8000/</code> ，就可以获得之前准备的HTML内容了。</p>
<h3>支持的命令行选项</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>选项：
       <span class="token parameter variable">-h</span> 或 -? 或 <span class="token parameter variable">--help</span>
              打印帮助信息并退出.

       <span class="token parameter variable">-b</span> addr 或 --bind-address addr
              指定绑定的地址。默认：127.0.0.1或::1（回环地址）。要使用所有接口，请使用 <span class="token parameter variable">-b</span> <span class="token number">0.0</span>.0.0 或 <span class="token parameter variable">-b</span> ::.

       <span class="token parameter variable">-d</span> <span class="token function">dir</span> 或 <span class="token parameter variable">--directory</span> <span class="token function">dir</span>
              指定要提供服务的目录。默认：当前目录.

       <span class="token parameter variable">-o</span> level 或 <span class="token parameter variable">--output</span> level
              指定输出格式。none <span class="token operator">|</span> info <span class="token operator">|</span> verbose。默认：info.

       <span class="token parameter variable">-p</span> port 或 <span class="token parameter variable">--port</span> port
              指定要监听的端口。默认：8000.

       <span class="token parameter variable">-version</span> 或 <span class="token parameter variable">--version</span>
              打印版本信息并退出。

       要停止服务器，请按 Ctrl + C.
</code></pre></div><h2>API编程方式</h2>
<p>尽管命令行工具提供了便利，但为了更灵活地定制处理程序的行为，与现有代码集成，提高代码的可读性和可维护性，我们引入了新的API。</p>
<blockquote>
<p>新的API中引入了三个新的类是<code>SimpleFileServer</code>、<code>HttpHandlers</code>和<code>Request</code>，
每个类都构建在<code>com.sun.net.httpserver</code>包中的现有类和接口上：<code>HttpServer</code>、<code>HttpHandler</code>、<code>Filter</code>和<code>HttpExchange</code>。</p>
</blockquote>
<h3>简单文件服务器（SimpleFileServer）</h3>
<p><code>SimpleFileServer</code>支持创建文件服务器、文件服务器处理程序和输出过滤器。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFileServer</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建文件服务器实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token number">1</span> <span class="token function">createFileServer</span><span class="token punctuation">(</span>
        <span class="token class-name">InetSocketAddress</span> addr<span class="token punctuation">,</span> <span class="token class-name">Path</span> rootDirectory<span class="token punctuation">,</span> <span class="token class-name">OutputLevel</span> outputLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>          
    
    <span class="token comment">// 创建文件服务器处理程序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HttpHandler</span> <span class="token function">createFileHandler</span><span class="token punctuation">(</span>
        <span class="token class-name">Path</span> rootDirectory<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    
    <span class="token comment">// 创建输出过滤器</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Filter</span> <span class="token function">createOutputFilter</span><span class="token punctuation">(</span>
        <span class="token class-name">OutputStream</span> out<span class="token punctuation">,</span> <span class="token class-name">OutputLevel</span> outputLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有了这个类，在<code>jshell</code>中只需几行代码，就可以启动一个最小但定制的<strong>文件服务器</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token keyword">var</span> server <span class="token operator">=</span> <span class="token class-name">SimpleFileServer</span><span class="token punctuation">.</span><span class="token function">createFileServer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"/some/path"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">SimpleFileServer<span class="token punctuation">.</span>OutputLevel</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>相当于命令行模式的：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>jwebserver <span class="token parameter variable">-p</span> <span class="token number">8080</span> <span class="token parameter variable">-d</span> /some/path <span class="token parameter variable">-o</span> info
</code></pre></div><h3>自定义处理程序和过滤器</h3>
<p>将自定义的<strong>文件服务器处理程序</strong>添加到现有服务器：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token class-name">SimpleFileServer</span><span class="token punctuation">.</span><span class="token function">createFileHandler</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"/some/path"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> <span class="token keyword">var</span> server <span class="token operator">=</span> <span class="token class-name">HttpServer</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"/store/"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SomePutHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> server<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">"/browse/"</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将自定义的<strong>输出过滤器</strong>在创建过程中添加到服务器：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token keyword">var</span> filter <span class="token operator">=</span> <span class="token class-name">SimpleFileServer</span><span class="token punctuation">.</span><span class="token function">createOutputFilter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token class-name">OutputLevel</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> <span class="token keyword">var</span> server <span class="token operator">=</span> <span class="token class-name">HttpServer</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"/store/"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SomePutHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>
jshell<span class="token operator">&gt;</span> server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>两个例子是由<code>HttpServer</code>和<code>HttpsServer</code>类中的新重载<code>create</code>方法启用的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HttpServer</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">InetSocketAddress</span> addr<span class="token punctuation">,</span>
                                <span class="token keyword">int</span> backlog<span class="token punctuation">,</span>
                                <span class="token class-name">String</span> root<span class="token punctuation">,</span>
                                <span class="token class-name">HttpHandler</span> handler<span class="token punctuation">,</span>
                                <span class="token class-name">Filter</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> filters<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div><h3>增强的请求处理（HttpHandlers）</h3>
<p>简单Web服务器的核心功能是<strong>处理程序</strong>。为了与现有代码兼容，我们引入了<code>HttpHandlers</code>类，
提供两个静态方法用于<mark>创建</mark>和<mark>自定义处理程序</mark>，还有<code>Filter</code>类中的新方法用于适配请求：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HttpHandlers</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// handleOrElse方法补充条件处理程序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HttpHandler</span> <span class="token function">handleOrElse</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Request</span><span class="token punctuation">&gt;</span></span> handlerTest<span class="token punctuation">,</span>
                                           <span class="token class-name">HttpHandler</span> handler<span class="token punctuation">,</span>
                                           <span class="token class-name">HttpHandler</span> fallbackHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    
    <span class="token comment">// of方法创建具有预设响应状态的处理程序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HttpHandler</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">int</span> statusCode<span class="token punctuation">,</span> <span class="token class-name">Headers</span> headers<span class="token punctuation">,</span> <span class="token class-name">String</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>
    <span class="token comment">// adaptRequest方法获取预处理过滤器，用于在处理请求之前检查和调整请求的某些属性</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Filter</span> <span class="token function">adaptRequest</span><span class="token punctuation">(</span>
        <span class="token class-name">String</span> description<span class="token punctuation">,</span> <span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Request</span><span class="token punctuation">&gt;</span></span> requestOperator<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些方法的用例包括基于请求方法委托交换，创建总是返回特定响应的“canned response”处理程序，或向所有传入请求添加标头。</p>
<h3>请求（Request）</h3>
<p>现有API中，使用HttpExchange类来表达HTTP<mark>请求-响应对</mark>，描述了请求-响应交换的完整可变状态。
然而，并非所有这状态对于处理程序的定制和适配都是必要的。
因此，我们引入了更简单的Request接口，提供<mark>请求</mark>的不可变状态的有限视图。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Request</span> <span class="token punctuation">{</span>
    <span class="token class-name">URI</span> <span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 获取请求的URI</span>
    <span class="token class-name">String</span> <span class="token function">getRequestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 获取请求的方法</span>
    <span class="token class-name">Headers</span> <span class="token function">getRequestHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取请求的标头</span>
    <span class="token comment">// 用于修改请求头部信息</span>
    <span class="token keyword">default</span> <span class="token class-name">Request</span> <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">String</span> headerName<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> headerValues<span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这使得可以直接定制现有的处理程序，例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建一个处理程序，根据请求方法选择对应的处理器，如果请求方法为 PUT，则使用 SomePutHandler，否则使用 SomeHandler</span>
<span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token class-name">HttpHandlers</span><span class="token punctuation">.</span><span class="token function">handleOrElse</span><span class="token punctuation">(</span>r <span class="token operator">-&gt;</span> 
    r<span class="token punctuation">.</span><span class="token function">getRequestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"PUT"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SomePutHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SomeHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个过滤器，用于修改请求头部信息，在请求中添加名为 "Foo" 的头部，值为 "Bar"</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token class-name">Filter</span><span class="token punctuation">.</span><span class="token function">adaptRequest</span><span class="token punctuation">(</span><span class="token string">"Add Foo header"</span><span class="token punctuation">,</span> r <span class="token operator">-&gt;</span> r<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个 HTTP 服务器，并指定端口为 8080，最大连接数为 10，根路径为 "/"，处理程序为 h，过滤器为 f</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token class-name">HttpServer</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动服务器</span>
s<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>替代品</h2>
<p><strong>命令行工具</strong>的替代方案：</p>
<ul>
<li>最初，使用 <code>java -m jdk.httpserver</code> 命令运行 Simple Web Server，没有专门的命令行工具</li>
<li>为了提高便利性和可访问性，我们引入了一个专门的工具 <code>jwebserver</code>
<ul>
<li>实际上 <code>jwebserver</code> 在后台使用了 <code>java -m ...</code> 命令</li>
</ul>
</li>
</ul>
<p><strong>API编程方式</strong>替代方案：</p>
<ul>
<li>新的 <code>DelegatingHandler</code> 类：捆绑定制方法在一个单独的类中，但由于引入了新类型并未添加更多功能，我们放弃了这个选项。</li>
<li>将 <code>HttpHandler</code> 作为服务：将 <code>HttpHandler</code> 转换为服务，并提供内部文件服务器处理程序实现。然而，这种方法对于我们要提供的功能来说过于复杂。</li>
<li>使用<strong>过滤器</strong>而不是 <code>HttpHandler</code>：仅使用过滤器来处理请求，但这样做不符合直觉，并且过滤器的方法会更难找到。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 18 新特性：新增@snipppet标签</title>
      <link>https://www.geekyspace.cn/md/java/features/Java18/jep413-code-snippets-in-api-documentation.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java18/jep413-code-snippets-in-api-documentation.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 18 新特性：新增@snipppet标签</source>
      <description>Java 18 新特性：新增@snipppet标签 Java 18 引入了@snippet标签，用于在API文档中嵌入代码片段，以便更好地展示API的使用方法。 主要特点： 有效性检查，代码包含语法错误时，会出现错误提示 启用现代样式，例如语法高亮显示，以及名称与声明的自动链接 为创建和编辑代码段提供更好的IDE支持 存在的@code标签 用于单独的小...</description>
      <category>Java Features</category>
      <pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 18 引入了<code>@snippet</code>标签，用于在API文档中嵌入代码片段，以便更好地展示API的使用方法。</p>
<p>主要特点：</p>
<ul>
<li>有效性检查，代码包含语法错误时，会出现错误提示</li>
<li>启用现代样式，例如语法高亮显示，以及名称与声明的自动链接</li>
<li>为创建和编辑代码段提供更好的IDE支持</li>
</ul>
<h2>存在的@code标签</h2>
<p>用于单独的小段代码, 当代码片段复杂时, 使用复合模式的文档注释，如下所示：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token operator">*</span> <span class="token generics"><span class="token punctuation">&lt;</span>pre<span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token annotation punctuation">@code</span>
 <span class="token operator">*</span>     源代码行<span class="token number">1</span>
 <span class="token operator">*</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token operator">*</span>     源代码行n
 <span class="token operator">*</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>pre<span class="token operator">&gt;</span>
</code></pre></div><h2>引入@snippet标签</h2>
<p>解决了<code>@code</code>标签的不足，允许在API文档中直接嵌入代码片段，以便更好地展示API的使用方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 以下代码显示了如何使用 <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Optional</span><span class="token punctuation">.</span>isPresent</span></span><span class="token punctuation">}</span>:
 * <span class="token punctuation">{</span><span class="token keyword">@snippet</span> :
 * if (v.isPresent()) <span class="token punctuation">{</span>
 *     System.out.println("v: " + v.get());
 * <span class="token punctuation">}</span>
 * <span class="token punctuation">}</span>
 */</span>
</code></pre></div><p>作为外部片段导入</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 以下代码显示了如何使用 <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Optional</span><span class="token punctuation">.</span>isPresent</span></span><span class="token punctuation">}</span>:
 * <span class="token punctuation">{</span><span class="token keyword">@snippet</span> file="ShowOptional.java" region="example"<span class="token punctuation">}</span>
 */</span>
</code></pre></div><p>其中<code>ShowOptional.java</code>是一个包含以下内容的文件：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShowOptional</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// @start region="example"</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v: "</span> <span class="token operator">+</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// @end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java19 新特性总结</title>
      <link>https://www.geekyspace.cn/md/java/features/Java19/java19-new-features-summary.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java19/java19-new-features-summary.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java19 新特性总结</source>
      <description>Java 19 新特性总结 该版本推出的均为孵化与预览功能，所以这里不做单独的详细解读，大部分内容均放在Java 21中介绍。 422: Linux/RISC-V Port：RISC-V是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）,这个JEP的主旨则是移植JDK到RISC-V上。 以下预览特性在Java 21中正式定稿： 405: R...</description>
      <category>Java Features</category>
      <pubDate>Thu, 04 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>该版本推出的均为孵化与预览功能，所以这里不做单独的详细解读，大部分内容均放在Java 21中介绍。</p>
<ul>
<li>422: Linux/RISC-V Port：RISC-V是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）,这个JEP的主旨则是移植JDK到RISC-V上。</li>
</ul>
<p>以下预览特性在Java 21中正式定稿：</p>
<ul>
<li><a href="/java-features/Java21/jep440-record-partterns">405: Record Patterns (Preview)：终稿见 440: Record Patterns</a></li>
<li><a href="/java-features/Java21/jep444-virtual-threads">425: Virtual Threads (Preview)：终稿见 444: Virtual Threads</a></li>
<li><a href="/java-features/Java21/jep441-pattern-matching-for-switch">427: Pattern Matching for switch (Third Preview)：终稿见 441: Pattern Matching for switch</a></li>
</ul>
<p>以下内容在Java 21中继续迭代：</p>
<ul>
<li>424: Foreign Function &amp; Memory API (Preview)</li>
<li>426: Vector API (Fourth Incubator)</li>
<li>428: Structured Concurrency (Incubator)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java20 新特性总结</title>
      <link>https://www.geekyspace.cn/md/java/features/Java20/java20-new-features-summary.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java20/java20-new-features-summary.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java20 新特性总结</source>
      <description>Java 20 新特性总结 该版本推出的均为孵化与预览功能，所以这里不做单独的详细解读，大部分内容均放在Java 21中介绍。 以下内容在Java 21中正式定稿，可根据链接查看终稿内容： 432: Record Patterns (Second Preview)：终稿见440: Record Patterns 433: Pattern Matchin...</description>
      <category>Java Features</category>
      <pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>该版本推出的均为孵化与预览功能，所以这里不做单独的详细解读，大部分内容均放在Java 21中介绍。</p>
<p>以下内容在Java 21中正式定稿，可根据链接查看终稿内容：</p>
<ul>
<li><a href="/java-features/Java21/jep440-record-partterns">432: Record Patterns (Second Preview)：终稿见440: Record Patterns</a></li>
<li><a href="/java-features/Java21/jep441-pattern-matching-for-switch">433: Pattern Matching for switch (Fourth Preview)：终稿见441: Pattern Matching for switch</a></li>
<li><a href="/java-features/Java21/jep444-virtual-threads">436: Virtual Threads (Second Preview)：终稿见444: Virtual Threads</a></li>
</ul>
<p>以下内容在Java 21中继续迭代：</p>
<ul>
<li>429: Scoped Values (Incubator)</li>
<li>434: Foreign Function &amp; Memory API (Second Preview)</li>
<li>437: Structured Concurrency (Second Incubator)</li>
<li>438: Vector API (Fifth Incubator)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性：字符串模版(Preview)</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep430-string-templates.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep430-string-templates.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：字符串模版(Preview)</source>
      <description>Java 21 新特性：String Templates（字符串模版） Java 21 中引入了字符串模版（String Templates），它是一种新的字符串字面量，用于更简洁地构建字符串。 字符串组合的机制 在之前，Java 提供了几种字符串组合的机制，但不幸的是，它们都存在一些缺点 使用 + 操作符, 代码难以阅读 使用 StringBuild...</description>
      <category>Java Features</category>
      <pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 21 中引入了<strong>字符串模版</strong>（String Templates），它是一种新的字符串字面量，用于更简洁地构建字符串。</p>
<h2>字符串组合的机制</h2>
<p>在之前，Java 提供了几种字符串组合的机制，但不幸的是，它们都存在一些缺点</p>
<ol>
<li>使用 <code>+</code> 操作符, 代码难以阅读<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token string">" plus "</span> <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token string">" equals "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>使用 <code>StringBuilder</code> 和 <code>StringBuffer</code>，代码冗长<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span>（）
                <span class="token punctuation">.</span>append（x）
                <span class="token punctuation">.</span>append（“plus“）
                <span class="token punctuation">.</span>append（y）
                <span class="token punctuation">.</span>append（“equals“）
                <span class="token punctuation">.</span>append（x <span class="token operator">+</span> y）
                <span class="token punctuation">.</span>println（）<span class="token punctuation">;</span>
</code></pre></div></li>
<li>使用 <code>String::format</code> 和 <code>String::formatted</code>，容易出现参数数量和类型不匹配的问题<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%2$d plus %1$d equals %3$d"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> t <span class="token operator">=</span> <span class="token string">"%2$d plus %1$d equals %3$d"</span><span class="token punctuation">.</span><span class="token function">formatted</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>使用 <code>java.text.MessageFormat</code> 格式化消息，语法复杂对一些人来说可能不太熟悉<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">MessageFormat</span> mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span><span class="token string">"{0} plus {1} equals {2}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> mf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
</ol>
<p>下面，我们将学习Java 21中的字符串模版，以及它的使用方法。</p>
<h2>模版表达式（插值）</h2>
<p>在Java 21中处理字符串的新方法称为：<code>Template Expressions</code>，即：<strong>模版表达式</strong>。</p>
<ul>
<li>优点：模版表达式可以执行<strong>字符串插值</strong>，插值不仅比串联更方便，而且在阅读代码时也更清晰</li>
<li>缺点：但插值是危险的，尤其是对于SQL语句，因为它可能导致注入攻击</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Joan"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> info <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"My name is \{name}"</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> info<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"My name is Joan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
</code></pre></div><p>上述代码中的第2行就是一个模版表达式，其中主要包含三个部分：</p>
<ol>
<li>模板处理器<code>STR</code>;</li>
<li>一个<code>.</code>字符，类似于方法调用</li>
<li>包含嵌入表达式（<code>\{name}</code>）的模版</li>
</ol>
<p>运行时，计算模板表达式，模板处理器将模板中的文本与嵌入表达式的值组合在一起，以产生结果。</p>
<h2>STR模版处理器</h2>
<blockquote>
<p>STR模板处理器用于将模板中的每个<mark>嵌入表达式</mark>替换成<mark>表达式的（字符串）值</mark>来执行字符串插值</p>
</blockquote>
<ul>
<li>STR是一个<code>public static final</code>字段，它会自动导入到每个Java源文件中</li>
</ul>
<p>使用STR模板处理器的模板表达式示例。符号 <code>|</code> 后显示前一条语句的值，类似于<code>jshell</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 嵌入式表达式可以是字符串</span>
<span class="token class-name">String</span> firstName <span class="token operator">=</span> <span class="token string">"Bill"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> lastName  <span class="token operator">=</span> <span class="token string">"Duck"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> fullName  <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{firstName} \{lastName}"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"Bill Duck"</span>
<span class="token class-name">String</span> sortName  <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{lastName}, \{firstName}"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"Duck, Bill"</span>

<span class="token comment">// 嵌入式表达式可以执行算术运算</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{x} + \{y} = \{x + y}"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"10 + 20 = 30"</span>

<span class="token comment">// 嵌入式表达式可以调用方法和访问字段</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"You have a \{getOfferType()} waiting for you!"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"You have a gift waiting for you!"</span>
<span class="token class-name">String</span> t <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Access at \{req.date} \{req.time} from \{req.ipAddress}"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"Access at 2022-03-25 15:34 from 8.8.8.8"</span>
</code></pre></div><ul>
<li>
<p>为了帮助重构，嵌入式表达式中可以使用双引号字符，而无需将它们转义为<code>"</code></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> filePath <span class="token operator">=</span> <span class="token string">"tmp.dat"</span><span class="token punctuation">;</span>
<span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> old <span class="token operator">=</span> <span class="token string">"The file "</span> <span class="token operator">+</span> filePath <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"does"</span> <span class="token operator">:</span> <span class="token string">"does not"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" exist"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"The file \{filePath} \{file.exists() ? "</span>does<span class="token string">" : "</span>does not<span class="token string">"} exist"</span><span class="token punctuation">;</span>
<span class="token operator">|</span> <span class="token string">"The file tmp.dat does exist"</span> 或 <span class="token string">"The file tmp.dat does not exist"</span>
</code></pre></div></li>
<li>
<p>为了提高可读性，在源文件中，嵌入式表达式可以跨越多行而不会引入新的换行符</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> time <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span>"<span class="token class-name">The</span> time is \<span class="token punctuation">{</span>
    <span class="token comment">// java.time.format包非常有用</span>
    <span class="token class-name">DateTimeFormatter</span>
      <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> right now"<span class="token punctuation">;</span>
<span class="token comment">// "The time is 12:34:56 right now"</span>
</code></pre></div></li>
<li>
<p>字符串模板表达式中嵌入表达式的数量没有限制</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 嵌入式表达式可以是后缀递增表达式</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> data <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{index++}, \{index++}, \{index++}, \{index++}"</span><span class="token punctuation">;</span>
<span class="token comment">// "0, 1, 2, 3"</span>
</code></pre></div></li>
<li>
<p>任何Java表达式都可以用作嵌入式表达式，甚至是模板表达式。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 嵌入式表达式是（嵌套的）模板表达式</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fruit <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"apples"</span><span class="token punctuation">,</span> <span class="token string">"oranges"</span><span class="token punctuation">,</span> <span class="token string">"peaches"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{fruit[0]}, \{STR."</span>\<span class="token punctuation">{</span>fruit<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \<span class="token punctuation">{</span>fruit<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token string">"}"</span><span class="token punctuation">;</span>
<span class="token comment">// "apples, oranges, peaches"</span>
</code></pre></div></li>
<li>
<p>在这里，模板表达式 <code>STR."\{fruit[1]}, \{fruit[2]}"</code> 嵌入到另一个模板表达式的模板中。
由于存在大量的 <code>"</code> <code>,</code> <code>\</code> 和 <code>{ }</code> 字符，这段代码很难阅读，因此最好将其格式化为：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span>"\<span class="token punctuation">{</span>fruit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \<span class="token punctuation">{</span>
    <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{fruit[1]}, \{fruit[2]}"</span>
<span class="token punctuation">}</span>"<span class="token punctuation">;</span>
</code></pre></div></li>
</ul>
<h2>多行模板表达式</h2>
<p>模板表达式的模板可以跨越多行源代码，类似于Java 15中的<a href="/java-features/Java15/jep378-text-blocks">文本块</a>的语法。
开发者可以用它来方便的组织<code>html</code>、<code>json</code>、<code>xml</code>等字符串内容，比如下面这样：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 多行模板表达式示例：HTML文档</span>
<span class="token class-name">String</span> title <span class="token operator">=</span> <span class="token string">"My Web Page"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> text  <span class="token operator">=</span> <span class="token string">"Hello, world"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> html <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token triple-quoted-string string">"""
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;\{title}&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;\{text}&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
        """</span><span class="token punctuation">;</span>
<span class="token operator">|</span> 输出结果：
<span class="token operator">|</span> <span class="token triple-quoted-string string">"""
| &lt;html&gt;
|   &lt;head&gt;
|     &lt;title&gt;My Web Page&lt;/title&gt;
|   &lt;/head&gt;
|   &lt;body&gt;
|     &lt;p&gt;Hello, world&lt;/p&gt;
|   &lt;/body&gt;
| &lt;/html&gt;
| """</span>

<span class="token comment">// 多行模板表达式示例：JSON文档</span>
<span class="token class-name">String</span> name    <span class="token operator">=</span> <span class="token string">"Joan Smith"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> phone   <span class="token operator">=</span> <span class="token string">"555-123-4567"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> address <span class="token operator">=</span> <span class="token string">"1 Maple Drive, Anytown"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> json <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token triple-quoted-string string">"""
    {
        "name":    "\{name}",
        "phone":   "\{phone}",
        "address": "\{address}"
    }
    """</span><span class="token punctuation">;</span>
<span class="token operator">|</span> 输出结果：
<span class="token operator">|</span> <span class="token triple-quoted-string string">"""
| {
|     "name":    "Joan Smith",
|     "phone":   "555-123-4567",
|     "address": "1 Maple Drive, Anytown"
| }
| """</span>

<span class="token keyword">record</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> width<span class="token punctuation">,</span> <span class="token keyword">double</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Rectangle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> zone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Alfa"</span><span class="token punctuation">,</span> <span class="token number">17.8</span><span class="token punctuation">,</span> <span class="token number">31.4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Bravo"</span><span class="token punctuation">,</span> <span class="token number">9.6</span><span class="token punctuation">,</span> <span class="token number">12.4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Charlie"</span><span class="token punctuation">,</span> <span class="token number">7.1</span><span class="token punctuation">,</span> <span class="token number">11.23</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 多行模板表达式示例：表格</span>
<span class="token class-name">String</span> table <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token triple-quoted-string string">"""
    Description  Width  Height  Area
    \{zone[0].name}  \{zone[0].width}  \{zone[0].height}     \{zone[0].area()}
    \{zone[1].name}  \{zone[1].width}  \{zone[1].height}     \{zone[1].area()}
    \{zone[2].name}  \{zone[2].width}  \{zone[2].height}     \{zone[2].area()}
    Total \{zone[0].area() + zone[1].area() + zone[2].area()}
    """</span><span class="token punctuation">;</span>
<span class="token operator">|</span> 输出结果：
<span class="token operator">|</span> <span class="token triple-quoted-string string">"""
| Description  Width  Height  Area
| Alfa  17.8  31.4     558.92
| Bravo  9.6  12.4     119.03999999999999
| Charlie  7.1  11.23     79.733
| Total 757.693
| """</span>
</code></pre></div><h2>FMT模板处理器</h2>
<p>除了STR模版处理器之外，Java中还提供了另外一个模版处理器：FMT。
FMT与STR相似之处在于它执行插值，但还提供了<mark>格式化处理</mark>能力。</p>
<ul>
<li>格式说明符与<code>java.util.Formatter</code>中定义的格式说明符相同</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> width<span class="token punctuation">,</span> <span class="token keyword">double</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Rectangle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> zone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Alfa"</span><span class="token punctuation">,</span> <span class="token number">17.8</span><span class="token punctuation">,</span> <span class="token number">31.4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Bravo"</span><span class="token punctuation">,</span> <span class="token number">9.6</span><span class="token punctuation">,</span> <span class="token number">12.4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token string">"Charlie"</span><span class="token punctuation">,</span> <span class="token number">7.1</span><span class="token punctuation">,</span> <span class="token number">11.23</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 多行模板表达式示例：表格</span>
<span class="token class-name">String</span> table <span class="token operator">=</span> <span class="token constant">FMT</span><span class="token punctuation">.</span><span class="token triple-quoted-string string">"""
    Description     Width    Height     Area
    %-12s\{zone[0].name}  %7.2f\{zone[0].width}  %7.2f\{zone[0].height}     %7.2f\{zone[0].area()}
    %-12s\{zone[1].name}  %7.2f\{zone[1].width}  %7.2f\{zone[1].height}     %7.2f\{zone[1].area()}
    %-12s\{zone[2].name}  %7.2f\{zone[2].width}  %7.2f\{zone[2].height}     %7.2f\{zone[2].area()}
    \{" ".repeat(28)} Total %7.2f\{zone[0].area() + zone[1].area() + zone[2].area()}
    """</span><span class="token punctuation">;</span>
<span class="token operator">|</span> 输出结果：
<span class="token operator">|</span> <span class="token triple-quoted-string string">"""
| Description     Width    Height     Area
| Alfa            17.80    31.40      558.92
| Bravo            9.60    12.40      119.04
| Charlie          7.10    11.23       79.73
|                              Total  757.69
| """</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性：有序集合</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep431-sequenced-collections.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep431-sequenced-collections.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：有序集合</source>
      <description>Java 21 新特性：有序集合（Sequenced Collections） 在JDK 21中，有序集合（Sequenced Collections）引入了新的接口和方法来简化集合处理。 此增强功能旨在解决访问Java中各种集合类型的第一个和最后一个元素需要非统一且麻烦处理场景 Sequenced Collections 引入如下 3 个新接口，用于...</description>
      <category>Java Features</category>
      <pubDate>Sun, 07 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>在JDK 21中，<strong>有序集合</strong>（Sequenced Collections）引入了新的接口和方法来简化集合处理。</p>
<blockquote>
<p>此增强功能旨在解决访问Java中各种集合类型的第一个和最后一个元素需要非统一且麻烦处理场景</p>
</blockquote>
<p><code>Sequenced Collections</code> 引入如下 3 个新接口，用于处理顺序<code>List</code>、<code>Set</code>和<code>Map</code>，
并将它们整合到现有的集合类型中。这些新接口中的方法都具有默认实现。</p>
<ol>
<li>SequencedCollection</li>
<li>SequencedSet</li>
<li>SequencedMap</li>
</ol>
<h2>SequencedCollection</h2>
<p>提供了在集合两端添加、检索和移除元素的方法，沿着<code>reversed()</code>方法提供了该集合的逆序视图。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 新方法：返回反转后的序列化集合</span>
    <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 以下方法是从Deque提升的,支持在两端添加、获取和删除元素</span>
    <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul>
<li>新的<code>reversed()</code>方法提供了原始集合的反向视图，对原始集合的任何修改都可以在视图中看到</li>
<li>如果允许，对视图的修改将写入原始集合</li>
<li>逆序视图使得不同的序列类型可以在两个方向上处理元素
<ul>
<li>如：增强for循环、显式iterator()循环、forEach()、stream()、parallelStream() 和 toArray()</li>
</ul>
</li>
</ul>
<p>例如，从<code>LinkedHashSet</code>获得逆序流以前很难，现在很简单</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>linkedHashSet<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 获取逆序流非常困难</span>
linkedHashSet<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 现在：直接使用 reversed() 方法获取逆序流</span>
</code></pre></div><blockquote>
<p><code>reversed()</code> 方法本质上是 <code>NavigableSet::descendingSet</code>的重命名，并升级为 SequencedCollection</p>
</blockquote>
<h2>SequencedSet</h2>
<p>sequenced set 是一个不包含重复元素的 SequencedCollection，区别是<code>SequencedSet.reversed()</code>的返回类型是SequencedSet。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 重写父接口的 reversed() 方法</span>
    <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>SortedSet</strong></p>
<ul>
<li>Java集合框架中<code>SortedSet</code>接口，表示一个有序集合</li>
<li>不能支持显式定位操作，因为是基于元素之间的相对比较来确定它们位置的，而不是基于顺序插入</li>
<li>如果尝试使用<code>addFirst(E)</code>或<code>addLast(E)</code>方法，会抛出<code>UnsupportedOperationException</code>异常</li>
</ul>
<p><strong>SequencedSet</strong></p>
<ul>
<li><code>SequencedSet</code>接口扩展了<code>SortedSet</code></li>
<li>其中<code>addFirst(E)</code>和<code>addLast(E)</code> 方法对于集合（如<code>LinkedHashSet</code>）具有特殊情况语义：
<ul>
<li>如果元素已经存在于集合中，则将其移动到适当的位置</li>
<li>这弥补了LinkedHashSet中的一个长期缺陷，即无法重新定位元素</li>
</ul>
</li>
</ul>
<h2>SequencedMap</h2>
<p>sequenced map 是一个映射，其键具有已定义的顺序，
它不实现SequencedCollection，而是提供了自己的方法，这些方法将访问顺序应用于映射条目，而不是单个元素。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 新方法</span>
    <span class="token class-name">SequencedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 返回一个反转的映射</span>
    <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 返回键的序列化集合</span>
    <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回值的序列化集合</span>
    <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedEntrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回条目的序列化集合</span>
    <span class="token class-name">V</span> <span class="token function">putFirst</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 将键值对放在映射的第一个位置</span>
    <span class="token class-name">V</span> <span class="token function">putLast</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 将键值对放在映射的最后一个位置</span>
    <span class="token comment">// 从 NavigableMap 提升的方法，支持在映射的两端获取和移除条目</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">firstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 返回映射的第一个条目</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">lastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 返回映射的最后一个条目</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">pollFirstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 移除并返回映射的第一个条目</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">pollLastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 移除并返回映射的最后一个条目</span>
<span class="token punctuation">}</span>
</code></pre></div><p>新的<code>put*(K, V)</code>方法具有特殊的含义，类似于 SequencedSet 中对应的<code>add*(E)</code>方法：</p>
<ul>
<li>对于 LinkedHashMap 映射，如果已存在相同键的条目，该方法将重新定位该条目</li>
<li>对于 SortedMap 映射，这些方法会抛出 <code>UnsupportedOperationException</code> 异常</li>
</ul>
<h2>改造</h2>
<p>上述定义的三个新接口完美地适应了现有的集合类型层次结构（点击放大）：</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/SequencedCollectionDiagram20220216.png" alt="Sequenced-Collections" tabindex="0" loading="lazy"><figcaption>Sequenced-Collections</figcaption></figure>
<p>具体而言，我们对现有的类和接口进行以下调整：</p>
<ul>
<li>List 现在将 SequencedCollection 定义为其直接超级接口</li>
<li>Deque 现在将 SequencedCollection 定义为其直接超级接口</li>
<li>LinkedHashSet 另外实现了 SequencedSet</li>
<li>SortedSet 现在将 SequencedSet 定义为其直接超级接口</li>
<li>LinkedHashMap 另外实现了 SequencedMap</li>
<li>SortedMap 现在将 SequencedMap 定义为其直接超级接口</li>
</ul>
<p>我们在适当的位置为<code>reversed()</code>方法定义协变覆盖。
例如: <code>List::reversed</code> 被覆盖为返回 List 类型的值，而不是 <code>SequencedCollection</code> 类型的值。</p>
<p>我们还向 Collections 实用类添加了新方法，用于创建三种新类型的不可修改包装：</p>
<ul>
<li>Collections.unmodifiableSequencedCollection(sequencedCollection)</li>
<li>Collections.unmodifiableSequencedSet(sequencedSet)</li>
<li>Collections.unmodifiableSequencedMap(sequencedMap)</li>
</ul>
<h2>第一个和最后一个元素的访问</h2>
<p>引入顺序接口的动机是对获取集合的第一个和最后一个元素的简单方法的长期未决需求。</p>
<p>目前，在Java 21之前，JDK API调用访问第一个和最后一个元素的一些示例：</p>
<p>| 访问位置   | List                    | Deque            | SortedSet   |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/SequencedCollectionDiagram20220216.png" type="image/png"/>
    </item>
    <item>
      <title>Java 21 新特性：分代ZGC</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep439-generational-zgc.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep439-generational-zgc.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：分代ZGC</source>
      <description>Java 21 新特性：分代ZGC（Generational ZGC） Java以其垃圾回收机制而闻名。这是它的主要优势之一，但也可能是许多头疼的根源。 Java 11（JEP 333）中引入了一个可扩展的低延迟垃圾收集器，称为ZGC Java 15（JEP 377）中 ZGC 可用于生产 现在，随着Java 21的出现，它已经发展成为一种分代GC（J...</description>
      <category>Java Features</category>
      <pubDate>Mon, 08 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java以其垃圾回收机制而闻名。这是它的主要优势之一，但也可能是许多头疼的根源。</p>
<ul>
<li>Java 11（<a href="https://openjdk.org/jeps/333" target="_blank" rel="noopener noreferrer">JEP 333</a>）中引入了一个可扩展的低延迟垃圾收集器，称为ZGC</li>
<li>Java 15（<a href="https://openjdk.org/jeps/377" target="_blank" rel="noopener noreferrer">JEP 377</a>）中 ZGC 可用于生产</li>
<li>现在，随着Java 21的出现，它已经发展成为一种分代GC（<a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener noreferrer">JEP 439</a>）</li>
</ul>
<h2>垃圾收集（Garbage Collection）</h2>
<p>在Java中，垃圾收集器负责释放堆内存，堆内存是存储Java对象的地方。
这有助于防止内存泄漏并确保有效的资源使用，否则，程序会抛出<code>OutOfMemoryError</code>异常。</p>
<p>“<a href="https://wiki.c2.com/?GarbageCollection" target="_blank" rel="noopener noreferrer">垃圾收集</a>”的概念本质上是<strong>自动内存管理</strong>， 这可能导致如下潜在的错误：</p>
<ol>
<li>需要时间来清理和重新排列内存，引入了运行时开销，超出了程序员的控制。</li>
<li>GC运行的实际点通常是不确定的，对于高吞吐量内存消耗大的应用，可能会长时间的“<strong>GC暂停</strong>”</li>
<li>讽刺的是，GC的非确定性也是它的优点之一，我们不必担心内存是何时或如何释放的，它将自动发生</li>
</ol>
<p>有三种主要的自动内存管理技术：</p>
<ol>
<li>引用计数（<a href="https://wiki.c2.com/?ReferenceCounting" target="_blank" rel="noopener noreferrer">ReferenceCounting</a>）</li>
<li>标记和清除（<a href="https://wiki.c2.com/?MarkAndSweep" target="_blank" rel="noopener noreferrer">MarkAndSweep</a>）</li>
<li>复制（<a href="https://wiki.c2.com/?StopAndCopy" target="_blank" rel="noopener noreferrer">StopAndCopy</a>）</li>
</ol>
<h2>不同语言如何管理内存</h2>
<ul>
<li><strong>C/C++</strong>：手动管理内存，程序员负责分配和释放内存</li>
<li><strong>Objective-C 和 Swift</strong>：引入了自动引用计数（ARC），但仍然需要手动释放内存</li>
<li><strong>Rust</strong>：使用<a href="https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems" target="_blank" rel="noopener noreferrer">仿射类型系统</a>
而不是GC，引入了所有权和借用，编译器在编译时检查内存安全性</li>
<li><strong>Kotlin</strong>：与Java类似，但引入了<code>Kotlin/Native</code>，允许手动内存管理</li>
<li><strong>Java、<a href="https://devguide.python.org/internals/garbage-collector/" target="_blank" rel="noopener noreferrer">Python</a>
、Go、<a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals" target="_blank" rel="noopener noreferrer">C#</a>
、JavaScript</strong>：自动内存管理，垃圾收集器负责释放内存</li>
</ul>
<h2>HotSpot JVM垃圾收集器</h2>
<p>内存管理有许多不同的方法，并且没有“最好”的方法。
即使在一种语言/运行时中，也可以有不止一种垃圾收集方法，JVM就是一个很好的例子。</p>
<p>与单一的GC不同，<a href="https://docs.oracle.com/en/java/javase/11/gctuning/available-collectors.html" target="_blank" rel="noopener noreferrer">HotSpot JVM</a>有5个GC可供选择：</p>
<ul>
<li>Garbage-First Collector(G1)（Java 9后的默认选项）</li>
<li>Serial Collector</li>
<li>Parallel Collector</li>
<li><s>Concurrent Mark Sweep (CMS) Collector（Java 9中已弃用）</s></li>
<li>Shenandoah GC（Java 12+）</li>
<li>Z Garbage Collector（Java 15中可用于生产）</li>
</ul>
<p>此外，不要忘记还有其他的JDK实现！</p>
<ul>
<li><a href="https://eclipse.dev/openj9/" target="_blank" rel="noopener noreferrer">Eclipse OpenJ9</a> 使用具有多个收集策略的分代并发GC</li>
<li><a href="https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/" target="_blank" rel="noopener noreferrer">GraalVM</a>
有 Epsilon GC，它是一个 No-Op GC，完全不进行内存清理</li>
</ul>
<h2>如何选择JVM GC</h2>
<p>许多语言只提供了一种垃圾收集方法，而Java之所以提供多种GC选项，取决于您的应用程序对于“全局停顿”事件和总体暂停时间的容忍程度。</p>
<p>GC算法主要关注三个指标：</p>
<ol>
<li><strong>吞吐量</strong>：应用程序的运行时间与GC时间的比率</li>
<li><strong>延迟</strong>：GC暂停时间</li>
<li><strong>内存占用</strong>：GC对堆内存的使用</li>
</ol>
<p>与许多问题一样，您无法为所有这些问题进行优化，因此每个GC都需要在它们之间找到平衡点。以下是一些场景及其匹配的GC作为起点：</p>
<p>| 垃圾收集器       | 场景                                             |
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性：记录模式</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep440-record-partterns.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep440-record-partterns.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：记录模式</source>
      <description>Java 21 新特性：记录模式（Record Patterns） Java 21 中的记录模式（Record Patterns）是对模式匹配的扩展，它允许在模式匹配中使用记录（Records）类型。 同时，记录模式还支持嵌套，可以实现更复杂的数据查询和处理。 仅仅是类型匹配 到目前为止，Java中的模式匹配主要局限于匹配类型：instanceof类型...</description>
      <category>Java Features</category>
      <pubDate>Tue, 09 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 21 中的<strong>记录模式</strong>（Record Patterns）是对模式匹配的扩展，它允许在模式匹配中使用<strong>记录</strong>（Records）类型。
同时，记录模式还支持嵌套，可以实现更复杂的数据查询和处理。</p>
<h2>仅仅是类型匹配</h2>
<p>到目前为止，Java中的模式匹配主要局限于匹配类型：<a href="/java-features/Java16/jep394-pattern-matching-for-instanceof">instanceof类型匹配</a></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Java 16 之前</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// JAVA 16+</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Java
21扩展了这个概念，使其可用于switch语句和表达式: <a href="/java-features/Java21/jep441-pattern-matching-for-switch">switch的模式匹配</a></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// JAVA 21之前</span>
<span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">asStringValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>anyValue <span class="token keyword">instanceof</span> <span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> str<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>anyValue <span class="token keyword">instanceof</span> <span class="token class-name">BigDecimal</span> bd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">toEngineeringString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>anyValue instance <span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> <span class="token string">"n/a"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// JAVA 21+</span>
<span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">asStringValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">String</span> str    <span class="token operator">-&gt;</span> str<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">BigDecimal</span> bd <span class="token operator">-&gt;</span> bd<span class="token punctuation">.</span><span class="token function">toEngineeringString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">Integer</span> i     <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span>            <span class="token operator">-&gt;</span> <span class="token string">"n/a"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>代码比之前更加简洁，同时也更加易读。但是，这种模式匹配仍然局限于类型匹配。</p>
<h2>record模式</h2>
<p>当我们将模式匹配与记录类型结合使用时，我们称之为<strong>记录模式</strong>。这意味着我们可以在模式匹配中使用记录类型，以及记录类型的属性。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// Java 16 之前</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printSum</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// JAVA 21+</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printSum</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中<code>Point(int x, int y)</code>就是记录模式，它匹配<code>Point</code>类型的对象，将记录的实例（obj）分解到它的组件（<code>x</code>和<code>y</code>）。</p>
<h2>嵌套record的解构</h2>
<p>假设我们设计了一个记录，表示一个矩形，其中包含左上角和右下角的颜色点。
如果我们想要获取左上角点的颜色，我们可以这样写：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> <span class="token constant">RED</span><span class="token punctuation">,</span> <span class="token constant">GREEN</span><span class="token punctuation">,</span> <span class="token constant">BLUE</span> <span class="token punctuation">}</span>
<span class="token keyword">record</span> <span class="token class-name">ColoredPoint</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p<span class="token punctuation">,</span> <span class="token class-name">Color</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">record</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token class-name">ColoredPoint</span> upperLeft<span class="token punctuation">,</span> <span class="token class-name">ColoredPoint</span> lowerRight<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Rectangle</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ColoredPoint</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span><span class="token punctuation">,</span> 
                            <span class="token keyword">new</span> <span class="token class-name">ColoredPoint</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Java 16 之前</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printUpperLeftColoredPoint</span><span class="token punctuation">(</span><span class="token class-name">Rectangle</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token keyword">instanceof</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token class-name">ColoredPoint</span> ul<span class="token punctuation">,</span> <span class="token class-name">ColoredPoint</span> lr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ul<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// JAVA 21+</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printUpperLeftColoredPoint</span><span class="token punctuation">(</span><span class="token class-name">Rectangle</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token keyword">instanceof</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token class-name">ColoredPoint</span><span class="token punctuation">(</span><span class="token class-name">Point</span> ul<span class="token punctuation">,</span> <span class="token class-name">Color</span> c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ColoredPoint</span> lr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>嵌套模式允许我们使用与将其组合的代码一样清晰简洁的代码来拆解聚合。</p>
<h2>发展脉络</h2>
<p>该功能最初作为预览功能在Java 19（JEP 405）中首次亮相，随后经过Java 20（JEP 432）的迭代，最终在Java 21中定稿（JEP 440）。
此功能与模式匹配的switch语句（JEP 441）共同演进，并且它们之间存在相当大的互动。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性：switch模式匹配</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep441-pattern-matching-for-switch.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep441-pattern-matching-for-switch.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：switch模式匹配</source>
      <description>Java 21 新特性：switch模式匹配 Java 21 引入了 switch 模式匹配功能，它增强了 switch 语句的功能，允许使用更简洁的语法来执行类型检查和数据提取。 该功能与记录模式（JEP 440）共同发展，并与之有相当大的互动。 switch + instanceof 与if条件中的instanceof一样，switch case现...</description>
      <category>Java Features</category>
      <pubDate>Wed, 10 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 21 引入了 switch 模式匹配功能，它增强了 switch 语句的功能，允许使用更简洁的语法来执行类型检查和数据提取。
该功能与<a href="/java-features/Java21/jep440-record-partterns">记录模式（JEP 440）</a>共同发展，并与之有相当大的互动。</p>
<h2>switch + instanceof</h2>
<p>与if条件中的<code>instanceof</code>一样，<code>switch case</code>现在可以对其值进行类型检查，并创建一个case作用域变量:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">asStringValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> str      <span class="token operator">-&gt;</span> str<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">JSONObject</span> json <span class="token operator">-&gt;</span> json<span class="token punctuation">.</span><span class="token function">toCompactString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">BigDecimal</span> bd   <span class="token operator">-&gt;</span> bd<span class="token punctuation">.</span><span class="token function">toEngineeringString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Integer</span> i       <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">LocalDate</span> ld    <span class="token operator">-&gt;</span> ld<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">ISO_LOCAL_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span>              <span class="token operator">-&gt;</span> <span class="token string">"n/a"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>switch + null</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">asStringValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>anyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token keyword">null</span>       <span class="token operator">-&gt;</span> <span class="token string">"n/a"</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> str <span class="token operator">-&gt;</span> str<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>switch + enum</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">sealed</span> <span class="token keyword">interface</span> <span class="token class-name">CardClassification</span> <span class="token keyword">permits</span> <span class="token class-name">Suit</span><span class="token punctuation">,</span> <span class="token class-name">Tarot</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Suit</span> <span class="token keyword">implements</span> <span class="token class-name">CardClassification</span> <span class="token punctuation">{</span> <span class="token constant">CLUBS</span><span class="token punctuation">,</span> <span class="token constant">DIAMONDS</span><span class="token punctuation">,</span> <span class="token constant">HEARTS</span><span class="token punctuation">,</span> <span class="token constant">SPADES</span> <span class="token punctuation">}</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Tarot</span> <span class="token keyword">implements</span> <span class="token class-name">CardClassification</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exhaustiveSwitchWithBetterEnumSupport</span><span class="token punctuation">(</span><span class="token class-name">CardClassification</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token constant">CLUBS</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"梅花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">DIAMONDS</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">HEARTS</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"红桃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">SPADES</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黑桃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Tarot</span> t <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"塔罗牌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未知的卡片类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性：虚拟线程</title>
      <link>https://www.geekyspace.cn/md/java/features/Java21/jep444-virtual-threads.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java21/jep444-virtual-threads.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 21 新特性：虚拟线程</source>
      <description>Java 21 新特性：虚拟线程（Virtual Threads） Java 21 引入了虚拟线程（Virtual Threads）功能，类似于Go语言中的Goroutines。 虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。 Java平台目前为止有两种类型的线程：传统线程，也称为平台线程，和虚拟线程。...</description>
      <category>Java Features</category>
      <pubDate>Thu, 11 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 21 引入了<strong>虚拟线程</strong>（Virtual Threads）功能，类似于Go语言中的<code>Goroutines</code>。
虚拟线程是一种轻量级的线程，它可以极大地减少了编写、维护和管理高吞吐量并发应用程序所需的工作量。</p>
<p>Java平台目前为止有两种类型的线程：<strong>传统线程</strong>，也称为<mark>平台线程</mark>，和<strong>虚拟线程</strong>。</p>
<h2>平台线程</h2>
<p>在引入虚拟线程之前，我们所使用的线程<code>java.lang.Thread</code>是由所谓的平台线程支持的。</p>
<p>这些线程通常是 1:1 映射到操作系统线程的，因此它们是重量级的，创建和销毁线程的开销很大。
且每个请求都需要一个独立的线程，这会导致线程资源的快速耗尽，从而限制了应用程序的可伸缩性。</p>
<h3>创建平台线程</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 由平台线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>随着<a href="https://openjdk.org/projects/loom/" target="_blank" rel="noopener noreferrer">Project Loom</a>简化了新的并发方法，它还提供了一种新的方法来创建平台支持的线程：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofPlatform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      
<span class="token comment">// 或者</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofPlatform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                      <span class="token punctuation">.</span><span class="token function">daemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"platform-thread"</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">unstarted</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>虚拟线程</h2>
<p>虚拟线程是JDK提供的<strong>轻量级线程</strong>实现，可以在同一个OS线程上运行许多虚拟线程。
虚拟线程为平台线程提供了一种更有效的替代方案，允许开发人员以显著降低的开销处理大量任务。
这些线程提供了与现有Java代码的兼容性和无缝迁移路径，从而从增强的性能和资源利用率中获益。</p>
<p>许多语言中都有某种形式的轻量级线程：</p>
<ul>
<li>Go语言的<a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener noreferrer">Goroutines</a></li>
<li>Erlang的<a href="https://www.erlang.org/docs/23/efficiency_guide/processes.html" target="_blank" rel="noopener noreferrer">Erlang Processes</a></li>
<li>Haskell的<a href="https://wiki.haskell.org/Lightweight_concurrency" target="_blank" rel="noopener noreferrer">Haskell Threads</a></li>
<li>等等</li>
</ul>
<h3>创建虚拟线程</h3>
<ol>
<li>使用<code>Thread.startVirtualThread()</code>方法创建虚拟线程：</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 使用静态构建器方法</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">startVirtualThread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 由虚拟线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也可以使用<code>Thread.ofVirtual()</code>来创建，这里还可以设置一些属性，比如：线程名称等。具体如下代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Thread</span> virtualThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"virtual-thread"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2">
<li>使用<code>ExecutorService</code>创建虚拟线程：</li>
</ol>
<p>从Java 5开始，就推荐开发人员使用<code>ExecutorServices</code>而不是直接使用<code>Thread</code>类了。
现在，Java 21中引入了使用虚拟线程，所以也有了新的ExecutorService来适配，看看下面的例子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10_000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span class="token comment">// executor.close() 被隐式调用, 然后 waits</span>
</code></pre></div><p>3.使用<code>ThreadFactory</code>创建虚拟线程：</p>
<p>开发者还可以创建一个生成虚拟线程的工厂来管理，具体看下面的例子例子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ThreadFactory</span> virtualThreadFactory <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"virtual-thread"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Thread</span> factoryThread <span class="token operator">=</span> virtualThreadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 由虚拟线程执行的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
factoryThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码创建了一个虚拟线程工厂，每个虚拟线程都会以<code>virtual-thread</code>为前缀、以数字结尾（从0开始累加）的名称。</p>
<h2>虚拟线程如何工作</h2>
<p>虚拟线程是一个新的轻量级<code>java.lang.Thread</code>变体，由JVM的<a href="https://openjdk.org/projects/loom/" target="_blank" rel="noopener noreferrer">Project Loom</a>项目实现的。
它使用了一种称为<code>Continuation</code>的技术，不受操作系统的管理或调度。相反，JVM负责调度。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403141847457.jpg" alt="Java中虚拟线程的结构" tabindex="0" loading="lazy"><figcaption>Java中虚拟线程的结构</figcaption></figure>
<p>应用程序实例化虚拟线程，而 JVM 分配计算资源来处理它们。
与传统线程相对比，传统线程直接映射到操作系统（OS）进程。
传统线程中，应用程序代码负责提供和释放 OS 资源。
而虚拟线程中，应用程序实例化虚拟线程，从而表达并发需求。
但实际上是 JVM 从操作系统获取并释放资源。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403141846557.webp" alt="JVM/OS线程管理" tabindex="0" loading="lazy"><figcaption>JVM/OS线程管理</figcaption></figure>
<p>所需的平台线程在 FIFO 工作窃取
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html" target="_blank" rel="noopener noreferrer">ForkJoinPool</a>
中进行管理，默认情况下使用所有可用处理器，
但可以通过调整系统属性 <code>jdk.virtualThreadScheduler.parallelism</code> 来根据您的需求进行修改。
您熟悉的 <code>ForkJoinPool</code> 和其他功能（如并行流）使用的公共池的主要区别在于，公共池以 LIFO 模式运行。</p>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202403141847457.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Java 9 新特性：交互式编程环境JShell</title>
      <link>https://www.geekyspace.cn/md/java/features/Java9/jep222-jshell.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java9/jep222-jshell.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 9 新特性：交互式编程环境JShell</source>
      <description>Java 9 新特性：交互式编程环境JShell JShell 是 Java 9 引入的一个交互式编程环境，它是 Java 编程语言的 REPL（Read-Eval-Print Loop）实现。 REPL 是一种编程环境，允许用户输入表达式并立即看到结果，而无需事先编写和编译完整的程序。 JShell 的目标是提供一个轻量级、灵活且易于使用的工具，使得...</description>
      <category>Java Features</category>
      <pubDate>Thu, 21 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>JShell 是 Java 9 引入的一个<strong>交互式编程环境</strong>，它是 Java 编程语言的 REPL（Read-Eval-Print Loop）实现。
REPL 是一种编程环境，允许用户输入表达式并立即看到结果，而无需事先编写和编译完整的程序。
JShell 的目标是提供一个轻量级、灵活且易于使用的工具，使得 Java 开发者能够更直观地编写和测试代码。</p>
<h2>JShell快速入门</h2>
<h3>启动JShell</h3>
<p>打开终端，然后执行命令：<code>jshell</code>，执行效果如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>➜  <span class="token operator">~</span> jshell
<span class="token operator">|</span>  欢迎使用 <span class="token class-name">JShell</span> <span class="token operator">--</span> 版本 <span class="token number">9</span>
<span class="token operator">|</span>  要大致了解该版本<span class="token punctuation">,</span> 请键入<span class="token operator">:</span> <span class="token operator">/</span>help intro

jshell<span class="token operator">&gt;</span>
</code></pre></div><h3>帮助介绍 /help intro</h3>
<p>执行 <code>/help intro</code> 命令以获取有关 JShell 工具的简要介绍，<strong>intro</strong> 是主题，提供了关于 jshell 工具的核心概念和使用方法的信息。</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>jshell&gt; /help intro
|
|                                   intro
|                                   =====
|
|  使用 jshell 工具可以执行 Java 代码，从而立即获取结果。
|  您可以输入 Java 定义（变量、方法、类等等），例如：int x = 8
|  或 Java 表达式，例如：x + x
|  或 Java 语句或导入。
|  这些小块的 Java 代码称为“片段”。
|
|  这些 jshell 工具命令还可以让您了解和
|  控制您正在执行的操作，例如：/list
|
|  有关命令的列表，请执行：/help

jshell&gt;
</code></pre></div><h3>定义变量、方法、类</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 定义变量</span>
jshell<span class="token operator">&gt;</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span>
x <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">8</span>

<span class="token comment">// 定义方法</span>
jshell<span class="token operator">&gt;</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token punctuation">}</span>
<span class="token operator">|</span>  已创建 方法 <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>

<span class="token comment">// 定义类</span>
jshell<span class="token operator">&gt;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token keyword">public</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;         <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;         <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;     <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt; <span class="token punctuation">}</span>
<span class="token operator">|</span>  已创建 类 <span class="token class-name">Message</span>

jshell<span class="token operator">&gt;</span>
</code></pre></div><h3>执行表达式、调用方法</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 执行 Java 表达式</span>
jshell<span class="token operator">&gt;</span> x <span class="token operator">+</span> x
$<span class="token number">4</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">16</span>

<span class="token comment">// 调用方法</span>
jshell<span class="token operator">&gt;</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
$<span class="token number">5</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">25</span>

    
<span class="token comment">// 创建类实例并调用方法</span>
jshell<span class="token operator">&gt;</span> <span class="token class-name">Message</span> messageObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"Hello, JShell!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messageObj <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token class-name">Message</span><span class="token annotation punctuation">@6d4b1c02</span>

jshell<span class="token operator">&gt;</span> messageObj<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

$<span class="token number">7</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token string">"Hello, JShell!"</span>
</code></pre></div><h2>查看定义的变量：/vars</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>vars
<span class="token operator">|</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span>
<span class="token operator">|</span>    <span class="token keyword">int</span> $<span class="token number">4</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token operator">|</span>    <span class="token keyword">int</span> $<span class="token number">5</span> <span class="token operator">=</span> <span class="token number">25</span>
<span class="token operator">|</span>    <span class="token class-name">Message</span> messageObj <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token annotation punctuation">@6d4b1c02</span>
<span class="token operator">|</span>    <span class="token class-name">String</span> $<span class="token number">7</span> <span class="token operator">=</span> <span class="token string">"Hello, JShell!"</span>
</code></pre></div><h2>查看定义的方法：/methods</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>methods
<span class="token operator">|</span>    <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
</code></pre></div><h2>查看定义的类：/types</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>types
<span class="token operator">|</span>    <span class="token keyword">class</span> <span class="token class-name">Message</span>

</code></pre></div><h2>列出输入源条目：/list</h2>
<p>执行后，可以看到之前在<code>jshell</code>中输入的内容清单：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>list

   <span class="token number">1</span> <span class="token operator">:</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
   <span class="token number">2</span> <span class="token operator">:</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token number">3</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span><span class="token punctuation">{</span>
           <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>
           <span class="token keyword">public</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
               <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
               <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token number">4</span> <span class="token operator">:</span> x <span class="token operator">+</span> x
   <span class="token number">5</span> <span class="token operator">:</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
   <span class="token number">6</span> <span class="token operator">:</span> <span class="token class-name">Message</span> messageObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"Hello, JShell!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token number">7</span> <span class="token operator">:</span> messageObj<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

jshell<span class="token operator">&gt;</span>
</code></pre></div><h2>编辑源条目：/edit</h2>
<p>上面通过<code>/list</code>列出了输入的条目信息，下面试试通过<code>/edit</code>编辑下，比如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>edit <span class="token number">2</span>
</code></pre></div><p>这将打开编辑器，修改先前定义的 <code>square</code> 方法。</p>
<p>修改完成后，点击 <strong>accept</strong> 即可</p>
<h2>删除源条目：/drop</h2>
<p>使用 <code>/drop</code> 命令可以删除之前输入的源代码块。可以通过指定<strong>名称</strong>或 <strong>ID</strong> 删除特定的源代码块。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>drop <span class="token class-name">Message</span>
<span class="token operator">|</span>  已删除 类 <span class="token class-name">Message</span>
</code></pre></div><p>这将删除之前定义的 <code>Message</code> 类。</p>
<h2>保存文件：/save</h2>
<p>通过 <code>/save</code> 命令，您可以将 JShell 中的源代码保存到文件中，以便将其保留或与他人共享。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>save myCode<span class="token punctuation">.</span>java
</code></pre></div><p>这将把当前所有的源代码保存到一个名为 <code>myCode.java</code> 的文件中。</p>
<h2>打开文件：/open</h2>
<p>使用 <code>/open</code> 命令可以将文件的内容导入到 JShell 中，以便重新使用或修改。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span><span class="token keyword">open</span> <span class="token namespace">myCode<span class="token punctuation">.</span>java</span>
</code></pre></div><p>这将导入之前保存的 <code>myCode.java</code> 文件中的源代码。</p>
<h2>重置jshell：/reset</h2>
<p>使用 <code>/reset</code> 命令可以清空 JShell 的状态，包括所有定义的变量、方法和类。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>reset
<span class="token operator">|</span>  正在重置状态
</code></pre></div><p>这将重置 JShell 并清除所有之前定义的内容。</p>
<h2>查看引入的包：/imports</h2>
<p>使用 <code>/imports</code> 命令可以查看当前已经导入的包。这对于确保您在 JShell 中能够访问所需的类和方法非常有用。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>imports
<span class="token operator">|</span>    <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span>
</code></pre></div><p>这表明已经导入了 <code>java.util</code> 包。</p>
<h2>退出jshell：/exit</h2>
<p>使用 <code>/exit</code> 命令可以退出 JShell。如果需要，在命令后可以添加一个整数表达式片段作为退出代码。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>exit <span class="token number">0</span>
</code></pre></div><p>这将以退出代码 0 退出 JShell。</p>
<h2>查看命令：/help</h2>
<p>最后，使用 <code>/help</code> 命令可以随时查看 JShell 的帮助信息，了解各种命令和主题的使用方法。例如：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>jshell<span class="token operator">&gt;</span> <span class="token operator">/</span>help
<span class="token operator">|</span>  键入 <span class="token class-name">Java</span> 语言表达式<span class="token punctuation">,</span> 语句或声明。
<span class="token operator">|</span>  或者键入以下命令之一<span class="token operator">:</span>
<span class="token operator">|</span>  <span class="token operator">/</span>list <span class="token punctuation">[</span><span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span><span class="token operator">|</span><span class="token operator">-</span>all<span class="token operator">|</span><span class="token operator">-</span>start<span class="token punctuation">]</span>
<span class="token operator">|</span>  	列出您键入的源
<span class="token operator">|</span>  <span class="token operator">/</span>edit <span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span>
<span class="token operator">|</span>  	编辑源条目
<span class="token operator">|</span>  <span class="token operator">/</span>drop <span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span>
<span class="token operator">|</span>  	删除源条目
<span class="token operator">|</span>  <span class="token operator">/</span>save <span class="token punctuation">[</span><span class="token operator">-</span>all<span class="token operator">|</span><span class="token operator">-</span>history<span class="token operator">|</span><span class="token operator">-</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;</span>文件<span class="token operator">&gt;</span>
<span class="token operator">|</span>  	将片段源保存到文件
<span class="token operator">|</span>  <span class="token operator">/</span><span class="token keyword">open</span> <span class="token generics"><span class="token punctuation">&lt;</span>file<span class="token punctuation">&gt;</span></span>
<span class="token operator">|</span>  	打开文件作为源输入
<span class="token operator">|</span>  <span class="token operator">/</span>vars <span class="token punctuation">[</span><span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span><span class="token operator">|</span><span class="token operator">-</span>all<span class="token operator">|</span><span class="token operator">-</span>start<span class="token punctuation">]</span>
<span class="token operator">|</span>  	列出已声明变量及其值
<span class="token operator">|</span>  <span class="token operator">/</span>methods <span class="token punctuation">[</span><span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span><span class="token operator">|</span><span class="token operator">-</span>all<span class="token operator">|</span><span class="token operator">-</span>start<span class="token punctuation">]</span>
<span class="token operator">|</span>  	列出已声明方法及其签名
<span class="token operator">|</span>  <span class="token operator">/</span>types <span class="token punctuation">[</span><span class="token operator">&lt;</span>名称或 id<span class="token operator">&gt;</span><span class="token operator">|</span><span class="token operator">-</span>all<span class="token operator">|</span><span class="token operator">-</span>start<span class="token punctuation">]</span>
<span class="token operator">|</span>  	列出类型声明
<span class="token operator">|</span>  <span class="token operator">/</span>imports 
<span class="token operator">|</span>  	列出导入的项
<span class="token operator">|</span>  <span class="token operator">/</span>exit <span class="token punctuation">[</span><span class="token operator">&lt;</span>integer<span class="token operator">-</span>expression<span class="token operator">-</span>snippet<span class="token operator">&gt;</span><span class="token punctuation">]</span>
<span class="token operator">|</span>  	退出 jshell 工具
<span class="token operator">|</span>  <span class="token operator">/</span>env <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">module</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>add<span class="token operator">-</span>modules <span class="token operator">&lt;</span>模块<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">|</span>  	查看或更改评估上下文
<span class="token operator">|</span>  <span class="token operator">/</span>reset <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">module</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>add<span class="token operator">-</span>modules <span class="token operator">&lt;</span>模块<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">|</span>  	重置 jshell 工具
<span class="token operator">|</span>  <span class="token operator">/</span>reload <span class="token punctuation">[</span><span class="token operator">-</span>restore<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>quiet<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">module</span><span class="token operator">-</span>path <span class="token operator">&lt;</span>路径<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">|</span>  	重置和重放相关历史记录 <span class="token operator">--</span> 当前历史记录或上一个历史记录 <span class="token punctuation">(</span><span class="token operator">-</span>restore<span class="token punctuation">)</span>
<span class="token operator">|</span>  <span class="token operator">/</span>history <span class="token punctuation">[</span><span class="token operator">-</span>all<span class="token punctuation">]</span>
<span class="token operator">|</span>  	您键入的内容的历史记录
<span class="token operator">|</span>  <span class="token operator">/</span>help <span class="token punctuation">[</span><span class="token generics"><span class="token punctuation">&lt;</span>command<span class="token punctuation">&gt;</span></span><span class="token operator">|</span><span class="token generics"><span class="token punctuation">&lt;</span>subject<span class="token punctuation">&gt;</span></span><span class="token punctuation">]</span>
<span class="token operator">|</span>  	获取有关使用 jshell 工具的信息
<span class="token operator">|</span>  <span class="token operator">/</span>set editor<span class="token operator">|</span>start<span class="token operator">|</span>feedback<span class="token operator">|</span>mode<span class="token operator">|</span>prompt<span class="token operator">|</span>truncation<span class="token operator">|</span>format <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">|</span>  	设置配置信息
<span class="token operator">|</span>  <span class="token operator">/</span><span class="token operator">?</span> <span class="token punctuation">[</span><span class="token generics"><span class="token punctuation">&lt;</span>command<span class="token punctuation">&gt;</span></span><span class="token operator">|</span><span class="token generics"><span class="token punctuation">&lt;</span>subject<span class="token punctuation">&gt;</span></span><span class="token punctuation">]</span>
<span class="token operator">|</span>  	获取有关使用 jshell 工具的信息
<span class="token operator">|</span>  <span class="token operator">/</span><span class="token operator">!</span> 
<span class="token operator">|</span>  	重新运行上一个片段 <span class="token operator">--</span> 请参阅 <span class="token operator">/</span>help rerun
<span class="token operator">|</span>  <span class="token operator">/</span><span class="token generics"><span class="token punctuation">&lt;</span>id<span class="token punctuation">&gt;</span></span> 
<span class="token operator">|</span>  	按 <span class="token constant">ID</span> 或 <span class="token constant">ID</span> 范围重新运行片段 <span class="token operator">--</span> 参见 <span class="token operator">/</span>help rerun
<span class="token operator">|</span>  <span class="token operator">/</span><span class="token operator">-</span><span class="token generics"><span class="token punctuation">&lt;</span>n<span class="token punctuation">&gt;</span></span> 
<span class="token operator">|</span>  	重新运行以前的第 n 个片段 <span class="token operator">--</span> 请参阅 <span class="token operator">/</span>help rerun
<span class="token operator">|</span>  
<span class="token operator">|</span>  有关详细信息<span class="token punctuation">,</span> 请键入 <span class="token char">'/help'</span><span class="token punctuation">,</span> 后跟
<span class="token operator">|</span>  命令或主题的名称。
<span class="token operator">|</span>  例如 '<span class="token operator">/</span>help <span class="token operator">/</span>list<span class="token char">' 或 '</span><span class="token operator">/</span>help intro'。主题<span class="token operator">:</span>
<span class="token operator">|</span>  
<span class="token operator">|</span>  intro
<span class="token operator">|</span>  	jshell 工具的简介
<span class="token operator">|</span>  keys
<span class="token operator">|</span>  	类似 readline 的输入编辑的说明
<span class="token operator">|</span>  id
<span class="token operator">|</span>  	片段 <span class="token constant">ID</span> 以及如何使用它们的说明
<span class="token operator">|</span>  shortcuts
<span class="token operator">|</span>  	片段和命令输入提示<span class="token punctuation">,</span> 信息访问以及
<span class="token operator">|</span>  	自动代码生成的按键说明
<span class="token operator">|</span>  context
<span class="token operator">|</span>  	<span class="token operator">/</span>env <span class="token operator">/</span>reload 和 <span class="token operator">/</span>reset 的评估上下文选项的说明
<span class="token operator">|</span>  rerun
<span class="token operator">|</span>  	重新评估以前输入片段的方法的说明

jshell<span class="token operator">&gt;</span> 
</code></pre></div><p>这将显示 JShell 的主要帮助信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 9 新特性：不可变集合的快捷创建方法</title>
      <link>https://www.geekyspace.cn/md/java/features/Java9/jep269-convenience-factory-methods-for-collections.html</link>
      <guid>https://www.geekyspace.cn/md/java/features/Java9/jep269-convenience-factory-methods-for-collections.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 9 新特性：不可变集合的快捷创建方法</source>
      <description>Java 9 新特性：不可变集合的快捷创建方法 Java 9 引入了一项令人期待的新特性，即集合的便利工厂方法（Convenience Factory Methods for Collections），旨在使不可变集合的创建更加简单和便捷。 在此之前，我们通常使用构造方法来初始化集合，而Java 9为我们提供了一些全新的静态工厂方法，使得创建不可变集合...</description>
      <category>Java Features</category>
      <pubDate>Fri, 22 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Java 9 引入了一项令人期待的新特性，即<strong>集合的便利工厂方法</strong>（Convenience Factory Methods for Collections），旨在使不可变集合的创建更加简单和便捷。
在此之前，我们通常使用构造方法来初始化集合，而Java 9为我们提供了一些全新的静态工厂方法，使得创建不可变集合的过程更为优雅。</p>
<h2>Java 9的集合创建方式</h2>
<p>Java 9引入了一些便利的工厂方法，使得创建和初始化集合对象变得更加简洁和方便。
这些改进包括List.of()、Set.of()和Map.of()等方法，用于创建不可变的集合对象。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建不可变列表</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> immutableList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变集合</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> immutableSet <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变映射</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> immutableMap <span class="token operator">=</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样一行代码就完成了整个集合的创建和初始化过程，使得代码更加简洁、清晰，并且具有更高的可读性。</p>
<h2>Java 8的集合创建方式</h2>
<p>Java 8引入了Lambda表达式和流式操作，这使得集合的初始化过程变得更加流畅和具有函数式编程的特性。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建不可变列表</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> immutableList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>
        <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变集合</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> immutableSet <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableSet</span><span class="token punctuation">(</span>
        <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">,</span> <span class="token string">"item2"</span><span class="token punctuation">,</span> <span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变映射</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> immutableMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>
        <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>data <span class="token operator">-&gt;</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然相较于传统方式，Java 8的写法更为紧凑，但仍显得略显繁琐。</p>
<h2>传统的集合创建方式</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建不可变列表</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> traditionalList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>traditionalList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变集合</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> traditionalSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalSet <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableSet</span><span class="token punctuation">(</span>traditionalSet<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建不可变映射</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> traditionalMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
traditionalMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>traditionalMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种方式繁琐且不够直观，给代码的可读性和编写效率带来了一定的挑战。</p>
<h2>List.of() vs. Arrays.asList()</h2>
<ul>
<li>
<p><strong>可变性：</strong><code>List.of</code> 创建的是不可变集合，<code>Arrays.asList</code> 是可变集合</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// List.of 创建建的列表是不可变的</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> immutableList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 无法添加、删除或修改元素，以下操作会导致 UnsupportedOperationException</span>
immutableList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
immutableList<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Arrays.asList()  创建的列表是可变的</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> mutableList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可以使用 add()、set() 方法修改元素，但不允许改变列表的大小</span>
mutableList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mutableList<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>
<p><strong>null元素：</strong><code>List.of</code> 不允许包含 null 元素，<code>Arrays.asList</code> 允许包含 null 元素，但不推荐</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> listWithNull <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>
<p><strong>底层数据结构：</strong><code>List.of </code>使用不可变数据结构，<code>Arrays.asList</code>底层使用数组，对列表修改将反映在原始数组上</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> immutableList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> mutableList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>深入理解Java虚拟机</title>
      <link>https://www.geekyspace.cn/md/java/jvm/</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">深入理解Java虚拟机</source>
      <description>深入理解Java虚拟机目录 前言（Preface） 致谢（Acknowledgements） 第一部分 走近Java（Part 1: Approaching Java） 第1章 走近Java（Chapter 1: Approaching Java） 1.1 概述（Overview） 1.2 Java技术体系（Java Technology System...</description>
      <category>JVM</category>
      <pubDate>Thu, 08 Aug 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>前言（Preface）</h2>
<h2>致谢（Acknowledgements）</h2>
<h2>第一部分 走近Java（Part 1: Approaching Java）</h2>
<ul>
<li><strong>第1章 走近Java（Chapter 1: Approaching Java）</strong>
<ul>
<li>1.1 概述（Overview）</li>
<li>1.2 Java技术体系（Java Technology System）</li>
<li>1.3 Java发展史（History of Java）</li>
<li><a href="/md/java/jvm/part1/overview.html#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%B6%E6%97%8F" target="_blank">1.4 Java虚拟机家族（Java Virtual Machine Family）</a></li>
<li>1.5 展望Java技术的未来（Future of Java Technology）</li>
<li><a href="part1/compile_jdk">1.6 实战：自己编译JDK（Practical: Compiling JDK）</a></li>
</ul>
</li>
</ul>
<h2>第二部分 自动内存管理（Part 2: Automatic Memory Management）</h2>
<ul>
<li>
<p><strong>第2章 Java内存区域与内存溢出异常（Chapter 2: Java Memory Areas and OutOfMemoryError）</strong></p>
<ul>
<li>2.1 概述（Overview）</li>
<li><a href="part2/runtime-data-areas">2.2 运行时数据区域（Runtime Data Areas）</a></li>
<li><a href="part2/heap-object-flow">2.3 HotSpot虚拟机对象探秘（HotSpot Virtual Machine Object Exploration）</a></li>
<li>2.4 实战：OutOfMemoryError异常（Practical: OutOfMemoryError Exception）</li>
</ul>
</li>
<li>
<p><strong>第3章 垃圾收集器与内存分配策略（Chapter 3: Garbage Collectors and Memory Allocation Strategies）</strong></p>
<ul>
<li>3.1 概述（Overview）</li>
<li>3.2 对象已死吗？（Is the Object Dead?）</li>
<li>3.3 垃圾收集算法（Garbage Collection Algorithms）</li>
<li>3.4 HotSpot的算法实现（HotSpot Algorithm Implementation）</li>
<li>3.5 垃圾收集器（Garbage Collectors）</li>
</ul>
</li>
<li>
<p><strong>第4章 虚拟机性能监控、故障处理工具（Chapter 4: JVM Performance Monitoring and Troubleshooting Tools）</strong></p>
<ul>
<li>4.1 概述（Overview）</li>
<li>4.2 JConsole介绍（Introduction to JConsole）</li>
<li><a href="/md/java/jvm/part2/visual-tools/visualvm.html" target="_blank">4.3 VisualVM介绍（Introduction to VisualVM）</a></li>
<li>4.4 其他工具（Other Tools）</li>
</ul>
</li>
<li>
<p><strong>第5章 调优案例分析与实战（Chapter 5: Optimization Case Analysis and Practices）</strong></p>
<ul>
<li>5.1 概述（Overview）</li>
<li>5.2 实战案例分析（Practical Case Analysis）</li>
<li>5.3 调优实践（Optimization Practices）</li>
</ul>
</li>
</ul>
<h2>第三部分 虚拟机执行子系统（Part 3: JVM Execution Subsystem）</h2>
<ul>
<li>
<p><strong>第6章 类文件结构（Chapter 6: Class File Structure）</strong></p>
<ul>
<li>6.1 概述（Overview）</li>
<li><a href="/md/java/jvm/part3/class-file-structure.html#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%9F%BA%E7%9F%B3" target="_blank">6.2 无关性的基石（The Cornerstone of Independence）</a></li>
<li><a href="/md/java/jvm/part3/class-file-structure.html#class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-%E7%90%86%E8%AE%BA" target="_blank">6.3 Class类文件的结构（Structure of Class File）</a></li>
<li><a href="part3/bytecode-instructions-set">6.4 字节码指令简介（Introduction to Bytecode Instructions）</a></li>
<li>6.5 公有设计，私有实现（Public Design, Private Implementation）</li>
<li>6.6 Class文件结构的发展（Development of Class File Structure）</li>
</ul>
</li>
<li>
<p><strong>第7章 虚拟机类加载机制（Chapter 7: JVM Class Loading Mechanism）</strong></p>
<ul>
<li>7.1 概述（Overview）</li>
<li>7.2 类加载的时机（Timing of Class Loading）</li>
<li><a href="/md/java/jvm/part3/class-loading-mechanism.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B" target="_blank">7.3 类加载的过程（Class Loading Process）</a></li>
<li><a href="/md/java/jvm/part3/class-loading-mechanism.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" target="_blank">7.4 类加载器（Class Loaders）</a></li>
<li>7.5 Java模块化系统（Java Modular System）</li>
</ul>
</li>
<li>
<p><strong>第8章 虚拟机字节码执行引擎（Chapter 8: JVM Bytecode Execution Engine）</strong></p>
<ul>
<li>8.1 概述（Overview）</li>
<li>8.2 运行时栈帧结构（Runtime Stack Frame Structure）</li>
<li>8.3 方法调用与返回（Method Invocation and Return）</li>
</ul>
</li>
<li>
<p><strong>第9章 类加载及执行子系统的案例与实战（Chapter 9: Case Studies and Practices of Class Loading and Execution Subsystem）</strong></p>
<ul>
<li>9.1 概述（Overview）</li>
<li>9.2 实战案例分析（Practical Case Analysis）</li>
<li>9.3 调优实践（Optimization Practices）</li>
</ul>
</li>
</ul>
<h2>第四部分 程序编译与代码优化（Part 4: Program Compilation and Code Optimization）</h2>
<ul>
<li>
<p><strong>第10章 前端编译与优化（Chapter 10: Front-end Compilation and Optimization）</strong></p>
<ul>
<li>10.1 概述（Overview）</li>
<li>10.2 语法与语义分析（Syntax and Semantic Analysis）</li>
<li>10.3 字节码生成（Bytecode Generation）</li>
</ul>
</li>
<li>
<p><strong>第11章 后端编译与优化（Chapter 11: Back-end Compilation and Optimization）</strong></p>
<ul>
<li>11.1 概述（Overview）</li>
<li>11.2 即时编译器（Just-in-time Compiler）</li>
<li>11.3 编译优化（Compilation Optimization）</li>
</ul>
</li>
</ul>
<h2>第五部分 高效并发（Part 5: Efficient Concurrency）</h2>
<ul>
<li>
<p><strong>第12章 Java内存模型与线程（Chapter 12: Java Memory Model and Threads）</strong></p>
<ul>
<li>12.1 概述（Overview）</li>
<li>12.2 Java内存模型（Java Memory Model）</li>
<li>12.3 线程与线程池（Threads and Thread Pools）</li>
</ul>
</li>
<li>
<p><strong>第13章 线程安全与锁优化（Chapter 13: Thread Safety and Lock Optimization）</strong></p>
<ul>
<li>13.1 概述（Overview）</li>
<li>13.2 线程安全（Thread Safety）</li>
<li>13.3 锁优化（Lock Optimization）</li>
</ul>
</li>
</ul>
<h2>附录（Appendices）</h2>
<ul>
<li>
<p><strong>附录A 在Windows系统下编译OpenJDK 6（Appendix A: Compiling OpenJDK 6 on Windows）</strong></p>
</li>
<li>
<p><strong>附录B 展望Java技术的未来（2013年版）（Appendix B: Outlook of Java Technology's Future (2013 Edition)）</strong></p>
</li>
<li>
<p><strong>附录C 虚拟机字节码指令表（Appendix C: JVM Bytecode Instruction Table）</strong></p>
<ul>
<li>C.1 指令集概述（Overview of Instruction Set）</li>
<li>C.2 常用指令详解（Detailed Explanation of Common Instructions）</li>
</ul>
</li>
<li>
<p><strong>附录D 对象查询语言（OQL）简介（Appendix D: Introduction to Object Query Language (OQL)）</strong></p>
<ul>
<li>D.1 概述（Overview）</li>
<li>D.2 OQL语法（OQL Syntax）</li>
<li>D.3 使用案例（Usage Cases）</li>
</ul>
</li>
<li>
<p><strong>附录E JDK历史版本轨迹（Appendix E: Historical Versions of the JDK）</strong></p>
<ul>
<li>E.1 概述（Overview）</li>
<li>E.2 版本列表（Version List）</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>实战编译JDK</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part1/compile_jdk.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part1/compile_jdk.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">实战编译JDK</source>
      <description>实战编译JDK 想要窥探Java虚拟机内部的实现原理，最直接的路径就是编译自己的JDK。 尽管网络上有不少开源JDK实现，但OpenJDK无疑是最广泛使用的，我们将选择OpenJDK进行编译实战。 获取源码 版本选择OpenJDK 12，下载地址 https://hg.openjdk.org/jdk/jdk12 点击“browse”链接，然后选择对应的...</description>
      <category>JVM</category>
      <pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>想要窥探Java虚拟机内部的实现原理，最直接的路径就是编译自己的JDK。
尽管网络上有不少开源JDK实现，但OpenJDK无疑是最广泛使用的，我们将选择OpenJDK进行编译实战。</p>
<h2>获取源码</h2>
<ul>
<li>版本选择OpenJDK 12，下载地址 <a href="https://hg.openjdk.org/jdk/jdk12" target="_blank" rel="noopener noreferrer">https://hg.openjdk.org/jdk/jdk12</a></li>
<li>点击“browse”链接，然后选择对应的压缩包（zip、gz）进行下载</li>
</ul>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202407260406861.png" alt="OpenJDK源码下载" tabindex="0" loading="lazy"><figcaption>OpenJDK源码下载</figcaption></figure>
<h2>系统需求</h2>
<p>建议在Linux或MacOS上构建OpenJDK，构建工具链和依赖项比起Windows或Solaris平台要容易许多。</p>
<ul>
<li>认真阅读一遍源码中的<code>doc/building.html</code>文档</li>
<li>确保源码和依赖项不要放在包含中文的目录里面</li>
</ul>
<h2>构建编译环境</h2>
<h2>进行编译</h2>
<h2>在IDE工具中进行源码调试</h2>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202407260406861.png" type="image/png"/>
    </item>
    <item>
      <title>Java虚拟机概述</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part1/overview.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part1/overview.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java虚拟机概述</source>
      <description>Java虚拟机概述 Java虚拟机（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。 它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。 JVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Writ...</description>
      <category>JVM</category>
      <pubDate>Fri, 19 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p><strong>Java虚拟机</strong>（Java Virtual Machine，简称JVM）是运行所有Java程序的虚拟计算机，是Java平台的核心实现。
它提供了一种独立于底层硬件和操作系统的运行环境，使Java程序能够在任何安装了JVM的系统上执行。
JVM通过将Java字节码（.class文件）转换为机器码来实现跨平台运行，这一特性被称为“Write Once, Run Anywhere”。</p>
</blockquote>
<h2>跨平台开发的通用平台</h2>
<p>随着发展，JVM不再是Java独享的Moment，越来越多的语言开始在JVM上运行，使JVM逐渐演变成一个<strong>跨平台开发的通用平台</strong>。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png" alt="jvm-class" tabindex="0" loading="lazy"><figcaption>jvm-class</figcaption></figure>
<ul>
<li>JVM本质上只关心<code>.class</code>的字节码文件，而不关心源代码是用什么语言编写的。</li>
<li>通过Oracle TCK（Technology Compatibility Kit）测试，就是合格的Java虚拟机。</li>
</ul>
<h2>Java虚拟机家族</h2>
<p><strong>虚拟机始祖：Sun Classic/Exact VM（Sun/Oracle公司）</strong></p>
<ul>
<li><strong>Classic VM：</strong>
<ul>
<li>1996年1月23日，Sun发布JDK 1.0，正式商用，最早的Java虚拟机实现</li>
<li>直到JDK 1.4，才完全退出商用虚拟机的历史舞台</li>
<li><mark>纯解释器</mark>，可外挂即时编译器（JIT），<strong>缺点</strong>是只能<u>二选一</u></li>
</ul>
</li>
<li><strong>Exact VM：</strong>
<ul>
<li>在JDK 1.2时，在Solaris平台发布，是Classic VM的改进版</li>
<li>因准确式内存管理（Exact Memory Management）而得名，是垃圾收集时准确判断堆上数据的前提</li>
<li>它的编译执行系统已经具备现代高性能虚拟机雏形
<ul>
<li>如热点探测、两级即时编译器、<mark>编译器与解释器混合工作</mark>模式等</li>
</ul>
</li>
<li><strong>缺点</strong>是<u>只能在Solaris平台上运行</u></li>
</ul>
</li>
</ul>
<p><strong>武林盟主：HotSpot VM（Sun/Oracle公司）</strong></p>
<ul>
<li><strong>HotSpot VM</strong>
<ul>
<li>最初由Longview Technologies公司开发，后被Sun公司收购</li>
<li>从JDK 1.3至今（2024），HotSpot VM成为默认虚拟机，目前使用最广泛</li>
<li>HotSpot VM集成了Sun以上两款虚拟机优点（准确式内存管理，热点代码探测技术...）
<ul>
<li><strong>优点</strong>是<u>同时支持解释执行和即时编译执行</u>，在响应速度和执行速度上取得平衡</li>
</ul>
</li>
<li>Oracle收购Sun以后，建立HotRockit项目，把BEA JRocki优秀特性融合到HotSpot之中</li>
<li>2014年JDK 8时期，HotSpot移除掉<a href="/md/jvm/part2/runtime-data-areas.html#%E6%96%B9%E6%B3%95%E5%8C%BA" target="_blank">永久代</a>，吸收了JRockit的Java Mission Control监控工具等功能</li>
</ul>
</li>
</ul>
<p><strong>小家碧玉：Mobile/Embedded VM（Sun/Oracle公司）</strong></p>
<p>专门为移动设备和嵌入式设备设计的Java虚拟机（JavaME）</p>
<ul>
<li><strong>KVM（Kilobyte Virtual Machine）</strong>:
<ul>
<li>用于早期的移动设备，但智能手机市场已被Android和iOS主导</li>
</ul>
</li>
<li><strong>CDC（Connected Device Configuration）</strong>:
<ul>
<li>用于功能更强的嵌入式设备，但面临自家Java SE Embedded（eJDK）的竞争</li>
<li>由于Java SE的普及，CDC市场快速萎缩，Oracle基本砍掉了CDC-HI项目，将其划归Java SE Embedded</li>
</ul>
</li>
</ul>
<p><strong>天下第二：BEA JRockit/IBM J9 VM</strong></p>
<ul>
<li><strong>BEA JRockit</strong>:
<ul>
<li>最初由BEA Systems开发，后被Oracle收购，永远停留在R28（JDK 6版JRockit代号）</li>
<li><mark>专注于服务器</mark>硬件和服务端应用场景，不关注启动速度，不包含解释器实现</li>
<li>以其出色的垃圾收集器和性能和诊断工具（如Java Mission Control）著称</li>
</ul>
</li>
<li><strong>IBM J9 VM</strong>:
<ul>
<li>全称“IBM Technology for Java Virtual Machine”，简称IT4J，但普遍称为J9</li>
<li>作为通用型JVM，其市场定位接近HotSpot，主要优势在IBM产品上</li>
<li>由IBM开发，2017年开源为<a href="https://www.eclipse.org/openj9/" target="_blank" rel="noopener noreferrer">OpenJ9</a>，现由Eclipse基金会维护</li>
<li>模块化设计优于HotSpot
<ul>
<li>核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）构成了IBM OMR项目</li>
<li>可以在其他语言平台如Ruby、Python中快速组装成相应的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>软硬合璧：BEA Liquid VM/Azul VM（Zing）</strong></p>
<ul>
<li>
<p><strong>BEA Liquid VM</strong>:</p>
<ul>
<li>也被称为JRockit VE（Virtual Edition，VE），专为BEA WebLogic实时运行环境设计</li>
<li>BEA公司开发的JRockit虚拟机虚拟化版本，可直接运行在自家Hypervisor系统上</li>
<li>不需要操作系统支持，自身实现了必要的操作系统功能（如线程调度、文件系统、网络支持等）</li>
<li>直接控制硬件，避免内核态/用户态切换，最大限度发挥硬件性能，提升Java程序执行效率</li>
<li>随着JRockit虚拟机终止开发，Liquid VM项目也停止了</li>
</ul>
</li>
<li>
<p><strong>Azul VM</strong>:</p>
<ul>
<li>适用于Azul Systems专有硬件Vega产品线，在HotSpot基础改进</li>
<li>采用PGC和C4收集器，停顿时间可控，每个Azul VM实例可管理数十个CPU和数百GB内存</li>
</ul>
</li>
<li>
<p><strong>Zing VM</strong>:</p>
<ul>
<li>2010年起，Azul公司重心转向软件，发布Zing虚拟机，基于HotSpot某旧版代码分支</li>
<li>低延迟，配备PGC和C4垃圾收集器
<ul>
<li>支持TB级别Java堆内存，暂停时间不超过10毫秒</li>
<li>HotSpot直到JDK 11和JDK 12的ZGC和Shenandoah收集器才达到类似目标，但效果仍不及C4</li>
</ul>
</li>
<li>Zing的ReadyNow（快速预热、启动）！
<ul>
<li>利用之前收集的性能监控数据，使虚拟机在启动后快速达到高性能水平</li>
<li>减少从解释执行到即时编译的等待时间</li>
</ul>
</li>
<li>易于监控（ZVision/ZVRobot工具）
<ul>
<li>方便用户监控JVM运行状态，包括代码热点、对象分配监控、锁竞争监控等</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>挑战者：Apache Harmony/Google Android Dalvik VM</strong></p>
<ul>
<li>
<p><strong>Apache Harmony</strong>:</p>
<ul>
<li>一个开源的Java SE实现项目，旨在提供兼容Java SE的JVM及类库。虽然项目已停止，但其代码和理念影响深远</li>
<li>Apache软件基金会开源项目，兼容JDK 5和JDK 6，提供自己的虚拟机和Java类库API。</li>
<li>没有通过TCK认证，无法正式称为“Java虚拟机”</li>
<li>曾对Java生态系统构成巨大挑战，导致Apache基金会退出JCP组织</li>
<li>随Sun公司开源OpenJDK，Harmony项目的优势逐渐减弱</li>
<li>主要贡献（如Java类库代码）被吸纳进IBM JDK 7和Google Android SDK</li>
</ul>
</li>
<li>
<p><strong>Google Android Dalvik VM</strong>:</p>
<ul>
<li>Android平台核心虚拟机，名字来源于冰岛的小渔村Dalvik</li>
<li>非Java虚拟机，使用寄存器架构，不直接执行Java Class文件，而是执行DEX文件</li>
<li>通过Class文件转化为DEX文件，支持Java语法和API，推动Android迅速发展</li>
<li>Android 2.2引入即时编译器，提升性能</li>
<li>Android 4.4开始引入提前编译（Ahead of Time Compilation，AOT）的ART虚拟机</li>
<li>Android 5.0开始ART全面替代Dalvik虚拟机</li>
</ul>
</li>
</ul>
<p><strong>没有成功，但并非失败：Microsoft JVM及其他</strong></p>
<ul>
<li><strong>Microsoft JVM</strong>:
<ul>
<li>微软开发的Java虚拟机，曾用于早期的Windows平台。但由于与Sun的法律纠纷，微软最终停止了其开发</li>
<li>为支持Internet Explorer 3中的Java Applets，开发Microsoft JVM，仅限Windows平台</li>
<li>被认为是当时Windows系统下性能最好的Java虚拟机，1997年和1998年连续获得《PC Magazine》“编辑选择奖”</li>
<li>1997年被Sun公司控告侵犯商标、不正当竞争，最终微软赔偿2000万美元，并承诺停止开发和逐步移除其Java虚拟机</li>
<li>虽然微软的Java虚拟机未能长期发展，但其短暂的成功对当时Java的推广起到了积极作用。</li>
</ul>
</li>
</ul>
<p><strong>百家争鸣</strong></p>
<ul>
<li>KVM：为小型设备设计的轻量级Java虚拟机</li>
<li>Java Card VM：支持智能卡和小型嵌入式设备的Java虚拟机</li>
<li>Squawk VM：针对嵌入式系统和传感器网络的Java虚拟机</li>
<li>JavaInJava：用Java自身编写的Java虚拟机</li>
<li>Maxine VM：由Java编写、用于研究和实验的Java虚拟机</li>
<li>Jikes RVM： IBM开源的高性能研究虚拟机</li>
<li>IKVM.NET：在.NET平台上运行Java代码的虚拟机</li>
<li>JamVM：<a href="http://jamvm.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://jamvm.sourceforge.net/</a></li>
<li>CacaoVM：<a href="http://www.cacaovm.org/" target="_blank" rel="noopener noreferrer">http://www.cacaovm.org/</a></li>
<li>SableVM：<a href="http://www.sablevm.org/" target="_blank" rel="noopener noreferrer">http://www.sablevm.org/</a></li>
<li>Kaffe：<a href="http://www.kaffe.org/" target="_blank" rel="noopener noreferrer">http://www.kaffe.org/</a></li>
<li>Jelatine JVM：<a href="http://jelatine.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://jelatine.sourceforge.net/</a></li>
<li>NanoVM：<a href="http://www.harbaum.org/till/nanovm/index.shtml" target="_blank" rel="noopener noreferrer">http://www.harbaum.org/till/nanovm/index.shtml</a></li>
<li>MRP：<a href="https://github.com/codehaus/mrp" target="_blank" rel="noopener noreferrer">https://github.com/codehaus/mrp</a></li>
<li>Moxie JVM：<a href="http://moxie.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://moxie.sourceforge.net/</a></li>
</ul>
<h2>Java虚拟机架构</h2>
<p>理解总体知识点在全局上与知识体系之间的对应关系</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="Java虚拟机架构" tabindex="0" loading="lazy"><figcaption>Java虚拟机架构</figcaption></figure>
<p>从整体上看，JVM 由三个不同的组件组成：</p>
<ol>
<li><strong>类加载子系统（Class Loader SubSystem）</strong>：主要负责将类<code>.class</code>加载到内存中</li>
<li><strong>运行时数据区（Runtime Data Area）</strong>：管理JVM运行时所需的数据结构</li>
<li><strong>执行引擎（Execution Engine）</strong>：负责执行字节码指令，将其转换为机器代码，供机器理解</li>
</ol>
<figure><img src="https://img.geekyspace.cn/pictures/2024/image-39.png" alt="JVM三大组件" tabindex="0" loading="lazy"><figcaption>JVM三大组件</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png" type="image/png"/>
    </item>
    <item>
      <title>堆中对象分配、布局和访问的全过程</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part2/heap-object-flow.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part2/heap-object-flow.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">堆中对象分配、布局和访问的全过程</source>
      <description>堆中对象分配、布局和访问的全过程 本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。 对象的创建 在Java中，创建对象通常使用new关键字，而在JVM中，创建对象的过程如下： 1、类加载检查 JVM首先检查new指令所引用的类是否已加载、连接和初始化。 如果没有，会先执行。 2、分配内存 JVM为新对象分配内存，其大小在类...</description>
      <category>JVM</category>
      <pubDate>Sat, 10 Aug 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>本文将深入探讨HotSpot虚拟机中Java堆中对象分配、布局和访问的全过程。</p>
</blockquote>
<h2>对象的创建</h2>
<p>在Java中，创建对象通常使用<code>new</code>关键字，而在JVM中，创建对象的过程如下：</p>
<p><strong>1、类加载检查</strong></p>
<p>JVM首先检查<code>new</code>指令所引用的类是否已加载、连接和初始化。
如果没有，会先执行<a href="/md/jvm/part3/class-loading-mechanism.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B" target="_blank">类加载过程</a>。</p>
<p><strong>2、分配内存</strong></p>
<p>JVM为新对象分配内存，其大小在类加载完成时确认，<strong>内存分配的方式：</strong></p>
<ol>
<li><strong>指针碰撞：</strong> 适用于规整的堆内存，将内存分为已使用和未使用两部分，通过移动指针分配内存。</li>
<li><strong>空闲列表：</strong> 适用于不规整的堆内存，JVM维护一个空闲列表，从中找到合适的内存块进行分配。</li>
</ol>
<p>使用压缩整理功能的收集器（如Serial、ParNew）通常采用指针碰撞分配，而基于标记-清除（Sweep）算法的CMS收集器使用空闲列表分配。</p>
<p><strong>线程安全的内存分配方式：</strong></p>
<ul>
<li><strong>同步处理：</strong> 通过同步操作或CAS加重试机制确保原子性。</li>
<li><strong>线程本地分配缓冲（TLAB）：</strong> 每个线程在Java堆中预先分配一小块内存，分配时在<code>TLAB</code>中进行，
只有<code>TLAB</code>耗尽分配新的<code>TLAB</code>时才才需同步。
<ul>
<li>通过<code>-XX:+UseTLAB</code>参数来启用<code>TLAB</code>。</li>
</ul>
</li>
</ul>
<p><strong>3、初始化零值（不包括对象头）</strong></p>
<p>JVM将分配的内存空间（不包括对象头）初始化为零值，确保对象字段在未显式初始化时可直接使用。</p>
<p><strong>4、设置对象头</strong></p>
<p>JVM设置对象头，包括：</p>
<ul>
<li><strong>Mark Word：</strong> 存储对象的哈希码（调用<code>Object::hashCode()</code>时计算）、GC分代年龄、锁信息等。</li>
<li><strong>类元数据指针：</strong> 指向对象所属类的元数据，确定对象是哪个类的实例。</li>
</ul>
<p><strong>5、执行<code>&lt;init&gt;</code>方法</strong></p>
<p>至此，在JVM层面，一个新的对象已经产生了。
但从Java程序视角，对象创建才刚刚开始，所有的字段都还为零值。
只有构造方法<code>&lt;init&gt;</code>执行后，对象才按照程序员的意图完成初始化，成为一个真正可用的对象。</p>
<h2>对象的内存布局</h2>
<h2>对象的访问定位</h2>
]]></content:encoded>
    </item>
    <item>
      <title>运行时数据区</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part2/runtime-data-areas.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part2/runtime-data-areas.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">运行时数据区</source>
      <description>运行时数据区 运行时数据区是指在运行程序时存储数据的内存区域。分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。 Java虚拟机运行时数据区Java虚拟机运行时数据区 线程私有： 程序计数器 - 存储线程执行位置 虚拟机栈 - 存储Java方法调用与执行过程的数据 本地方法栈 - 存储本地方法的执行数据 线程共享： 堆 - 主要...</description>
      <category>JVM</category>
      <pubDate>Sat, 10 Aug 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p><strong>运行时数据区</strong>是指在运行程序时存储数据的内存区域。分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区五个部分。</p>
</blockquote>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202408102247073.png" alt="Java虚拟机运行时数据区" tabindex="0" loading="lazy"><figcaption>Java虚拟机运行时数据区</figcaption></figure>
<ul>
<li><strong>线程私有：</strong>
<ul>
<li><strong>程序计数器</strong> - 存储线程执行位置</li>
<li><strong>虚拟机栈</strong> - 存储Java方法调用与执行过程的数据</li>
<li><strong>本地方法栈</strong> - 存储本地方法的执行数据</li>
</ul>
</li>
<li><strong>线程共享：</strong>
<ul>
<li><strong>堆</strong> - 主要存储对象</li>
<li><strong>方法区</strong> - 存储类/方法/字段等定义(元)数据</li>
<li><strong>运行时常量区</strong> - 保存常量static数据</li>
</ul>
</li>
</ul>
<h2>程序计数器</h2>
<blockquote>
<p><strong>程序计数器</strong>是线程私有的，用于记录当前程序执行的字节码指定位置。</p>
</blockquote>
<p><strong>知识点：</strong></p>
<ol>
<li>线程私有</li>
<li>不会被垃圾回收</li>
<li>访问速度最快（JVM内存区域中）</li>
<li>占用内存少，不会出现<code>OutOfMemoryError</code></li>
<li>执行Java方法时，记录的是字节码指令地址</li>
<li>执行Native方法时，记录为未定义（<code>undefined</code>）</li>
</ol>
<p><strong>思考以下问题，加强理解：</strong></p>
<ol>
<li>程序计数器如何保证线程能够准确地恢复到之前的执行位置？</li>
<li>字节码执行与程序计数器的关系？</li>
</ol>
<h2>虚拟机栈</h2>
<blockquote>
<p><strong>虚拟机栈</strong>是线程私有的内存区域，其生命周期与线程相同。
它描述了<strong>方法执行的内存模型</strong>。当方法被执行时，JVM会为该方法同步创建一个<mark>栈帧（Stack Frame）</mark>。</p>
</blockquote>
<p><strong>知识点：</strong></p>
<ol>
<li>线程私有</li>
<li>不会被垃圾回收</li>
<li>访问速度仅次于程序计数器</li>
<li>栈大小可设置，限制深度：
<ul>
<li>推荐固定大小设置（<code>-Xss 数值[k|m|g]</code>），达到上限，抛出<code>StackOverflowError</code></li>
<li>动态扩展，可用内存不足时，抛出<code>OutOfMemoryError</code></li>
</ul>
</li>
</ol>
<p><strong>栈帧的内部结构：</strong></p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt="栈帧的概念结构" tabindex="0" loading="lazy"><figcaption>栈帧的概念结构</figcaption></figure>
<ul>
<li><strong>局部变量表：</strong> 用于存储方法中的局部变量和参数。</li>
<li><strong>操作数栈：</strong> 后进先出（LIFO）结构，用于方法执行时存储执行指令产生中间结果。</li>
<li><strong>动态链接：</strong> 指在方法调用时，将符号引用转换为直接引用的过程。</li>
<li><strong>方法返回地址：</strong> 指方法调用后返回位置的地址。</li>
</ul>
<h2>本地方法栈</h2>
<blockquote>
<p><strong>本地方法栈</strong>是线程私有，与虚拟机栈功能相似。其中虚拟机栈为Java方法（字节码）服务，本地方法栈则为Native方法服务。</p>
</blockquote>
<ul>
<li>HotSpot虚拟机把虚拟机栈和本地方法栈合二为一。</li>
<li>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</li>
</ul>
<h2>Java堆</h2>
<blockquote>
<p><strong>Java堆</strong>是虚拟机管理的内存中最大的一块，线程共享，并在虚拟机启动时创建。
它的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在堆上分配。</p>
</blockquote>
<p><strong>堆内存模型：</strong></p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202407172004168.png" alt="堆内存模型" tabindex="0" loading="lazy"><figcaption>堆内存模型</figcaption></figure>
<p>现代垃圾收集器采用分代收集理论进行设计，因此堆内存被划分为多个区域，包括：</p>
<ul>
<li><strong>新生代：</strong>
<ul>
<li>存放生命周期较短的对象</li>
<li>通常由Eden区和两个Survivor区(被称为from/to或s0/s1)组成，默认比例是<code>8:1:1</code></li>
<li>填满时触发<code>Minor GC</code>（小型垃圾回收）</li>
<li>采用复制算法，将存活的对象复制到Survivor区，然后清理Eden区和使用过的Survivor区。</li>
</ul>
</li>
<li><strong>老年代：</strong>
<ul>
<li>存放生命周期较长，或多次垃圾收集后任然存活的对象</li>
<li>填满时触发<code>Major GC</code>或<code>Full GC</code>，耗时严重</li>
<li>使用的垃圾收集算法通常是标记-清除算法或标记-整理算法。</li>
</ul>
</li>
<li><strong>永久代（PermGen）：</strong>
<ul>
<li>存放Class元数据，包括类结构、方法、字段信息等</li>
<li>属于“堆”的一部分，无法扩展时会抛出<code>OutOfMemoryError</code>异常</li>
<li>通过命令<code>-Xms</code>设置初始堆大小，<code>-Xmx</code>设定最大堆大小</li>
<li>从JDK8开始，被元空间（Metaspace）取代，称为“非堆”，使用的是本地内存</li>
</ul>
</li>
</ul>
<p><a href="https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener noreferrer">DigitalOcean——Java （JVM） 内存模型 - Java 中的内存管理</a></p>
<h2>方法区</h2>
<blockquote>
<p><strong>方法区</strong>是JVM规范中的一个逻辑区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。</p>
</blockquote>
<ul>
<li>在Java7的时候，方法区被称为“<strong>永久代</strong>（PermGen）”。</li>
<li>从Java8开始，方法区的实现被改为<strong>元空间</strong>（Metaspace），元空间使用的是本地内存，而不是像永久代那样在JVM的堆内存中分配。</li>
</ul>
<h2>运行时常量池</h2>
<blockquote>
<p><strong>运行时常量池</strong>是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，支持在运行时动态添加新的常量。</p>
</blockquote>
<ul>
<li><strong>字面量：</strong> 表示固定的数据值，如整数、浮点数、字符串等常量。</li>
<li><strong>符号引用：</strong> 一组符号，用于描述所引用的目标，包括类和接口的全限定名、字段和方法的名称。</li>
</ul>
<p><strong>知识点：</strong></p>
<ol>
<li>具备动态性，如<code>String.intern()</code>方法将字符串对象添加到运行时常量池中。</li>
<li>会产生<code>OutOfMemoryError</code>异常</li>
</ol>
<p><strong>思考以下问题，加强理解：</strong></p>
<ol>
<li>Class常量池与运行时常量池的关系？</li>
</ol>
<h2>直接内存</h2>
<p><strong>直接内存</strong>并不是虚拟机运行时数据区的一部分，也未在《Java虚拟机规范》中明确定义。
然而，由于其频繁使用且可能导致<code>OutOfMemoryError</code>异常，值得在此进行讨论。</p>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>NIO的引入：</strong> JDK 1.4引入了NIO（New Input/Output）类，通过通道（Channel）和缓冲区（Buffer）实现了一种新的I/O方式。它使用本地（Native）函数库直接分配堆外内存，并通过在Java堆中的<code>DirectByteBuffer</code>对象进行引用和操作。</li>
<li><strong>性能优势：</strong> 这种方法能够显著提高性能，因为它避免了在Java堆和本地堆之间的数据复制，从而加快了I/O操作。</li>
<li><strong>内存限制：</strong> 虽然直接内存的分配不受Java堆大小的限制，但仍受到本机总内存（包括物理内存、SWAP分区或分页文件）大小和处理器寻址空间的限制。</li>
<li><strong>配置问题：</strong> 在配置虚拟机参数（如<code>-Xmx</code>）时，管理员通常会根据实际物理内存来设置Java堆的大小，但可能忽略直接内存的占用。如果各个内存区域的总和超过了物理内存限制，可能在动态扩展时导致<code>OutOfMemoryError</code>异常。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202408102247073.png" type="image/png"/>
    </item>
    <item>
      <title>字节码指令集</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part3/bytecode-instructions-set.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part3/bytecode-instructions-set.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">字节码指令集</source>
      <description>字节码指令集 字节码指令集是Java虚拟机（JVM）能理解和执行的低级指令集合。具体保存在Java类文件（.class）的方法区描述中。 总数不超过256个，由操作码和操作数 组成。 操作码（Opcode）： 一个字节长度的数字，代表某种特定操作 操作数（Operands）： 跟随操作码之后的零至多个参数，用于该操作所需的数据 由于JVM采用面向操作数...</description>
      <category>JVM</category>
      <pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>字节码指令集是Java虚拟机（JVM）能理解和执行的低级指令集合。具体保存在Java类文件（<code>.class</code>）的方法区描述中。</p>
</blockquote>
<p>总数不超过256个，由<u><em>操作码</em></u>和<u><em>操作数</em></u> 组成。</p>
<ul>
<li><strong>操作码（<code>Opcode</code>）：</strong> 一个字节长度的数字，代表某种特定操作</li>
<li><strong>操作数（<code>Operands</code>）：</strong> 跟随操作码之后的零至多个参数，用于该操作所需的数据</li>
</ul>
<p>由于JVM采用面向操作数栈而不是面向寄存器的架构，大多数指令都不包含操作数，只有一个操作码，指令参数存放在操作数栈中。</p>
<h2>操作码助记符</h2>
<p>数据类型相关的字节码指令，包含特定的<strong>操作码助记符</strong>：</p>
<p>| 数据类型      | 操作码助记符 |
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>类文件结构</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part3/class-file-structure.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part3/class-file-structure.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">类文件结构</source>
      <description>类文件结构 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 无关性的基石 字节码是构成平台无关性和的语言无关性基石： 平台无关性： 字节码不依赖特定操作系统或硬件架构，任何支持JVM的环境（如Windows、Linux、macOS、甚至嵌入式设备）都能运行相同的字节码，实现 “一次编写，到处运行”。 语言无关...</description>
      <category>JVM</category>
      <pubDate>Fri, 19 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>代码编译的结果从本地机器码转变为<strong>字节码</strong>，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
</blockquote>
<h2>无关性的基石</h2>
<p><strong>字节码</strong>是构成<mark>平台无关性</mark>和的<mark>语言无关性</mark>基石：</p>
<ul>
<li><strong>平台无关性：</strong>
<ul>
<li>字节码不依赖特定操作系统或硬件架构，任何支持<strong>JVM</strong>的环境（如<code>Windows</code>、<code>Linux</code>、<code>macOS</code>、甚至嵌入式设备）都能运行相同的字节码，实现 “<em>一次编写，到处运行</em>”。</li>
</ul>
</li>
<li><strong>语言无关性：</strong>
<ul>
<li>多种编程语言（如<code>Java</code>、<code>Kotlin</code>、<code>Scala</code>、<code>Groovy</code>）都可以编译成字节码，并在<strong>JVM</strong>（如<code>GraalVM</code>）上运行，不仅限于Java。</li>
</ul>
</li>
</ul>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202407200209120.png" alt="Java虚拟机提供的语言无关性" tabindex="0" loading="lazy"><figcaption>Java虚拟机提供的语言无关性</figcaption></figure>
<h2>Class类文件结构</h2>
<p>我们通俗的将类和接口的定义信息
Java技术的良好向后兼容性得益于Class文件结构的稳定性，Class文件对应的是类或接口的定义信息，是一组以8个字节为单位的二进制流。各数据项严格按顺序排列，没有任何分隔符。</p>
<p>Class文件格式类似于C语言的结构体，这种伪结构只有两种数据类型：“<u>无符号数</u>”和“<u>表</u>”。</p>
<ul>
<li><strong>无符号数：</strong> <mark>基本数据类型</mark>，使用<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>表示1、2、4、8个字节的无符号数。
<ul>
<li>它们可以描述数字、索引引用、数量值或按照<code>UTF-8</code>编码的字符串值。</li>
</ul>
</li>
<li><strong>表：</strong> 由多个无符号数或其他表构成的<mark>复合数据类型</mark>，通常以“<strong>_info</strong>”结尾。
<ul>
<li>描述有层次关系的复合结构，整个Class文件本质上也是一个表，由按严格顺序排列的数据项构成。</li>
</ul>
</li>
</ul>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html" target="_blank" rel="noopener noreferrer">JVM虚拟机规范第四章</a>中规定了<code>ClassFile</code>的结构，如下所示：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ClassFile</span> <span class="token punctuation">{</span>
  u4 magic<span class="token punctuation">;</span>                            <span class="token comment">// 魔数 (0xCAFEBABE)，标识class文件格式</span>
  u2 minor_version<span class="token punctuation">;</span>                    <span class="token comment">// 次版本号</span>
  u2 major_version<span class="token punctuation">;</span>                    <span class="token comment">// 主版本号</span>
  u2 constant_pool_count<span class="token punctuation">;</span>              <span class="token comment">// 常量池计数</span>
  cp_info constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 常量池</span>
  u2 access_flags<span class="token punctuation">;</span>                     <span class="token comment">// 访问标志</span>
  u2 this_class<span class="token punctuation">;</span>                       <span class="token comment">// 当前类索引</span>
  u2 super_class<span class="token punctuation">;</span>                      <span class="token comment">// 父类索引</span>
  u2 interfaces_count<span class="token punctuation">;</span>                 <span class="token comment">// 接口计数</span>
  u2 interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 接口索引表</span>
  u2 fields_count<span class="token punctuation">;</span>                     <span class="token comment">// 字段计数</span>
  field_info fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 字段表</span>
  u2 methods_count<span class="token punctuation">;</span>                    <span class="token comment">// 方法计数</span>
  method_info methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 方法表</span>
  u2 attributes_count<span class="token punctuation">;</span>                 <span class="token comment">// 属性计数</span>
  attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 属性表</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 <code>class</code> 文件的组成。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202407220149546.png" alt="ClassFile 内容分析" tabindex="0" loading="lazy"><figcaption>ClassFile 内容分析</figcaption></figure>
<h3>1.魔数</h3>
<blockquote>
<p><strong>魔数：</strong> 区分文件类型的依据，验证文件是否有效。</p>
</blockquote>
<ul>
<li><code>0xCAFEBABE</code>是<code>Class</code>文件的魔数。</li>
<li>其他文件格式也使用魔数来进行身份识别。
<ul>
<li>JPEG（jpg）：<code>FFD8FF</code></li>
<li>PNG（png）：<code>89504E47</code></li>
<li>GIF（gif）：<code>47494638</code></li>
<li>TIFF（tif）：<code>49492A00</code></li>
</ul>
</li>
</ul>
<p><strong><code>0xCAFEBABE</code>的由来</strong></p>
<p>在Java语言仍被称为“Oak”的早期（约 1991 年），Java开发团队便选定<code>0xCAFEBABE</code>作为魔数。
据Java开发小组关键成员<em>Patrick Naughton</em>透露，他们选择这个值是因为它好玩且容易记忆。
象征着著名咖啡品牌<em>Peet’s Coffee</em>备受喜爱的<em>Baristas</em>咖啡，也预示着日后“<u>Java-咖啡</u>”商标的出现。</p>
<h3>2.Class文件版本号</h3>
<blockquote>
<p><strong>版本号：</strong> 紧跟魔数之后，占 4 个字节，包含主版本号和次版本号，用于标识Class文件的版本。</p>
</blockquote>
<ul>
<li>第5~6字节：<u><strong>次</strong>版本号</u>（Minor Version）</li>
<li>第7~8字节：<u><strong>主</strong>版本号</u>（Major Version），Java 8 = 52.0</li>
</ul>
<p>主版本号从JDK 1.0 = <strong>45</strong>开始，每次大版本发布都会 <strong>+1</strong> ；</p>
<p><strong>向下兼容：</strong></p>
<ul>
<li>使用JDK 1.8版本，编译出1.7版本的<code>class</code></li>
<li>编译后的字节码版本高于JVM版本时，运行会产生<code>UnsupportedClassVersionError</code>异常</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>javac –source <span class="token number">1.8</span> –target <span class="token number">1.7</span> Example.java
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2025/image-20250227222416922.png" alt="Class文件版本号" tabindex="0" loading="lazy"><figcaption>Class文件版本号</figcaption></figure>
<p>注：从JDK 9开始，<code>javac</code>编译器不再支持使用<code>-source</code>参数编译版本号小于1.5的源码。</p>
<h3>3.常量池</h3>
<blockquote>
<p><strong>常量池：</strong> 紧随版本号之后，可以理解成Class文件的资源仓库。用于存放<u><em>字面量</em></u>，<u><em>符号引用</em></u>，<u><em>常量池类型数据表</em></u>。</p>
</blockquote>
<p><strong>1、常量池计数</strong></p>
<p>由于常量项不固定，入口处<code>u2</code>类型的数据值表示<strong>常量池计数</strong>（<code>constant_pool_count</code>）。</p>
<ul>
<li>常量池的计数从1开始，即：<code>常量项 = 常量池计数 - 1</code></li>
<li>Class文件格式规范刻意将第0项常量空出，特定情况下索引值0表示“不引用任何常量池项”</li>
</ul>
<p><strong>2、常量类型</strong></p>
<p>常量池主要存放两大类常量：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic References）</p>
<ul>
<li><strong>字面量：</strong> 比较接近于Java语言层面的常量概念，如数值、文本字符串、final常量等</li>
<li><strong>符号引用：</strong> 符号引用则属于编译原理方面的概念，包括以下几类常量：
<ul>
<li>被模块导出或者开放的包(Package)</li>
<li>类和接口的全限定名(Fully Qualified Name)</li>
<li>字段的名称和描述符(Descriptor)</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型(Method Handle、Method Type、Invoke Dynamic)</li>
<li>动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)</li>
</ul>
</li>
</ul>
<p>不同于C/C++编译时有“连接”步骤，JVM在加载Class文件时才进行“动态连接”。
因此，Class文件不保存方法、字段最终在内存中的布局信息。
JVM在类加载时从常量池获取符号引用，并在类创建或运行时解析为具体地址。</p>
<p><strong>3、常量池数据类型表</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener noreferrer">JVM虚拟机规范第四章-常量池</a>
定义了<code>constant_pool</code>表条目具有以下通用格式：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>cp_info <span class="token punctuation">{</span>
  u1 tag<span class="token punctuation">;</span>
  u1 info<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常量池中的每项常量都是一个表，起始的第一位是一个<code>u1</code>类型的标志位（tag），表示当前常量的类型。</p>
<ol>
<li>最初设计的11种常量类型</li>
<li>为支持动态语言，增加了4种动态语言相关的常量</li>
<li>为支持Java模块化系统（Jigsaw），新增了<code>CONSTANT_Module_info</code>和<code>CONSTANT_Package_info</code></li>
</ol>
<p>| 类型(tag)                              | 描述              | 结构细节（起始<code>u1 tag;</code>）                                                                                  |
|</p>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202407200209120.png" type="image/png"/>
    </item>
    <item>
      <title>类加载机制</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part3/class-loading-mechanism.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part3/class-loading-mechanism.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">类加载机制</source>
      <description>类加载机制 类的生命周期 类的生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。 解析阶段不一...</description>
      <category>JVM</category>
      <pubDate>Sat, 20 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>类的生命周期</h2>
<blockquote>
<p>类的生命周期将会经历<strong>加载</strong> （Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）七个阶段</p>
</blockquote>
<ul>
<li>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，按部就班地开始。</li>
<li>解析阶段不一定，某些情况下可以在初始化之后，以支持Java的运行时绑定（动态绑定）特性。</li>
</ul>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202407260441081.png" alt="类的生命周期" tabindex="0" loading="lazy"><figcaption>类的生命周期</figcaption></figure>
<ul>
<li>注：并非所有的类都会经历完整的生命周期，有些类可能在某些阶段就结束其在JVM中的生涯。</li>
</ul>
<h2>Class实例何时被创建</h2>
<p>在Java虚拟机(JVM)规范中，类的<strong>加载</strong>过程是由JVM自行决定的，但<strong>初始化</strong>过程则必须严格按照规范执行。
（在初始化之前，类的加载、验证、准备阶段必然已经完成）。</p>
<h3>主动引用（六种情况）</h3>
<blockquote>
<p>在Java虚拟机规范中，“有且只有”以下六种情况会触发类的初始化，称为对一个类的<u><strong>主动引用</strong></u>：</p>
</blockquote>
<ol>
<li>创建对象实例、访问静态字段（非常量）、调用静态方法
<ul>
<li>即遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这 4 种字节码指令。</li>
</ul>
</li>
<li><strong>反射调用</strong> 使用<code>java.lang.reflect</code>对类型（类和接口）进行反射调用</li>
<li>初始化子类时，先初始化父类</li>
<li><strong>启动主类</strong>，JVM启动时，先初始化包含<code>main()</code>方法的主类。</li>
<li><strong>JDK 1.7的动态语言支持</strong>
<ul>
<li><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener noreferrer">周志明-解析 JDK 7 的动态类型语言支持</a></li>
<li>JDK 1.7 引入<code>java.lang.invoke.MethodHandle</code> 动态语言支持，解析静态字段/方法或构造方法时</li>
<li>即解析的句柄属于<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>或<code>REF_newInvokeSpecial</code>四种情况时，会触发目标类初始化。</li>
</ul>
</li>
<li><strong>接口默认方法</strong>初始化规则
<ul>
<li>JDK 1.8 新增<code>default</code>默认方法，若实现类初始化，则需要先初始化该接口。</li>
</ul>
</li>
</ol>
<h3>被动引用（不触发）</h3>
<blockquote>
<p>除了以上六种场景外，所有其他引用类的方式都不会触发初始化，称为<u><strong>被动引用</strong></u>。</p>
</blockquote>
<ul>
<li><strong>例1：通过子类引用父类的静态字段，不会导致子类初始化，只有父类会被初始化</strong>
<ul>
<li>子类是否加载和验证，取决于虚拟机的具体实现。</li>
<li>在HotSpot虚拟机（JDK 1.8 亲测）中，使用<code>-XX:+TraceClassLoading</code>观察到此操作会导致子类加载。</li>
</ul>
</li>
<li><strong>例2：通过数组定义来引用类，不会触发此类的初始化</strong>
<ul>
<li>例如，<code>MyClass[] sca = new MyClass[10];</code>，不会初始化<code>MyClass</code>类</li>
<li>但这段代码触发了另一个名为<code>[L包名.MyClass</code>的类的初始化阶段。它是由虚拟机自动生成的、继承自<code>java.lang.Object</code>
的子类，由字节码指令<code>newarray</code>触发。这个类表示<code>MyClass</code>的一维数组，包含数组应有的属性和方法（如<code>public</code>的<code>length</code>
属性和<code>clone()</code>方法）。</li>
<li>Java语言对数组的访问比C/C++更安全，因为这个类包装了数组元素的访问，C/C++中直接翻译为对数组指针的移动。
在Java语言里，发生数组越界时会抛出<code>java.lang.ArrayIndexOutOfBoundsException</code>异常，避免非法内存访问。</li>
</ul>
</li>
<li><strong>例3：引用常量不会触发定义常量的类的初始化</strong>
<ul>
<li>因为常量在编译阶段就会被存入调用类的常量池中。</li>
</ul>
</li>
</ul>
<h3>接口和类“加载与初始化”的差异</h3>
<p><strong>相同点</strong></p>
<ul>
<li>类 &amp; 接口都经历：加载 → 验证 → 准备 → 解析 → <strong>初始化（<code>&lt;clinit&gt;()</code>）</strong></li>
</ul>
<p><strong>差异</strong></p>
<ul>
<li>接口不能使用<code>static{}</code>语句块，但编译器仍会生成<code>&lt;clinit&gt;()</code>方法用于初始化静态变量。</li>
<li>类在初始化时，其父类必须先初始化。</li>
<li>接口在初始化时不要求父接口初始化，只有在真正使用到父接口的常量等成员时才会触发其初始化。</li>
</ul>
<h2>类加载的过程</h2>
<p>Java类加载过程主要分为<strong>加载</strong>、<strong>连接</strong>（验证、准备、解析）、<strong>初始化</strong>三个阶段。</p>
<h3>加载（Loading）</h3>
<blockquote>
<ol>
<li>通过类的全限定名<strong>读取类的二进制字节流</strong>。</li>
<li>并将字节流所代表的 静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li>
<li>在<strong>堆</strong>内存中生成<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的的访问入口。</li>
</ol>
</blockquote>
<ul>
<li><strong>类文件来源：</strong>
<ul>
<li>通常包括本地文件系统、压缩文件（如JAR、WAR）、网络、数据库、加密文件（防止反编译）、运行时动态生成，以及由其他文件生成（如JSP应用生成的Class文件）。</li>
</ul>
</li>
<li><strong>数组类加载：</strong>
<ul>
<li>数组类本身不通过类加载器创建，而是由Java虚拟机直接在内存中构建出来。但数组类的元素类型最终还是靠类加载器来完成加载。</li>
</ul>
</li>
</ul>
<img src="http://img.geekyspace.cn/pictures/2025/image-20250302011909381.png" alt="image-20250302011909381" style="zoom: 60%;">
<h3>连接（Linking）</h3>
<p>分为三个阶段：</p>
<ul>
<li><strong>验证</strong>（Verify）：确保字节码符合虚拟机要求</li>
<li><strong>准备</strong>（Prepare）：为字段赋予初始值</li>
<li><strong>解析</strong>（Resolve）：符号引用转换为直接引用</li>
</ul>
<blockquote>
<p><strong>验证</strong>（Verify）是连接阶段的第一阶段，目的是确保字节码的正确性和安全性，包括文件格式验证、元数据验证、字节码验证和符号引用验证四个阶段。</p>
</blockquote>
<p>验证阶段大致上会完成下面四个阶段的检验动作：</p>
<ol>
<li><strong>文件格式验证：</strong> 检查字节流是否符合Class文件的格式规范。</li>
<li><strong>元数据验证：</strong> 对类的元数据信息进行语义校验，确保其符合Java语言的语法和语意规则。</li>
<li><strong>字节码验证：</strong> 通过数据流分析和控制流分析，确保字节码指令的合法性和逻辑正确性。</li>
<li><strong>符号引用验证：</strong> 在解析阶段之前，检查符号引用是否能被正确解析。</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2025/image-20250302022044718.png" alt="验证阶段" tabindex="0" loading="lazy"><figcaption>验证阶段</figcaption></figure>
<blockquote>
<p><strong>准备</strong>（Prepare）阶段为类中的静态变量分配内存并设置初始值。</p>
</blockquote>
<p>静态变量的内存分配发生在<strong>方法区</strong>中。</p>
<ul>
<li>在 JDK 7及之前，HotSpot使用<strong>永久代</strong>（PerGen）来实现方法区，存放在堆内存中。</li>
<li>在 JDK 8及之后，永久代被移除，取而代之的是<strong>元空间</strong>（Metaspace），存放在操作系统本地内存中。</li>
</ul>
<img src="http://img.geekyspace.cn/pictures/2025/image-20250302023259231.png" alt="准备阶段" style="zoom: 60%;">
<blockquote>
<p><strong>解析</strong>（Prepare）阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
</blockquote>
<ul>
<li><strong>符号引用（Symbolic References）：</strong> 字符串形式表示的对目标的逻辑引用</li>
<li><strong>直接引用（Direct References）：</strong> 是直接定位到目标内存位置的指针、偏移量或句柄。</li>
</ul>
<p>解析动作主要针对<u>类或接口</u>、<u>字段</u>、<u>类方法</u>、<u>接口方法</u>、<u>方法类型</u>、<u>方法句柄</u>和<u>调用点限定符</u>这 7 类符号引用进行。</p>
<h3>初始化（Initialization）</h3>
<blockquote>
<p>类加载过程的最后一个阶段，负责执行类构造器方法 <code>&lt;clinit&gt;</code>。</p>
</blockquote>
<ul>
<li><strong>自动生成：</strong> 由javac编译自动生成<code>&lt;clinit&gt;</code>，是所有静态变量赋值和静态代码块的集合。</li>
<li><strong>非法前向引用：</strong> 静态语句块中只能访问定义在其之前的变量。</li>
<li>父类的 <code>&lt;clinit&gt;</code> 方法会先于子类的 <code>&lt;clinit&gt;</code> 方法执行。</li>
<li>如果一个类没有静态语句块和静态变量的赋值操作，那么编译器可能不会生成 <code>&lt;clinit&gt;</code> 方法。</li>
<li><code>+TraceClassLoading</code> 查看类加载过程</li>
<li>多线程环境下，类的初始化可能会出现并发问题，JVM会保证<code>&lt;clinit&gt;</code>方法的线程安全执行。</li>
</ul>
<h2>类加载器</h2>
<blockquote>
<p>加载阶段“通过一个类的全限定名来获取描述该类的二进制字节流”，这个动作的代码被称为“类加载器”（Class Loader）。</p>
</blockquote>
<h3>类与类加载器</h3>
<p>一个类在JVM中由其完全限定名和对应的类加载器共同确定唯一性。
即使两个类具有相同的完全限定名，由不同的类加载器加载的，JVM也会将它们视为两个“不相等”的类。</p>
<ul>
<li>“不相等” 包括Class对象的<code>equals</code>方法，<code>isAssignableFrom()</code>方法，<code>isInstance()</code>方法的返回结果。</li>
</ul>
<p><strong>不同的类加载器对instanceof关键字运算的结果的影响</strong></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 类加载器与instanceof关键字演示
 *
 * <span class="token keyword">@author</span> zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个自定义的类加载器</span>
        <span class="token class-name">ClassLoader</span> myLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取类名对应的文件名（去除包名，只保留类名）</span>
                    <span class="token class-name">String</span> fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>
                    <span class="token comment">// 从当前类路径中加载Class文件</span>
                    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 如果找不到文件，则调用父类加载器加载</span>
                        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token class-name">Object</span> obj <span class="token operator">=</span> myLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"org.fenixsoft.classloading.ClassLoaderTest"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>classloading<span class="token punctuation">.</span></span>ClassLoaderTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行结果：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>class org.fenixsoft.classloading.ClassLoaderTest
<span class="token boolean">false</span>
</code></pre></div><h3>双亲委派模型</h3>
<p>双亲委派模型是Java类加载机制的一种设计模式 ，用于确保类的唯一性和安全性。
它规定，类加载器在接收到类加载请求时，首先将该请求委派给父类加载器处理。
如果父类加载器无法完成加载，子类加载器才会尝试加载该类。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202408100244787.png" alt="类加载器双亲委派模型（JDK 8及之前）" tabindex="0" loading="lazy"><figcaption>类加载器双亲委派模型（JDK 8及之前）</figcaption></figure>
<ul>
<li>从Java虚拟机的角度，类加载器分为两类：
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这是Java虚拟机的一部分，使用<code>C++</code>实现，负责加载核心类库，如<code>rt.jar</code>中的类。这个类加载器不可被Java程序直接引用。</li>
<li>其他类加载器：这些是由Java实现的类加载器，继承自<code>java.lang.ClassLoader</code>，并且独立存在于虚拟机之外。</li>
</ul>
</li>
<li>从Java开发人员的角度，可以细分为三层类加载器：
<ul>
<li><strong>启动类加载器</strong>（Bootstrap ClassLoader）：加载<code>&lt;JAVA_HOME&gt;\lib</code>目录中的核心类库。</li>
<li><strong>扩展类加载器</strong>（Extension ClassLoader）：加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或通过java.ext.dirs指定路径中的扩展类库。</li>
<li><strong>应用程序类加载器</strong>（Application ClassLoader）：加载用户类路径（ClassPath）上的所有类库，通常是程序的默认类加载器。</li>
</ul>
</li>
</ul>
<p><strong>双亲委派模型的实现</strong></p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先，检查请求的类是否已经被加载过了</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果该类还未被加载</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果存在父类加载器</span>
                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 让父类加载器尝试加载该类</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果没有父类加载器，尝试用引导类加载器加载</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果父类加载器抛出 ClassNotFoundException</span>
            <span class="token comment">// 说明父类加载器无法完成加载请求，继续在本加载器中寻找</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 在父类加载器无法加载时</span>
            <span class="token comment">// 调用本加载器的 findClass 方法来加载类</span>
            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment">// 返回加载的类</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>破坏双亲委派模型</h3>
<p>双亲委派模型并不是强制性约束的模型，直到Java模块化出现为止，出现过3次较大规模“被破坏”的情况。</p>
<p><strong>第 1 次被破坏：</strong></p>
<p>在JDK 1.2之前，由于没有双亲委派模型的约束，开发者可以直接覆盖 <code>loadClass()</code> 方法。
为了兼容现有代码并引导开发者遵循双亲委派模型，JDK 1.2引入了 <code>findClass()</code>
方法，建议开发者重写该方法而非直接覆盖 <code>loadClass()</code>。</p>
<ul>
<li><strong>loadClass()：</strong> 双亲委派模型的实现，父类加载异常时，调用 <code>findClass()</code> 方法进行加载。</li>
<li><strong>findClass()：</strong> 自定义类加载器具体实现。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202407260441081.png" type="image/png"/>
    </item>
    <item>
      <title>VisualVM介绍</title>
      <link>https://www.geekyspace.cn/md/java/jvm/part2/visual-tools/visualvm.html</link>
      <guid>https://www.geekyspace.cn/md/java/jvm/part2/visual-tools/visualvm.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">VisualVM介绍</source>
      <description>VisualVM介绍 官网地址: https://visualvm.github.io/ IDEA 集成：VisualVM Launcher Github开源翻译助手：VVM-Translator 安装插件VisualVM GC</description>
      <category>JVM</category>
      <pubDate>Thu, 06 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>官网地址: https://visualvm.github.io/</p>
</blockquote>
<ul>
<li>
<p>IDEA 集成：<a href="https://plugins.jetbrains.com/plugin/7115-visualvm-launcher/versions" target="_blank" rel="noopener noreferrer">VisualVM Launcher</a></p>
</li>
<li>
<p>Github开源翻译助手：<a href="https://github.com/zedoCN/VVM-Translator" target="_blank" rel="noopener noreferrer">VVM-Translator</a></p>
</li>
<li>
<p>安装插件VisualVM GC</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 常用类与工具</title>
      <link>https://www.geekyspace.cn/md/java/basic/java-common-classes.html</link>
      <guid>https://www.geekyspace.cn/md/java/basic/java-common-classes.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 常用类与工具</source>
      <description>Java 常用类与工具 Object 通用方法 Object 类是Java编程语言中的根类（基类），具有以下特点： 继承关系：所有类都直接或间接继承自 Object 类 默认父类：如果一个类没有明确指定父类，它会自动继承 Object 类 核心方法：提供了所有对象都具备的基本方法 Object 通用方法Object 通用方法 对象包装器与自动装箱 Ja...</description>
      <category>Java</category>
      <pubDate>Sat, 13 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>Object 通用方法</h2>
<p><code>Object</code> 类是Java编程语言中的根类（基类），具有以下特点：</p>
<ul>
<li><strong>继承关系</strong>：所有类都直接或间接继承自 <code>Object</code> 类</li>
<li><strong>默认父类</strong>：如果一个类没有明确指定父类，它会自动继承 <code>Object</code> 类</li>
<li><strong>核心方法</strong>：提供了所有对象都具备的基本方法</li>
</ul>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509150047796.png" alt="Object 通用方法" tabindex="0" loading="lazy"><figcaption>Object 通用方法</figcaption></figure>
<h2>对象包装器与自动装箱</h2>
<p>Java 为每种基本数据类型提供了对应的<strong>包装类（Wrapper Class）</strong>，其特点如下：</p>
<ul>
<li>所有包装类位于 <code>java.lang</code> 包中，均为 <code>final</code> 类</li>
<li>包装类是引用类型，可以像对象一样使用基本类型</li>
</ul>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509150129780.png" alt="对象包装器类图结构" tabindex="0" loading="lazy"><figcaption>对象包装器类图结构</figcaption></figure>
<p>从 Java 5 开始，JDK 支持了<strong>自动装箱/拆箱（Autoboxing / Unboxing）</strong>，简化了基本类型与包装类之间的转换：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 装箱：基本类型 → 包装类对象</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 拆箱：包装类对象 → 基本类型</span>
</code></pre></div><p>根据 Java 自动装箱规范，部分包装类在特定范围内使用<strong>缓存池（CachePool）</strong> 复用对象，提高性能，避免重复创建：</p>
<ul>
<li>Boolean：缓存 <code>true</code> / <code>false</code></li>
<li>Character：缓存 <code>\u0000 ~ \u007F</code>（0 ~ 127）</li>
<li>Byte：缓存所有取值范围 <code>[-128, 127]</code></li>
<li>Short / Integer/Long：默认缓存 <code>[-128, 127]</code>，其中 <code>Integer</code> 上限可通过 JVM 参数调整（<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>）</li>
<li>Float / Double：不使用缓存</li>
</ul>
<h2>String</h2>
<p>String 是 Java 中最常用的<strong>引用类型</strong>之一，使用<code>final</code>修饰，具有<strong>不可变性</strong>（<code>Immutable</code>）。</p>
<ul>
<li>位于 <code>java.lang</code> 包中</li>
<li><strong>线程安全</strong>，可被多个线程共享</li>
<li>JDK8 底层使用<code>char</code>数组实现，JDK9+ 改用<code>byte</code>数组+ <code>coder</code>编码标志</li>
</ul>
<h3>String API</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token number">1</span>️⃣ 字符串创建
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"..."</span>               → 字面量创建（常量池复用）
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                → 构造函数创建（堆中新建对象）
<span class="token number">2</span>️⃣ 长度与空值判断
<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                       → 获取字符串的长度
<span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                      → 判断是否为空（即：length <span class="token operator">==</span> <span class="token number">0</span>）
<span class="token function">isBlank</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                      → 判断是否为空白
<span class="token number">3</span>️⃣ 字符串查找
<span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                   → 查找子字符串首次出现位置
<span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>               → 查找子字符串最后出现位置
<span class="token function">contains</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                  → 判断是否包含某子串
<span class="token number">4</span>️⃣ 字符串截取
<span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span>               → 截取子字符串（从 begin 到 结尾）
<span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span>          → 截取子字符串（从 begin 到 end<span class="token operator">-</span><span class="token number">1</span>）
<span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>                  → 获取指定位置字符
<span class="token number">5</span>️⃣ 字符串拼接
<span class="token operator">+</span>                              → 最常用
<span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                    → 辅助拼接
<span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>delimiter<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    → 多字符串拼接
<span class="token number">6</span>️⃣ 字符串替换
<span class="token function">replace</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">)</span>              → 替换字符或子串
<span class="token function">replaceAll</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> replacement<span class="token punctuation">)</span> → 正则全局替换
<span class="token number">7</span>️⃣ 大小写转换
<span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  → 转大写
<span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  → 转小写
<span class="token number">8</span>️⃣ 字符串比较
<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                    → 精确比较
<span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>          → 忽略大小写
<span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                 → 字典序比较（负数<span class="token operator">/</span><span class="token number">0</span><span class="token operator">/</span>正数表示小于<span class="token operator">/</span>相等<span class="token operator">/</span>大于）
<span class="token number">9</span>️⃣ 类型转换与格式化
<span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>            → 基本类型转字符串
<span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>             → 模板格式化
<span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  → 字符串转字符数组（<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span>）
</code></pre></div><h3>JDK9+ Compact Strings</h3>
<ul>
<li><a href="https://openjdk.org/jeps/254" target="_blank" rel="noopener noreferrer">JEP 254: Compact Strings</a></li>
<li>前面提到：<u>JDK8 底层使用<code>char</code>数组实现，JDK9+ 改用<code>byte</code>数组+<code>coder</code>编码标志</u>。</li>
<li><strong>背景</strong>：JDK8 String 使用 <code>char[]</code>，每字符占 2 字节，存储 ASCII/Latin1 时存在内存浪费。</li>
<li><strong>优化方案</strong>：JDK9 起改为 <code>byte[] + coder</code>，根据字符串内容自动选择最优编码方式：
<ul>
<li><code>Latin1</code> 编码 → 每个字符占 1 字节</li>
<li><code>UTF-16</code> 编码 → 每个字符占 2 字节</li>
</ul>
</li>
<li><strong>效果</strong>：减少内存占用，提高缓存命中率，且 API 保持兼容。</li>
</ul>
<h3><a href="/md/java/features/Java21/jep430-string-templates.html" target="_blank">Java21  String Templates</a></h3>
<h3>内存分配演进</h3>
<ol>
<li>在 Java 中，String 是引用类型，其引用存放在<strong>栈（Stack）</strong> 中，对象内容存放在<strong>堆（Heap）</strong> 中。</li>
<li>通过<strong>字符串常量池（String Pool）</strong> 缓存已创建的字面量，避免重复创建对象，提高内存利用率。</li>
<li>利用<code>String.intern()</code>方法，将字符串对象<strong>放入常量池</strong>，并返回常量池中的对象引用。</li>
</ol>
<p><strong>HotSpot中字符串常量池保存哪里？</strong></p>
<p>| JDK 版本 | 常量池位置                          | 说明                                                                   |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/202509150047796.png" type="image/png"/>
    </item>
    <item>
      <title>Java核心思想 - 面向对象编程（OOP）</title>
      <link>https://www.geekyspace.cn/md/java/basic/java-basic-oop.html</link>
      <guid>https://www.geekyspace.cn/md/java/basic/java-basic-oop.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java核心思想 - 面向对象编程（OOP）</source>
      <description>Java核心思想-面向对象编程（OOP） 什么是面向对象编程？ 发展历史简述 1960 年：类（Class）和对象（Object）的概念首次出现在 Simula 语言中。 1970 年代：Smalltalk 引入了“面向对象编程（OOP）”的概念，被认为是第一个真正意义上的 OOP 语言。 1980 年左右：C++ 出现，推动了 OOP 的广泛流行。 ...</description>
      <category>Java</category>
      <pubDate>Sat, 13 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>什么是面向对象编程？</h2>
<h3>发展历史简述</h3>
<ul>
<li><strong>1960 年</strong>：类（Class）和对象（Object）的概念首次出现在 <strong>Simula</strong> 语言中。</li>
<li><strong>1970 年代</strong>：<strong>Smalltalk</strong> 引入了“面向对象编程（OOP）”的概念，被认为是第一个真正意义上的 OOP 语言。</li>
<li><strong>1980 年左右</strong>：<strong>C++</strong> 出现，推动了 OOP 的广泛流行。</li>
<li><strong>今天</strong>：大多数主流语言都支持 OOP（Java、C++、Python、C#、Ruby、JavaScript、Go、Scala、PHP 等）。</li>
</ul>
<h3>类和对象</h3>
<p>面向对象编程中有两个非常重要、非常基础的概念，那就是<strong>类（Cass）</strong> 和<strong>对象（Object）</strong>。</p>
<ul>
<li><strong>类（Class）</strong> 是指对某一类事物的抽象描述，包含属性和方法。</li>
<li><strong>对象（Object）</strong> 是类的实例，是在程序中具体存在的实体。</li>
</ul>
<h3>核心定义</h3>
<ul>
<li><strong>面向对象编程（OOP, Object-Oriented Programming）</strong> 是一种编程范式或编程风格。它以<strong>类</strong>或<strong>对象</strong>作为组织代码的基本单元，并将<strong>封装</strong>、<strong>抽象</strong>、<strong>继承</strong>、<strong>多态</strong>四个特性，作为代码设计和实现的基石 。</li>
<li><strong>面向对象编程语言（OOPL, Object-Oriented Programming Language）</strong> 是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<h2>四大特性</h2>
<h3>封装（Encapsulation）</h3>
<ul>
<li>核心思想：<mark><u>隐藏实现、保护数据、对外提供接口</u></mark>。</li>
<li><strong>实现方式：</strong> 通过 <code>private</code>、<code>protected</code>、<code>public</code> 等权限控制，把属性隐藏起来，通过方法来操作。</li>
<li><strong>意义：</strong>
<ul>
<li>防止数据被随意修改，提高代码的<strong>安全性和可维护性</strong>。</li>
<li>对外只暴露必要的接口，提高类的<strong>易用性</strong>。</li>
<li>👉 通俗理解：<strong>“把属性藏起来，通过方法管起来”</strong>。</li>
</ul>
</li>
</ul>
<h3>抽象（Abstraction）</h3>
<ul>
<li>核心思想：<mark><u>提取共性，屏蔽细节</u></mark>。</li>
<li><strong>实现方式：</strong> 接口、抽象类，或者只提供方法定义而隐藏实现。</li>
<li><strong>意义：</strong>
<ul>
<li>使用者只需关心<strong>做什么</strong>，不必关心<strong>怎么做</strong>。</li>
<li>提高代码的<strong>扩展性和维护性</strong>，修改实现不影响对外接口。</li>
<li>👉 通俗理解：<strong>“只告诉你功能，不告诉你原理”</strong>。</li>
</ul>
</li>
</ul>
<p>⚠️ 有的教程会把<strong>抽象</strong> 视为 <strong>封装的一部分</strong>（抽象 ≈ “隐藏细节、暴露共性”）</p>
<h3>继承（Inheritance）</h3>
<ul>
<li>核心思想：<mark><u>子类复用父类的属性和方法</u></mark>，体现 <code>is-a</code> 关系。</li>
<li><strong>模式：</strong>
<ul>
<li>单继承：一个子类只能继承一个父类（Java）。</li>
<li>多继承：一个子类可继承多个父类（C++ 支持，Java 通过接口间接实现）。</li>
</ul>
</li>
<li><strong>意义：</strong>
<ul>
<li>解决<strong>代码复用</strong>问题。</li>
<li>为多态打下基础。</li>
<li>👉 通俗理解：<strong>“子承父业”</strong>。</li>
</ul>
</li>
</ul>
<h3>多态（Polymorphism）</h3>
<ul>
<li>核心思想：<mark><u>同一接口，不同实现，表现出不同行为</u></mark>。</li>
<li><strong>定义：</strong> 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</li>
<li><strong>实现方式：</strong> 继承 + 方法重写、接口实现、duck typing（动态语言）。</li>
<li><strong>多态的三种类型：</strong>
<ol>
<li><strong>编译时多态（静态多态）</strong>
<ul>
<li>通过**方法重载（Overload）**实现。</li>
<li>编译阶段决定调用哪个方法。</li>
<li>示例：<code>print(int a)</code> 和 <code>print(String s)</code>。</li>
</ul>
</li>
<li><strong>运行时多态（动态多态）</strong>
<ul>
<li>通过<strong>方法重写（Override）<strong>和</strong>向上转型</strong>实现。</li>
<li>运行时根据实际对象类型决定调用哪个方法。</li>
<li>示例：父类 <code>Animal</code> 的 <code>speak()</code> 被子类 <code>Dog</code>、<code>Cat</code> 重写。</li>
</ul>
</li>
<li><strong>参数化多态（泛型多态）</strong>
<ul>
<li>通过<strong>泛型（Generics）</strong> 实现。</li>
<li>方法或类可以操作不同类型，而无需写多份代码。</li>
<li>示例：<code>List&lt;String&gt;</code>、<code>List&lt;Integer&gt;</code> 都能用同一个 <code>List&lt;T&gt;</code> 实现。</li>
</ul>
</li>
</ol>
</li>
<li><strong>意义：</strong>
<ul>
<li>提高代码的<strong>扩展性</strong>（新增子类无需修改原有逻辑）。</li>
<li>提升代码的<strong>复用性</strong>（相同代码可适配多种对象）。</li>
<li>是<strong>设计模式与面向对象编程技巧</strong>的核心基础。</li>
<li>👉 通俗理解：<strong>“一个接口，多种形态”</strong>。</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java基础 - 从零开始学习Java</title>
      <link>https://www.geekyspace.cn/md/java/basic/java-from-scratch.html</link>
      <guid>https://www.geekyspace.cn/md/java/basic/java-from-scratch.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java基础 - 从零开始学习Java</source>
      <description>Java基础 - 从零开始学习Java 1.Java语言的发展历史 Java特征 Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。 特征： 面向对象（OOP） 跨平台性强（“一次编写，到处运行”） 安全性高、可移植性强 Java之父 Java之父 詹姆斯·高斯林 （James G...</description>
      <category>Java</category>
      <pubDate>Tue, 09 Sep 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>1.Java语言的发展历史</h2>
<h3>Java特征</h3>
<p>Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。
<strong>特征：</strong></p>
<ul>
<li>面向对象（OOP）</li>
<li>跨平台性强（“一次编写，到处运行”）</li>
<li>安全性高、可移植性强</li>
</ul>
<h3>Java之父</h3>
<p><img src="http://img.geekyspace.cn/pictures/2025/202509092327337.png" alt="Java之父" loading="lazy">
詹姆斯·高斯林 （James Gosling）是一名软件专家，1955年5月19日出生于加拿大，Java编程语言的共同创始人之一，一般公认他为“Java之父”。
1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位。</p>
<h3>发展历史</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092328789.png" alt="Java语言发展史" tabindex="0" loading="lazy"><figcaption>Java语言发展史</figcaption></figure>
<ul>
<li>2004年推出了Java 1.5版本</li>
<li>2009年Sun公司被Oracle甲骨文公司收购</li>
<li>2014年推出了Java 8.0版本</li>
</ul>
<h3>计算机语言发展历史</h3>
<ol>
<li>第一代<strong>机器语言</strong> 打孔机 二进制010101</li>
<li>第二代<strong>汇编语言</strong> 助记符</li>
<li>第三代<strong>高级编程语言</strong> C、C++、Java、Python 、php、c#等
<img src="http://img.geekyspace.cn/pictures/2025/202509092328775.png" alt="机器>汇编>高级语言发展" loading="lazy"></li>
</ol>
<h3>Java跨平台原理</h3>
<ul>
<li><strong>平台</strong> = 操作系统（<code>Windows</code>，<code>Linux</code>，<code>Mac</code>）</li>
<li>Java的程序可以在任意的操作系统上运行
<img src="http://img.geekyspace.cn/pictures/2025/202509092329828.png" alt="Java跨平台的原理" loading="lazy"></li>
</ul>
<h2>2.下载安装使用JDK</h2>
<h3>下载JDK11</h3>
<p>JDK11的下载官方网站:
<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html" target="_blank" rel="noopener noreferrer">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a>
注意：需要注意下载对应不同操作系统版本的JDK</p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092330631.png" alt="jdk-11安装包" tabindex="0" loading="lazy"><figcaption>jdk-11安装包</figcaption></figure>
<h3>安装后目录介绍</h3>
<p>傻瓜式安装，下一步</p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092330060.png" alt="JDK常见目录" tabindex="0" loading="lazy"><figcaption>JDK常见目录</figcaption></figure>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092331631.png" alt="JDK常见目录" tabindex="0" loading="lazy"><figcaption>JDK常见目录</figcaption></figure>
<h3>配置JDK环境变量</h3>
<p><strong>1. 为什么需要配置JDK环境变量？</strong></p>
<p>不配置JDK环境变量的话，就需要每次到JDK安装路径下的Bin目录执行对应的exe文件；
在环境变量中加入软件的安装路径后，即使没有在该软件的安装目录下，我们在命令行输入软件的名称也可启动该软件。</p>
<p><strong>2.如何配置环境变量</strong></p>
<p>右键“此电脑”&gt;&gt;“属性”，在弹出的页面上点击高“高级系统设置”</p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092332594.png" alt="环境变量-高级系统设置" tabindex="0" loading="lazy"><figcaption>环境变量-高级系统设置</figcaption></figure>
<p>在弹出的“系统属性”窗口中“高级”标签下点击“环境变量”按钮</p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092332253.png" alt="环境变量" tabindex="0" loading="lazy"><figcaption>环境变量</figcaption></figure>
<p>在弹出的“环境变量”窗口中，点击下方的“新建”按钮，在弹出的“新建系统变量”窗口中，新建一个名为<code>JAVA_HOME</code>的环境变量，设置<code>Path</code>环境变量</p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092333174.png" alt="设置Path环境变量" tabindex="0" loading="lazy"><figcaption>设置Path环境变量</figcaption></figure>
<p>验证是否配置成功，进入win+r输入cmd，输入指令<code>java -version</code></p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092333155.png" alt="java -version指令验证" tabindex="0" loading="lazy"><figcaption>java -version指令验证</figcaption></figure>
<p>JDK8之后的版本只需要配置<code>JAVA_HOME</code>，在PATH中添加<code>JAVA_HOME/bin</code>即可。</p>
<h3>JRE，JDK，JVM之间的关系</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092330293.png" alt="JDK，JRE，JVM之间的关系" tabindex="0" loading="lazy"><figcaption>JDK，JRE，JVM之间的关系</figcaption></figure>
<h3>JavaSE，JavaEE，JavaME之间的区别</h3>
<p>Java总共有三个版本</p>
<ol>
<li><strong>标准版Java SE</strong>
<ul>
<li>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类；</li>
</ul>
</li>
<li><strong>企业版Java EE</strong>
<ul>
<li>JavaEE是在JavaSE的基础上构建的，用来开发B/S架构软件，也就是开发企业级应用，所以称为企业版帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API；</li>
</ul>
</li>
<li><strong>微型Java ME</strong>
<ul>
<li>Java ME为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME包括灵活的用户界面、健壮的安全模式、许多内置的网络协议以及对于动态下载的连网和离线应用程序的丰富支持。基于Java ME规范的应用程序只需要编写一次，就可以用于许多设备，而且可以利用每个设备的本级功能。</li>
</ul>
</li>
</ol>
<p><strong>简而言之</strong></p>
<ul>
<li>JavaSE是Java的基础，主要针对桌面程序开发；</li>
<li>JavaEE是针对企业级应用开发；</li>
<li>JavaME是主要针对嵌入式设备软件开发。</li>
</ul>
<h3>Dos常用命令</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092331468.png" alt="Dos常用命令" tabindex="0" loading="lazy"><figcaption>Dos常用命令</figcaption></figure>
<h3>编译运行Java程序</h3>
<p>开发java程序，需要三个步骤：<strong>1.编写程序（源代码）&gt;&gt; 2.编译程序 &gt;&gt; 3.运行程序</strong></p>
<ol>
<li>新建文本文件，修改名称为<code>HelloWorld.java</code></li>
<li>用记事本打开，编写以下程序</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3">
<li>打开命令提示窗口，进入<code>HelloWorld</code>所在目录，输入编译和执行命令</li>
</ol>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 编译，生成 .class 字节码文件</span>
javac <span class="token parameter variable">-encoding</span> UTF-8 HelloWorld.java
<span class="token comment"># 运行程序（执行字节码）</span>
<span class="token function">java</span> HelloWorld
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2025/202509092334223.png" alt="Java程序编译运行流程" tabindex="0" loading="lazy"><figcaption>Java程序编译运行流程</figcaption></figure>
<h2>3.Java基础语法</h2>
<h3>Java注释</h3>
<p>注释是指在程序指定的位置添加的说明信息，不参与运行。<strong>Java 支持三种注释方式：</strong></p>
<ol>
<li>单行：<code>// 注释内容</code></li>
<li>多行：<code>/* 注释内容 */</code></li>
<li>文档注释：<code>/** 注释内容 */</code>
<img src="http://img.geekyspace.cn/pictures/2025/202509092335176.png" alt="Java注释的使用" loading="lazy"></li>
</ol>
<h3>什么是关键字</h3>
<p><strong>Java关键字</strong>是电脑语言里事先定义的，<strong>有特别意义的标识符</strong>，有时又叫保留字。
一律用<strong>小写字母标志</strong>，根据用途分为如下分组：</p>
<ol>
<li><strong>数据类型</strong>：<code>boolean</code>、<code>byte</code>、<code>char</code>、 <code>double</code>、 <code>false</code>、<code>float</code>、<code>int</code>、<code>long</code>、<code>new</code>、<code>short</code>、<code>true</code>、<code>void</code>、<code>instanceof</code>。</li>
<li><strong>语句控制</strong>： <code>break</code>、<code>case</code>、 <code>catch</code>、 <code>continue</code>、 <code>default</code> 、<code>do</code>、 <code>else</code>、 <code>for</code>、 <code>if</code>、<code>return</code>、<code>switch</code>、<code>try</code>、 <code>while</code>、 <code>finally</code>、 <code>throw</code>、<code>this</code>、 <code>super</code>。</li>
<li><strong>修饰符</strong>： <code>abstract</code>、<code>final</code>、<code>native</code>、<code>private</code>、 <code>protected</code>、<code>public</code>、<code>static</code>、<code>synchronized</code>、<code>transient</code>、 <code>volatile</code>。</li>
<li><strong>用于类，方法，包，接口和异常</strong>：<code>class</code>、 <code>extends</code>、 <code>implements</code>、<code>interface</code>、 <code>package</code>、<code>import</code>、<code>throws</code>。</li>
</ol>
<h3>常量与变量</h3>
<ul>
<li><strong>常量</strong>：Java中使用<code>final</code> 修饰，表示运行中不可变化的量。</li>
<li><strong>变量</strong>：在程序运行过程中，可以取不同数值的量；可变，需先声明后使用。
<ul>
<li>语法：变量的数据类型 变量名称 = 变量的值（赋值操作）；</li>
<li>为整数常量，浮点数常量，字符常量，字符串常量，布尔常量（true，false），NULL是常量</li>
</ul>
</li>
<li>命名规则：字母、数字、下划线 <code>_</code>、$ 符号开头，不能以数字开头，遵循驼峰命名法</li>
</ul>
<h3>Java变量命名规则</h3>
<ol>
<li>不能使用Java中的关键字，比如public class void int char等等..</li>
<li>变量名必须以 字母 下划线_ 或者 $ 符号开头</li>
<li>变量名可以包含数字，但是不能够以数字开头</li>
<li>变量名除了 下划线_ 或者 $ 符号以外不能包含其他任何特殊字符</li>
</ol>
<p><strong>驼峰命名法</strong></p>
<figure><img src="http://img.geekyspace.cn/pictures/2025/202509092335719.png" alt="驼峰命名法" tabindex="0" loading="lazy"><figcaption>驼峰命名法</figcaption></figure>
<h3>存储单位与数据类型</h3>
<p><strong>常见存储单位换算</strong></p>
<p>数据必须首先在计算机内被表示，然后才能被计算机处理。计算机表示数据的部件主要是存储设备；而存储数据的具体单位是<strong>存储单元</strong>；因此，了解存储单元的结构是十分必要的。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">1</span> Byte（字节<span class="token punctuation">)</span><span class="token operator">=</span> <span class="token number">8</span> bit（位）
<span class="token number">1</span> KB <span class="token operator">=</span> <span class="token number">1024</span> Byte
<span class="token number">1</span> MB <span class="token operator">=</span> <span class="token number">1024</span> KB
<span class="token number">1</span> GB <span class="token operator">=</span> <span class="token number">1024</span> MB
<span class="token number">1</span> TB <span class="token operator">=</span> <span class="token number">1024</span> GB
<span class="token number">1</span> PB <span class="token operator">=</span> <span class="token number">1024</span> TB
<span class="token number">1</span> EB <span class="token operator">=</span> <span class="token number">1024</span> PB
<span class="token number">1</span> ZB <span class="token operator">=</span> <span class="token number">1024</span> EB
</code></pre></div><ul>
<li>计算机中存储设备的最小单元叫”位（bit）”，又称为“比特位”，用小写字母b表示。</li>
<li>计算机中最小存储单元叫”字节（byte）”，用大写字母B表示，字节由8个位组成。</li>
</ul>
<p><strong>Java中的数据类型</strong></p>
<p>Java语言是强类型语言，对于每一个数据都给出明确的数据类型，不同的数据类型也分配了不同的内存空间，所以它们表示的数据大小也是不一样的。
<img src="http://img.geekyspace.cn/pictures/2025/202509092337025.png" alt="Java数据类型" loading="lazy"></p>
<p>| <strong>数据类型</strong> | <strong>类型</strong>         | <strong>内存占用</strong> | <strong>取值范围</strong>                                                         |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/202509092327337.png" type="image/png"/>
    </item>
    <item>
      <title>Node.js版本管理神器—nvm</title>
      <link>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/nvm.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/nvm.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Node.js版本管理神器—nvm</source>
      <description>Node.js版本管理神器—nvm 主要官方来源：nvm Github nvm是 node.js 的版本管理器，允许您通过命令行快速安装和使用不同版本的 node。 安装nvm 手动下载并运行 安装脚本，或使用命令行安装（cURL 或 Wget）： 脚本会自动配置环境变量（~/.zshrc下）： 自行修改后，需执行 source ~/.zshrc 验证...</description>
      <category>包管理器</category>
      <pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>主要官方来源：<a href="https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating" target="_blank" rel="noopener noreferrer">nvm Github</a></p>
<blockquote>
<p><code>nvm</code>是 <a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener noreferrer">node.js</a> 的版本管理器，允许您通过命令行快速安装和使用不同版本的 node。</p>
</blockquote>
<h2>安装nvm</h2>
<p>手动下载并运行 <a href="https://github.com/nvm-sh/nvm/blob/v0.40.2/install.sh" target="_blank" rel="noopener noreferrer">安装脚本</a>，或使用<strong>命令行安装</strong>（<code>cURL</code> 或 <code>Wget</code>）：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 使用 curl 安装</span>
<span class="token function">curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span>

<span class="token comment"># 使用 wget 安装</span>
<span class="token function">wget</span> -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span>
</code></pre></div><p>脚本会自动<strong>配置环境变量</strong>（<code>~/.zshrc</code>下）：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # 加载 nvm
[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # 加载 nvm bash_completion
</code></pre></div><ul>
<li>自行修改后，需执行 <code>source ~/.zshrc</code></li>
</ul>
<p><strong>验证安装</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm <span class="token parameter variable">--version</span>
</code></pre></div><blockquote>
<p>注意：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer">nvm</a> 的维护者明确表示 <code>brew</code> 不是官方推荐的安装方式。</p>
</blockquote>
<h2>使用指南</h2>
<h3>查看所有可用版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm ls-remote <span class="token parameter variable">--lts</span>   <span class="token comment"># 查看所有长期支持 (LTS) 版本</span>
nvm ls-remote         <span class="token comment"># 查看所有可用版本</span>
</code></pre></div><h3>安装</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm <span class="token function">install</span> <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>    <span class="token comment"># 安装指定版本（如 nvm install 20）</span>
nvm <span class="token function">install</span> <span class="token parameter variable">--lts</span>        <span class="token comment"># 安装最新的 LTS 版本</span>
nvm <span class="token function">install</span> <span class="token function">node</span>         <span class="token comment"># 安装最新的稳定版本</span>
</code></pre></div><h3>切换版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm use <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>    <span class="token comment"># 切换到指定版本（如 nvm use 16）</span>
nvm use default      <span class="token comment"># 切换到默认版本</span>
</code></pre></div><h3>设置默认版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm <span class="token builtin class-name">alias</span> default <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>   <span class="token comment"># 设置默认版本（如 nvm alias default 18）</span>
</code></pre></div><h3>列出已安装的版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm list      <span class="token comment"># 列出本地已安装的 Node.js 版本</span>
nvm <span class="token function">ls</span>        <span class="token comment"># 同上，显示已安装的版本</span>
</code></pre></div><h3>当前版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">node</span> <span class="token parameter variable">-v</span>     <span class="token comment"># 显示当前 Node.js 版本</span>
nvm current <span class="token comment"># 显示当前 NVM 管理的 Node.js 版本</span>
</code></pre></div><h3>卸载</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nvm uninstall <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>   <span class="token comment"># 卸载指定版本（如 nvm uninstall 16）</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>[object Object]</title>
      <link>https://www.geekyspace.cn/md/template/blog%20template.html</link>
      <guid>https://www.geekyspace.cn/md/template/blog%20template.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">[object Object]</source>
      <description>{{title}} {{title}}</description>
      <category>Blog</category>
      <pubDate>Sun, 16 Mar 2025 18:25:20 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>{{title}}</h2>
]]></content:encoded>
    </item>
    <item>
      <title>npm源切换加速利器—nrm</title>
      <link>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/nrm.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/nrm.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">npm源切换加速利器—nrm</source>
      <description>npm源切换加速利器—nrm 主要官方来源：npmjs-nrm nrm可以帮助您轻松快速地切换不同的 npm 注册表。它支持 npm 、 cnpm 、 taobao 、 yarn 、 tencent 、 npmMirror和huawei 。 安装nrm 安装成功后，使用nrm --version查看命令，验证是否安装正常。 使用指南 nrm ls 查看...</description>
      <category>包管理器</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>主要官方来源：<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="noopener noreferrer">npmjs-nrm</a></p>
<blockquote>
<p><code>nrm</code>可以帮助您轻松快速地切换不同的 npm 注册表。它支持&nbsp;<code>npm</code>&nbsp;、&nbsp;<code>cnpm</code>&nbsp;、&nbsp;<code>taobao</code>&nbsp;、&nbsp;<code>yarn</code>&nbsp;、&nbsp;<code>tencent</code>&nbsp;、&nbsp;<code>npmMirror</code>和<code>huawei</code>&nbsp;。</p>
</blockquote>
<h2>安装nrm</h2>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># npm 安装</span>
<span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> nrm
</code></pre></div><p>安装成功后，使用<code>nrm --version</code>查看命令，验证是否安装正常。</p>
<h2>使用指南</h2>
<h3>nrm ls</h3>
<p>查看源列表</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ nrm <span class="token function">ls</span>

* <span class="token function">npm</span> </code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Java生态版本管理神器—SDKMAN</title>
      <link>https://www.geekyspace.cn/md/installation-guide/dev-env/java/SDKMAN.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/dev-env/java/SDKMAN.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java生态版本管理神器—SDKMAN</source>
      <description>Java生态版本管理神器—SDKMAN 主要官方来源：SDKMAN官网 | Github SDKMAN! 是一个轻量级、支持多平台，开源的，用于管理多个 SDK（如 Java、Kotlin、Gradle、Maven 等）的工具。 安装SDKMAN 安装 SDKMAN! 只需启动一个新终端并输入： 初始化并配置环境变量 按照屏幕上的说明完成安装。然后，打...</description>
      <category>包管理器</category>
      <pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>主要官方来源：<a href="https://sdkman.io/" target="_blank" rel="noopener noreferrer">SDKMAN官网</a> | <a href="https://github.com/sdkman" target="_blank" rel="noopener noreferrer">Github</a></p>
<blockquote>
<p>SDKMAN! 是一个轻量级、支持多平台，开源的，用于管理多个 SDK（如 <code>Java</code>、<code>Kotlin</code>、<code>Gradle</code>、<code>Maven</code> 等）的工具。</p>
</blockquote>
<h2>安装SDKMAN</h2>
<p><strong>安装 SDKMAN!</strong></p>
<ul>
<li>只需启动一个新终端并输入：</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token string">"https://get.sdkman.io"</span> <span class="token operator">|</span> <span class="token function">bash</span>
</code></pre></div><p><strong>初始化并配置环境变量</strong></p>
<ul>
<li>按照屏幕上的说明完成安装。然后，打开一个新终端或在同一 shell 中运行以下命令：</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">source</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.sdkman/bin/sdkman-init.sh"</span>
</code></pre></div><p>最后，运行以下代码片段来确认安装成功：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk version
</code></pre></div><p>您应该看到包含最新脚本和本机版本的输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>SDKMAN<span class="token operator">!</span>
script: <span class="token number">5.19</span>.0
native: <span class="token number">0.6</span>.0 <span class="token punctuation">(</span>macos aarch64<span class="token punctuation">)</span>
</code></pre></div><h2>使用指南</h2>
<p>以下是基于 SDKMAN! 文档整理的&nbsp;<strong>Java SDK 管理命令及详细解释</strong>，按照使用流程排列：</p>
<h3>查看Java版本</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk list <span class="token function">java</span>
</code></pre></div><p>查看所有 <a href="https://sdkman.io/jdks" target="_blank" rel="noopener noreferrer">Java 发行版</a>（如 Zulu、AdoptOpenJDK、Amazon Corretto 等）及版本列表。
<img src="http://img.geekyspace.cn/pictures/2025/20250313021115034.png" alt="sdk list java" loading="lazy"></p>
<ul>
<li><strong>关键字段</strong>：<code>Identifier</code>&nbsp;是安装时使用的唯一标识符（如&nbsp;<code>21.0.6-tem</code>）。</li>
</ul>
<h3>JDK的安装与卸载</h3>
<p><strong>安装指定版本的 Java</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk <span class="token function">install</span> <span class="token function">java</span> <span class="token variable">$Identifier</span>
</code></pre></div><ul>
<li>如果不输入<code>$Identifier</code>的话，会自动安装最新的稳定版本。</li>
<li>Eclipse Temurin 作为默认 JDK，因为它被广泛认为是 OpenJDK 发行版的事实标准。</li>
</ul>
<p><strong>卸载已安装的 Java 版本</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk uninstall <span class="token function">java</span> <span class="token variable">$Identifier</span>
</code></pre></div><h3>JDK版本管理</h3>
<p><strong>切换 Java 版本（当前会话有效）</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk use <span class="token function">java</span> <span class="token variable">$Identifier</span>
</code></pre></div><p><strong>设置全局默认 Java 版本</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk default <span class="token function">java</span> <span class="token variable">$Identifier</span>
</code></pre></div><p><strong>查看当前 Java 版本</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>sdk current <span class="token function">java</span>
</code></pre></div>]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/20250313021115034.png" type="image/png"/>
    </item>
    <item>
      <title>Corepack核心包管理工具</title>
      <link>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/Corepack.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/dev-env/nodejs/Corepack.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Corepack核心包管理工具</source>
      <description>Corepack核心包管理工具 主要官方来源：Nodejs官网文档 | Github Corepack 作为一个内置于 Node.js 工具，为开发者解决了包管理器（Yarn、npm 和 pnpm ）版本不一致和兼容性问题。 安装Corepack 从 Node.js 16.x 开始，Corepack 已经内置在 Node.js 中，所以只要安装 Nod...</description>
      <category>包管理器</category>
      <pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>主要官方来源：<a href="https://nodejs.org/api/corepack.html" target="_blank" rel="noopener noreferrer">Nodejs官网文档</a> |  <a href="https://github.com/nodejs/corepack" target="_blank" rel="noopener noreferrer">Github</a></p>
<blockquote>
<p>Corepack 作为一个内置于 Node.js 工具，为开发者解决了包管理器（<code>Yarn</code>、<code>npm</code> 和 <code>pnpm</code> ）版本不一致和兼容性问题。</p>
</blockquote>
<h2>安装Corepack</h2>
<p>从 Node.js 16.x 开始，Corepack 已经内置在 Node.js 中，所以只要安装 Node.js，就可以直接使用 Corepack。如果需要手动安装，可以参考 <a href="https://github.com/nodejs/corepack?tab=readme-ov-file#manual-installs" target="_blank" rel="noopener noreferrer">Github 官方文档</a>。
<strong>验证安装</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>corepack <span class="token parameter variable">-v</span>
</code></pre></div><p><strong>Corepack更新</strong></p>
<ul>
<li>用于解决&nbsp;<a href="https://github.com/nodejs/corepack/issues/612" target="_blank" rel="noopener noreferrer">Corepack 中的签名过时</a>&nbsp;问题</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--global</span> corepack@latest
</code></pre></div><h2>启用/禁用 Corepack</h2>
<ul>
<li><a href="https://github.com/nodejs/corepack" target="_blank" rel="noopener noreferrer">Corepack</a> 默认是实验性工具，需要手动启用。</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 启用</span>
corepack <span class="token builtin class-name">enable</span>
</code></pre></div><p>启用后，它会自动为你管理所需的包管理器版本。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 禁用</span>
corepack disable
</code></pre></div><h2>管理包管理器的版本</h2>
<p>Corepack 使得你能够轻松管理不同版本的包管理器。比如你可以为项目指定特定版本的 <code>npm</code>、<code>Yarn</code> 或 <code>pnpm</code>。</p>
<h3><a class="header-anchor" href="#安装pnpm"><span>安装</span></a><a href="https://pnpm.io/zh/" target="_blank" rel="noopener noreferrer">pnpm</a></h3>
<blockquote>
<p>快速的，节省磁盘空间的包管理工具。pnpm 比 npm 快 2 倍。</p>
</blockquote>
<p><strong>安装并启用：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>corepack prepare pnpm@latest <span class="token parameter variable">--activate</span>
</code></pre></div><p><strong>验证安装：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">pnpm</span> <span class="token parameter variable">--version</span>
</code></pre></div><p><strong>固定项目使用的版本：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>corepack use pnpm@latest-10
</code></pre></div><p>这会将 <code>pnpm</code> 的版本信息添加到 <code>package.json</code> 中的 <code>packageManager</code> 字段。</p>
<h3><a class="header-anchor" href="#安装yarn"><span>安装</span></a><a href="https://yarnpkg.com/" target="_blank" rel="noopener noreferrer">Yarn</a></h3>
<p><a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener noreferrer">Github</a></p>
<blockquote>
<p>Yarn 是 Facebook 开发的一个快速、安全、稳定的包管理器，特别适用于大型项目。</p>
</blockquote>
<p><strong>安装并启用：</strong></p>
<ul>
<li>稳定版本：1.22.22</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>corepack prepare yarn@1.22.22 <span class="token parameter variable">--activate</span>
</code></pre></div><p><strong>验证安装：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">yarn</span> <span class="token parameter variable">--version</span>
</code></pre></div><p><strong>固定项目使用的版本：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>corepack use yarn@1.22.22
</code></pre></div><p>在 <code>package.json</code> 中，会看到类似以下内容：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">{</span>
  <span class="token string">"packageManager"</span><span class="token builtin class-name">:</span> <span class="token string">"yarn@1.22.22"</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，Corepack 会根据该配置自动管理 Yarn 的版本。</p>
]]></content:encoded>
    </item>
    <item>
      <title>macOS必备包管理工具—Homebrew</title>
      <link>https://www.geekyspace.cn/md/installation-guide/base-tools/Homebrew.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/base-tools/Homebrew.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">macOS必备包管理工具—Homebrew</source>
      <description>macOS必备包管理工具—Homebrew 主要官方来源：Homebrew官网 | Github Homebrew 是 macOS 和 Linux 上的包管理器，可以帮助用户轻松安装和管理各种软件包。 安装Homebrew 官网脚本 安装Homebrew安装Homebrew 安装 Homebrew 将以下命令粘贴至终端： 运行此命令将安装最新版本的Ho...</description>
      <category>包管理器</category>
      <pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>主要官方来源：<a href="https://brew.sh/zh-cn/" target="_blank" rel="noopener noreferrer">Homebrew官网</a> |  <a href="https://github.com/homebrew" target="_blank" rel="noopener noreferrer">Github</a></p>
<blockquote>
<p>Homebrew 是 macOS 和 Linux 上的包管理器，可以帮助用户轻松安装和管理各种软件包。</p>
</blockquote>
<h2>安装Homebrew</h2>
<h3>官网脚本</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2025/20250312024222153.png" alt="安装Homebrew" tabindex="0" loading="lazy"><figcaption>安装Homebrew</figcaption></figure>
<p><strong>安装 Homebrew</strong></p>
<p>将以下命令粘贴至终端：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>/bin/bash <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="token variable">)</span></span>"</span>
</code></pre></div><p>运行此命令将安装最新版本的Homebrew，自动处理MacOS环境中<code>Xcode Command Tools</code>的安装。</p>
<ul>
<li><strong><code>git</code></strong>（用于版本控制，拉取 Homebrew 软件包）</li>
<li><strong><code>gcc</code> / <code>clang</code></strong>（用于编译部分软件包）</li>
<li><strong><code>make</code></strong>（用于构建和安装依赖）</li>
</ul>
<p>安装完成后，按照终端提示，添加 Homebrew 环境环境变量到 <code>.zprofile</code> 或 <code>.bash_profile</code>。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token string">'eval "$(/opt/homebrew/bin/brew shellenv)"'</span> <span class="token operator">&gt;&gt;</span> ~/.zprofile
<span class="token builtin class-name">source</span> ~/.zprofile
</code></pre></div><p><strong>卸载 Homebrew</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>/bin/bash <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh<span class="token variable">)</span></span>"</span>
</code></pre></div><p><strong>验证 Homebrew 安装</strong>
安装完成后，可以运行以下命令来检查 Homebrew 是否正确安装：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>brew <span class="token parameter variable">--version</span>
</code></pre></div><h3>国内脚本</h3>
<p>由于国内网络访问 GitHub 可能较慢，可以使用国内的 Homebrew 安装脚本，加快安装速度。
<strong>安装步骤</strong></p>
<ol>
<li>访问 <a href="https://gitee.com/cunkai/HomebrewCN" target="_blank" rel="noopener noreferrer">HomebrewCN</a>。</li>
<li>按照说明执行相应的安装命令。</li>
</ol>
<h3>.pkg包（macOS）</h3>
<p>如果您使用的是 macOS，并希望通过图形化方式安装 Homebrew，可以使用官方提供的 <code>.pkg</code> 安装器。
<strong>安装步骤：</strong></p>
<ol>
<li>访问 <a href="https://github.com/Homebrew/brew/releases/latest" target="_blank" rel="noopener noreferrer">Homebrew 最新 GitHub 发行版</a>。</li>
<li>下载 <code>.pkg</code> 文件。</li>
<li>双击安装并按照提示完成安装。</li>
</ol>
<h2>使用指南</h2>
<p>以下是一些常见的 Homebrew 命令：</p>
<p>| 操作               | 命令                                  |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2025/20250312024222153.png" type="image/png"/>
    </item>
    <item>
      <title>Top20常用命令</title>
      <link>https://www.geekyspace.cn/md/docker/top20-commands.html</link>
      <guid>https://www.geekyspace.cn/md/docker/top20-commands.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Top20常用命令</source>
      <description>Top20常用命令 作为一款领先的容器化工具，Docker 提供了强大的功能，让开发者和运维人员能够快速构建、部署和管理应用。 在这篇文章中，我们将介绍 20 条最常用的 Docker 命令，并结合详细说明，帮助大家轻松掌握 Docker 的基本操作。 1. Docker version 2. Docker search 3. Docker pull ...</description>
      <category>Docker</category>
      <pubDate>Sat, 23 Nov 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>作为一款领先的容器化工具，Docker 提供了强大的功能，让开发者和运维人员能够快速构建、部署和管理应用。
在这篇文章中，我们将介绍 20 条最常用的 Docker 命令，并结合详细说明，帮助大家轻松掌握 Docker 的基本操作。</p>
<ul>
<li><a href="#docker-version">1. Docker version</a></li>
<li><a href="#docker-search">2. Docker search</a></li>
<li><a href="#docker-pull">3. Docker pull</a></li>
<li><a href="#docker-run">4. Docker run</a></li>
<li><a href="#docker-ps">5. Docker ps</a></li>
<li><a href="#docker-stop">6. Docker stop</a></li>
<li><a href="#docker-restart">7. Docker restart</a></li>
<li><a href="#docker-kill">8. Docker kill</a></li>
<li><a href="#docker-exec">9. Docker exec</a></li>
<li><a href="#docker-login">10. Docker login</a></li>
<li><a href="#docker-commit">11. Docker commit</a></li>
<li><a href="#docker-push">12. Docker push</a></li>
<li><a href="#docker-network">13. Docker network</a></li>
<li><a href="#docker-history">14. Docker history</a></li>
<li><a href="#docker-rmi">15. Docker rmi</a></li>
<li><a href="#docker-ps--a">16. Docker ps -a</a></li>
<li><a href="#docker-copy">17. Docker copy</a></li>
<li><a href="#docker-logs">18. Docker logs</a></li>
<li><a href="#docker-volume">19. Docker volume</a></li>
<li><a href="#docker-logout">20. Docker logout</a></li>
</ul>
<p><strong>相关文档</strong></p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener noreferrer">Docker 命令参考文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/?spm=5176.8351553.0.0.4ef81991wFvDZm" target="_blank" rel="noopener noreferrer">Dockerfile 镜像构建参考文档</a></li>
</ul>
<h2>Docker version</h2>
<p>用途：显示 Docker 的版本信息。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> version
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202411231416702.png" alt="docker version" tabindex="0" loading="lazy"><figcaption>docker version</figcaption></figure>
<h2>Docker search</h2>
<p>用途: 用于搜索 Docker Hub 上的镜像。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> search nginx
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202411231425169.png" alt="docker search nginx" tabindex="0" loading="lazy"><figcaption>docker search nginx</figcaption></figure>
<h2>Docker pull</h2>
<p>用途：从 Docker Hub 下载镜像。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull nginx
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202411231427300.png" alt="docker pull nginx" tabindex="0" loading="lazy"><figcaption>docker pull nginx</figcaption></figure>
<h2>Docker run</h2>
<p>用途：运行一个镜像，并创建一个容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> my-mysql <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root <span class="token parameter variable">-p</span> <span class="token number">3307</span>:3306 mysql:8.0
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>-d</code>：后台运行容器，并返回 Shell。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=root</code>：设置环境变量，用于设置 MySQL 的 root 用户密码。</li>
<li><code>-p 3306:3306</code>：将主机的端口 3306 映射到容器的端口 3306。</li>
<li><code>mysql:8.0</code>：要下载的镜像的名称。</li>
</ul>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202411231444798.png" alt="docker run mysql" tabindex="0" loading="lazy"><figcaption>docker run mysql</figcaption></figure>
<h2>Docker ps</h2>
<p>用途：列出当前正在运行的容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span>
</code></pre></div><h2>Docker stop</h2>
<p>用途：停止一个正在运行的容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> stop <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
</code></pre></div><h2>Docker restart</h2>
<p>用途：重启一个容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> restart <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
</code></pre></div><h2>Docker kill</h2>
<p>用途：强制停止一个容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">kill</span> <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
</code></pre></div><h2>Docker exec</h2>
<p>用途：在运行中的容器中执行命令。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span> <span class="token function">bash</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>-it</code>：保持 STDIN 打开并允许使用键盘输入。</li>
<li><code>&lt;container_id&gt;</code>：要进入的容器的ID。</li>
<li><code>bash</code>：要执行的命令。</li>
</ul>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202411231506412.png" alt="docker exec -it <container_id> bash" tabindex="0" loading="lazy"><figcaption>docker exec -it &lt;container_id&gt; bash</figcaption></figure>
<h2>Docker login</h2>
<p>用途：登录 Docker Hub，用于推送私有镜像。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> login
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202411231511727.png" alt="docker login" tabindex="0" loading="lazy"><figcaption>docker login</figcaption></figure>
<h2>Docker commit</h2>
<p>用途：创建一个镜像，该镜像包含一个容器的当前状态。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image_name<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;container_id&gt;</code>：要提交为镜像的容器的ID。</li>
<li><code>&lt;image_name&gt;</code>：新镜像的名称。</li>
</ul>
<h2>Docker push</h2>
<p>用途：将镜像推送到 Docker Hub。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> push <span class="token operator">&lt;</span>image_name<span class="token operator">&gt;</span>
</code></pre></div><h2>Docker network</h2>
<p>用途：管理 Docker 网络。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> network create <span class="token operator">&lt;</span>network_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> network inspect <span class="token operator">&lt;</span>network_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> network <span class="token function">rm</span> <span class="token operator">&lt;</span>network_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> network connect <span class="token operator">&lt;</span>network_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
<span class="token function">docker</span> network disconnect <span class="token operator">&lt;</span>network_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;network_name&gt;</code>：要创建、查看、删除或连接的 Docker 网络的名称。</li>
<li><code>&lt;container_id&gt;</code>：要连接到或断开连接的网络的容器的ID。</li>
</ul>
<h2>Docker history</h2>
<p>用途：显示镜像的创建历史。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">history</span> <span class="token operator">&lt;</span>image_name<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;image_name&gt;</code>：要查看其创建历史的镜像的名称。</li>
</ul>
<h2>Docker rmi</h2>
<p>用途：删除镜像。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi <span class="token operator">&lt;</span>image_id<span class="token operator">&gt;</span>
</code></pre></div><h2>Docker ps -a</h2>
<p>用途：列出所有容器，包括已停止的容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202411231500573.png" alt="docker ps -a" tabindex="0" loading="lazy"><figcaption>docker ps -a</figcaption></figure>
<h2>Docker copy</h2>
<p>用途：复制文件或文件夹到容器。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>host_path<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container_path<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;host_path&gt;</code>：主机上的文件或文件夹的路径。</li>
<li><code>&lt;container_id&gt;</code>：要复制文件的容器的ID。</li>
<li><code>&lt;container_path&gt;</code>：容器内的目标路径。</li>
</ul>
<h2>Docker logs</h2>
<p>用途：查看容器的日志。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> logs <span class="token operator">&lt;</span>container_id<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;container_id&gt;</code>：要查看其日志的容器的ID。</li>
</ul>
<h2>Docker volume</h2>
<p>用途：管理 Docker 卷。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create <span class="token operator">&lt;</span>volume_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> volume inspect <span class="token operator">&lt;</span>volume_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> volume <span class="token function">rm</span> <span class="token operator">&lt;</span>volume_name<span class="token operator">&gt;</span>
<span class="token function">docker</span> run <span class="token parameter variable">-v</span> <span class="token operator">&lt;</span>volume_name<span class="token operator">&gt;</span>:/data nginx
</code></pre></div><p>参数解释：</p>
<ul>
<li><code>&lt;volume_name&gt;</code>：要创建、查看或删除的卷的名称。</li>
<li><code>nginx</code>：要运行的镜像名称。</li>
<li><code>/data</code>：要挂载到容器内的卷的挂载点。</li>
</ul>
<h2>Docker logout</h2>
<p>用途：注销 Docker Hub。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">logout</span>
</code></pre></div>]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/202411231416702.png" type="image/png"/>
    </item>
    <item>
      <title>Docker安装</title>
      <link>https://www.geekyspace.cn/md/docker/install.html</link>
      <guid>https://www.geekyspace.cn/md/docker/install.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Docker安装</source>
      <description>Docker安装&amp;配置 您可以在多个平台上下载并安装 Docker。请参阅以下部分并选择最适合您的安装路径。 适用于Mac的Docker桌面 适用于Windows的Docker桌面 适用于Linux的Docker桌面 验证是否安装成功： 运行测试镜像 可能会遇到如下网络错误，这个时候就需要配置 docker: error pulling image c...</description>
      <category>Docker</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>您可以在多个平台上下载并安装 Docker。请参阅以下部分并选择最适合您的安装路径。</p>
<blockquote>
<p><a href="https://docs.docker.com/desktop/setup/install/mac-install/" target="_blank" rel="noopener noreferrer">适用于Mac的Docker桌面</a></p>
</blockquote>
<blockquote>
<p><a href="https://docs.docker.com/desktop/setup/install/windows-install/" target="_blank" rel="noopener noreferrer">适用于Windows的Docker桌面</a></p>
</blockquote>
<blockquote>
<p><a href="https://docs.docker.com/desktop/setup/install/linux/" target="_blank" rel="noopener noreferrer">适用于Linux的Docker桌面</a></p>
</blockquote>
<p><strong>验证是否安装成功：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> version           <span class="token comment"># 查看版本</span>
$ <span class="token function">docker</span> info              <span class="token comment"># 查看信息</span>
</code></pre></div><p><strong>运行测试镜像</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">docker</span> run hello-world
$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu <span class="token function">bash</span>  
</code></pre></div><p>可能会遇到如下网络错误，这个时候就需要配置<a href="/md/docker/mirror-acceleration.html" target="_blank">镜像源加速器</a></p>
<p><code>docker: error pulling image configuration: download failed after attempts=6: EOF.</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker镜像加速器</title>
      <link>https://www.geekyspace.cn/md/docker/mirror-acceleration.html</link>
      <guid>https://www.geekyspace.cn/md/docker/mirror-acceleration.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Docker镜像加速器</source>
      <description>Docker镜像加速器 国内从Docker Hub拉取镜像有时会遇到困难，此时可以配置镜像加速器。 阿里云镜像加速器 阿里云镜像加速器，有针对Ubuntu，CentOS，Mac，Windows的操作文档 阿里云镜像加速器阿里云镜像加速器 Linux 对于使用Ubuntu或CentOS的系统，请在/etc/docker/daemon.json文件中写入如...</description>
      <category>Docker</category>
      <pubDate>Sat, 16 Nov 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>国内从<code>Docker Hub</code>拉取镜像有时会遇到困难，此时可以配置镜像加速器。</p>
<h2>阿里云镜像加速器</h2>
<blockquote>
<p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener noreferrer">阿里云镜像加速器</a>，有针对<code>Ubuntu</code>，<code>CentOS</code>，<code>Mac</code>，<code>Windows</code>的操作文档</p>
</blockquote>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202411270006564.png" alt="阿里云镜像加速器" tabindex="0" loading="lazy"><figcaption>阿里云镜像加速器</figcaption></figure>
<h2>Linux</h2>
<p>对于使用<code>Ubuntu</code>或<code>CentOS</code>的系统，请在<code>/etc/docker/daemon.json</code>文件中写入如下内容（如果文件不存
在请新建该文件）</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker
<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
{
  "registry-mirrors": ["https://onnxqmp4.mirror.aliyuncs.com"]
}
EOF</span>

<span class="token comment"># 之后重新启动服务</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre></div><h2>Windows</h2>
<p>对于使用Windows的系统，在<code>docker desktop</code>右上角<strong>齿轮</strong>图标，打开配置窗口后选择<code>Docker Engine</code>。<br>
编辑JSON串，填写加速器地址：</p>
<p>Windows: <code>%USERPROFILE%\.docker\daemon.json</code></p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202411160051539.png" alt="Windows配置镜像加速" tabindex="0" loading="lazy"><figcaption>Windows配置镜像加速</figcaption></figure>
<p><strong>完整的<code>daemon.json</code>配置示例：</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">{</span>
  <span class="token string">"builder"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
    <span class="token string">"gc"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
      <span class="token string">"defaultKeepStorage"</span><span class="token builtin class-name">:</span> <span class="token string">"20GB"</span>,
      <span class="token string">"enabled"</span><span class="token builtin class-name">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  <span class="token string">"experimental"</span><span class="token builtin class-name">:</span> false,
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://onnxqmp4.mirror.aliyuncs.com"</span>,
    <span class="token string">"https://docker.hpcloud.cloud"</span>,
    <span class="token string">"https://docker.m.daocloud.io"</span>,
    <span class="token string">"https://docker.1panel.live"</span>,
    <span class="token string">"http://mirrors.ustc.edu.cn"</span>,
    <span class="token string">"https://docker.chenby.cn"</span>,
    <span class="token string">"https://docker.ckyl.me"</span>,
    <span class="token string">"http://mirror.azure.cn"</span>,
    <span class="token string">"https://hub.rat.dev"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>MacOS</h2>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202412041859454.png" alt="MacOS配置Docker镜像加速器" tabindex="0" loading="lazy"><figcaption>MacOS配置Docker镜像加速器</figcaption></figure>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/202411270006564.png" type="image/png"/>
    </item>
    <item>
      <title>Docker概述</title>
      <link>https://www.geekyspace.cn/md/docker/overview.html</link>
      <guid>https://www.geekyspace.cn/md/docker/overview.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Docker概述</source>
      <description>Docker概述 什么是Docker？ Docker是dotCloud团队在2013年发布的开源项目。 使用Go语言开发，是一个轻量级的虚拟机容器解决方案。 为什么使用Docker？ Docker跟传统虚拟机相比，具有以下优势： 更高效的利用系统资源 更快速的启动速度 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 Docker VS...</description>
      <category>Docker</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>什么是Docker？</h2>
<p><code>Docker</code>是<code>dotCloud</code>团队在2013年发布的开源项目。 使用<code>Go</code>语言开发，是一个轻量级的虚拟机容器解决方案。</p>
<h2>为什么使用Docker？</h2>
<p>Docker跟传统虚拟机相比，具有以下优势：</p>
<ul>
<li>更高效的利用系统资源</li>
<li>更快速的启动速度</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ul>
<p><strong><code>Docker</code> VS <code>传统虚拟机</code></strong></p>
<p>| 特性    | 容器        | 虚拟机    |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/202411152359021.png" type="image/png"/>
    </item>
    <item>
      <title>个人简介</title>
      <link>https://www.geekyspace.cn/about-me.html</link>
      <guid>https://www.geekyspace.cn/about-me.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">个人简介</source>
      <description>一个专注于技术分享的博客网站</description>
      <category>程序人生</category>
      <pubDate>Mon, 14 Dec 1998 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>欢迎访问我的博客网站 <a href="www.geekyspace.cn">www.geekyspace.cn</a>，与我一起探索科技的未来！</p>
<p>本博客维护人周宇，在Java和相关技术领域拥有多年的专业经验。
此前，我在深圳南山 <a href="https://www.liquido.com/" target="_blank" rel="noopener noreferrer">Liquido</a> 工作，这是一家专注于金融领域，
提供拉美地区<a href="https://mp.weixin.qq.com/s/UzPsaVvXqrvW8T8PDPnhZw" target="_blank" rel="noopener noreferrer">支付解决方案</a>的公司。</p>
<p><strong>贴上“程序员”标签</strong></p>
<ol>
<li>个人兴趣：我从小就对工科方向的工作非常感兴趣，喜欢倒腾电子产品，研究它们的原理，拆了又装。</li>
<li>家庭影响：我有一个“伢伢”，比我大10多岁，他学的就是计算机，赚钱也多。
他毕业后在一家电商公司工作，后来被京东收购，之后去了高德，又被阿里收购。在它的影响下，我最终成为了一名程序员。</li>
</ol>
<p><strong>程序员的价值体现</strong></p>
<p>做程序员是幸运的，世界的本质是价值交换。
作为程序员，我最大的成就感在于能否真正给别人带来价值。如果可以，那泰裤辣。
大环境没有那么差（给自己信心），这是程序员的时代！！！</p>
<ul>
<li>人生没有白走的路，每一步都算数（我要坚持坚持坚持）</li>
</ul>
<p><strong>我的程序员格言</strong></p>
<ol>
<li>编码原则：🥇 代码简洁高效，优雅永不过时 ✨</li>
<li>架构核心：🔧 掌握系统控制权，确保可扩展性和灵活性</li>
<li>技术理念：🌐 技术广度是技术深度的副产品</li>
<li>职业信仰：🚀 当坚持成为一种热爱，极致成为一种精神，那么成功就是一种必然</li>
<li>长期主义：⏳ 注重长远发展，坚持不懈地追求卓越</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>2025最新IntelliJ IDEA专业版稳定正版激活码</title>
      <link>https://www.geekyspace.cn/md/idea-tips/activation.html</link>
      <guid>https://www.geekyspace.cn/md/idea-tips/activation.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">2025最新IntelliJ IDEA专业版稳定正版激活码</source>
      <description>2025最新IntelliJ IDEA专业版稳定正版激活码 适用于Mac系统 仅支持官网专业版2020-2024的激活。不支持社区版 toolbox下载的IDEA。 1️⃣ 第一步：下载激活文件 激活文件获取 2️⃣ 第二步：打开激活文件 macjihuo.zip，解压缩 3️⃣ 第三步：&amp;quot;macjihuo&amp;quot;文件夹上右键，新建终端窗口 macjihuo...</description>
      <category>开发工具</category>
      <pubDate>Wed, 17 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>适用于Mac系统</h2>
<blockquote>
<p>仅支持官网专业版2020-2024的激活。不支持社区版 toolbox下载的IDEA。</p>
</blockquote>
<h3>1️⃣ 第一步：下载激活文件</h3>
<p><a href="https://h5.m.goofish.com/item?id=785250929165" target="_blank" rel="noopener noreferrer">激活文件获取</a></p>
<h3>2️⃣ 第二步：打开激活文件 <code>macjihuo.zip</code>，解压缩</h3>
<h3>3️⃣ 第三步："macjihuo"文件夹上右键，新建终端窗口</h3>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404171725739.png" alt="macjihuo" tabindex="0" loading="lazy"><figcaption>macjihuo</figcaption></figure>
<h3>4️⃣ 第三步：运行脚本，输入对应软件的命令-回车（看下图）</h3>
<p><mark>运行命令前：先打开你要激活的软件。然后关闭软件，最后输入命令激活软件哦。</mark></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>如果你要激活idea：     则输入 <span class="token function">sh</span> idea.sh
如果你要激活pycharm：  则输入 <span class="token function">sh</span> pycharm.sh
如果你要激活datagrip： 则输入 <span class="token function">sh</span> datagrip.sh
如果你要激活clion：    则输入 <span class="token function">sh</span> clion.sh
如果你要激活goland：   则输入 <span class="token function">sh</span> goland.sh
如果你要激活webstorm： 则输入 <span class="token function">sh</span> webstorm.sh
如果你要激活phpstorm： 则输入 <span class="token function">sh</span> phpstorm.sh
如果你要激活dataspell：则输入 <span class="token function">sh</span> dataspell.sh
如果你要激活rider：    则输入 <span class="token function">sh</span> rider.sh
</code></pre></div><figure><img src="http://img.geekyspace.cn/pictures/2024/202404171714345.png" alt="Success" tabindex="0" loading="lazy"><figcaption>Success</figcaption></figure>
<h2>适用于Windows系统</h2>
<blockquote>
<p>仅支持官网专业版2020-2024的激活。不支持社区版 toolbox下载的</p>
</blockquote>
<h3>1️⃣ 第一步：下载激活文件</h3>
<p><a href="https://h5.m.goofish.com/item?id=785250929165" target="_blank" rel="noopener noreferrer">激活文件获取</a></p>
<h3>2️⃣ 第二步：解压下载的压缩包</h3>
<h3>3️⃣ 第三步：打开解压的“<code>激活码-Win系统</code>”文件夹，</h3>
<p>双击要激活软件的vbs</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404171718775.png" alt="Double-click" tabindex="0" loading="lazy"><figcaption>Double-click</figcaption></figure>
<p><strong>♦♦比如：</strong></p>
<ul>
<li>要激活pycharm，就运行 pycharm激活.vbs</li>
<li>要激活IDEA，就运行 IDEA激活.vbs</li>
</ul>
<p>等待出现 如下 <code>Success</code> 提示，再次打开软件即可正常使用！</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404171718903.png" alt="Success" tabindex="0" loading="lazy"><figcaption>Success</figcaption></figure>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/202404171725739.png" type="image/png"/>
    </item>
    <item>
      <title>开发者安装大全</title>
      <link>https://www.geekyspace.cn/md/installation-guide/</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">开发者安装大全</source>
      <description>开发者安装大全 该专栏主要整理与汇总开发者常用的编程环境、中间件等工具的安装，以指导开发者快速搭建自己的需要的开发环境。</description>
      <category>软件安装</category>
      <pubDate>Tue, 23 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>该专栏主要整理与汇总开发者常用的编程环境、中间件等工具的安装，以指导开发者快速搭建自己的需要的开发环境。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring Boot 入门教程</title>
      <link>https://www.geekyspace.cn/md/spring-boot/</link>
      <guid>https://www.geekyspace.cn/md/spring-boot/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring Boot 入门教程</source>
      <description>Spring Boot 教程</description>
      <category>Spring Boot</category>
      <pubDate>Fri, 15 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot 快速入门</title>
      <link>https://www.geekyspace.cn/md/spring-boot/quickstart.html</link>
      <guid>https://www.geekyspace.cn/md/spring-boot/quickstart.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">SpringBoot 快速入门</source>
      <description>SpringBoot 快速入门</description>
      <category>Spring Boot</category>
      <pubDate>Fri, 15 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>Spring Data JPA</title>
      <link>https://www.geekyspace.cn/md/spring-data-jpa/</link>
      <guid>https://www.geekyspace.cn/md/spring-data-jpa/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring Data JPA</source>
      <description>Spring Data JPA 目录 Spring Data JPA 快速入门</description>
      <category>Spring Data</category>
      <pubDate>Thu, 04 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>目录</h2>
<ul>
<li><a href="/spring-data-jpa/jetbrains/getting-started">Spring Data JPA 快速入门</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Windows、Office激活密钥，脚本，程序</title>
      <link>https://www.geekyspace.cn/md/installation-guide/os/windows-office-activation.html</link>
      <guid>https://www.geekyspace.cn/md/installation-guide/os/windows-office-activation.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Windows、Office激活密钥，脚本，程序</source>
      <description>Windows、Office激活密钥，脚本，程序 ① 微软正版秘钥（官方） 01.Windows系统激活 Win+R 打开终端，输入命令 打开“系统激活”窗口，点击“更改”按钮 更改产品密钥更改产品密钥 输入“秘钥”，点击“下一页” 进行 “激活” ！获取 微软Windows官方正版秘钥 输入产品密钥输入产品密钥 “激活”成功 Windows官方密钥激...</description>
      <category>激活</category>
      <pubDate>Tue, 23 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>① 微软正版秘钥（官方）</h2>
<h3>01.Windows系统激活</h3>
<ol>
<li><code>Win+R</code> 打开终端，输入命令</li>
</ol>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>slui <span class="token number">3</span>
</code></pre></div><ol start="2">
<li>打开“系统激活”窗口，点击“更改”按钮</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232040995.png" alt="更改产品密钥" tabindex="0" loading="lazy"><figcaption>更改产品密钥</figcaption></figure>
<ol start="3">
<li>输入“秘钥”，点击“下一页” 进行 “激活” ！获取 <a href="https://learn.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys" target="_blank" rel="noopener noreferrer">微软Windows官方正版秘钥</a></li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232318292.png" alt="输入产品密钥" tabindex="0" loading="lazy"><figcaption>输入产品密钥</figcaption></figure>
<ol start="4">
<li>“激活”成功</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232327475.png" alt="Windows官方密钥激活" tabindex="0" loading="lazy"><figcaption>Windows官方密钥激活</figcaption></figure>
<h3>02.Office软件激活</h3>
<ol>
<li><strong>打开Office应用程序：</strong> 启动<code>Word</code>、<code>Excel</code>或<code>PowerPoint</code>等</li>
<li><strong>访问文件菜单：</strong> 在应用程序中，点击左上角的"文件"菜单</li>
<li><strong>点击账户：</strong> 在文件菜单中，选择"账户"</li>
<li><strong>更改产品密钥：</strong> 在账户页面，找到并点击"更改产品密钥"</li>
<li><strong>输入产品密钥：</strong> 在弹出的对话框中输入你的25位密钥 ！获取 <a href="https://learn.microsoft.com/zh-cn/deployoffice/vlactivation/gvlks" target="_blank" rel="noopener noreferrer">微软Office官方正版秘钥</a></li>
<li><strong>激活Office：</strong> 输入密钥后，点击"继续"或"激活产品"</li>
</ol>
<h2>② 激活脚本（原理）</h2>
<blockquote>
<p>一键激活脚本：<a href="https://wwi.lanzoup.com/b0foh27ne" target="_blank" rel="noopener noreferrer">https://wwi.lanzoup.com/b0foh27ne</a>, 密码：<code>gkjb</code></p>
</blockquote>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404231900072.png" alt="脚本-持续更新" tabindex="0" loading="lazy"><figcaption>脚本-持续更新</figcaption></figure>
<h3>01.脚本激活命令</h3>
<p><strong>将密钥写入系统，实现激活</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>slmgr /ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXX
</code></pre></div><p>如果你有新的零售产品密钥，将 <code>X</code> 替换为实际的密钥，运行以上命令即可激活</p>
<h3>02.脚本激活网站推荐</h3>
<p><a href="https://kms.cx/" target="_blank" rel="noopener noreferrer">KMS一键激活windows/office网站</a></p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240116136.png" alt="KMS一键激活windows/office网站" tabindex="0" loading="lazy"><figcaption>KMS一键激活windows/office网站</figcaption></figure>
<h2>③ 激活程序（推荐）</h2>
<blockquote>
<p>获取 <a href="https://m.tb.cn/h.g0ZtnKz?tk=OoXyWIKR74J" target="_blank" rel="noopener noreferrer">一键激活程序</a> ,提供多种激活方式</p>
</blockquote>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404231900370.png" alt="程序-持续更新" tabindex="0" loading="lazy"><figcaption>程序-持续更新</figcaption></figure>
<div class="hint-container note">
<p class="hint-container-title">注意：使用一键激活程序，需先关闭电脑相关的杀毒程序</p>
<ul>
<li><a href="https://support.microsoft.com/zh-cn/windows/%E5%85%B3%E9%97%AD-windows-%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83%E4%B8%AD%E7%9A%84defender-%E9%98%B2%E7%97%85%E6%AF%92%E4%BF%9D%E6%8A%A4-99e6004f-c54c-8509-773c-a4d776b77960" target="_blank" rel="noopener noreferrer">关闭 Windows 安全中心中的Defender 防病毒保护</a></li>
<li><a href="http://www.fastaux.com/index.php?c=show&amp;id=54" target="_blank" rel="noopener noreferrer">360安全卫士设置白名单</a></li>
<li><a href="https://www.eyunsou.com/360sd/gongnneg/bmd/" target="_blank" rel="noopener noreferrer">360杀毒软件怎么添加文件白名单</a></li>
</ul>
</div>
<h3>01.数字激活工具 HWID_KMS38_CN_62</h3>
<p><strong>概述</strong></p>
<p><code>HWID_KMS38_CN_62.exe</code> 是一种<strong>数字激活工具</strong>，主要用于激活 Microsoft Windows 操作系统。它采用 HWID 技术，生成硬件标识符并将其发送到
Microsoft 的激活服务器进行验证，实现系统长期激活。</p>
<p><strong>激活步骤</strong></p>
<ol>
<li>鼠标右键点击“打开”，进入程序中</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232343700.png" alt="正在启动" tabindex="0" loading="lazy"><figcaption>正在启动</figcaption></figure>
<ol start="2">
<li>进入程序界面后，工作模式选择“<mark>安装数字密钥</mark>（HWID）”，点击“开始”</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232345572.png" alt="数字密钥激活" tabindex="0" loading="lazy"><figcaption>数字密钥激活</figcaption></figure>
<ol start="3">
<li>完成后执行<a href="#%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BB%E8%84%9A%E6%9C%AC">一键激活脚本</a>中的<code>06.查看是否永久激活.bat</code>验证激活状态</li>
</ol>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232347627.png" alt="计算机已永久激活" tabindex="0" loading="lazy"><figcaption>计算机已永久激活</figcaption></figure>
<h3>02.KMS激活工具 DragonKMS</h3>
<p>互联网论坛上的知名激活工具，也是我个人常用的激活工具，常用于激活Windows和Office全家桶，通过联网KMS激活</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404232356474.png" alt="MicroKMS神龙版" tabindex="0" loading="lazy"><figcaption>MicroKMS神龙版</figcaption></figure>
<h3>03.开源激活工具 HEU_KMS_Activator</h3>
<p>仅供研究激活原理使用，在“智能激活”中点击“开始”，即按照最佳激活方式"数字许可证/KMS38/OEM/KMS"依次激活，直到激活成功</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240021458.png" alt="智能激活（即数字许可证/KMS38/OEM/KMS依次激活）" tabindex="0" loading="lazy"><figcaption>智能激活（即数字许可证/KMS38/OEM/KMS依次激活）</figcaption></figure>
<p>等待一会，激活成功后提示</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240027800.png" alt="Success" tabindex="0" loading="lazy"><figcaption>Success</figcaption></figure>
<h3>04.小马激活工具 KMS10</h3>
<p>老牌激活工具，文件大小仅1M，我以前还用来激活Win7，可以想象年代的久远。支持离线激活，永久有效，无需考虑激活时限。office版本为retail的用户请自行转换版本到volume，即channel
switch。</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240037901.png" alt="小马激活工具" tabindex="0" loading="lazy"><figcaption>小马激活工具</figcaption></figure>
<h3>05.大神制作 W10DigitalActivation</h3>
<p>大神Ratiborus制作的，它还有开发激活Office的 <strong>KMSAuto++</strong> 工具，以及可定制化安装Office的 <strong>Office2013-2021 C2R Install</strong>
。可以关注它的<a href="https://twitter.com/ratiborus58" target="_blank" rel="noopener noreferrer">Twitter</a>。</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240055203.png" alt="WIN0-HWID数字永久激活" tabindex="0" loading="lazy"><figcaption>WIN0-HWID数字永久激活</figcaption></figure>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240057039.png" alt="永久激活" tabindex="0" loading="lazy"><figcaption>永久激活</figcaption></figure>
<h3>06.云萌激活工具 CMWTAT_Digital</h3>
<p>云萌 Windows 10 激活工具，专门用于数字权利激活的软件。本软件是一款使用CSharp编写的 Windows 10 数字权利激活工具</p>
<figure><img src="http://img.geekyspace.cn/pictures/2024/202404240106825.png" alt="云萌 Windows 10 激活工具" tabindex="0" loading="lazy"><figcaption>云萌 Windows 10 激活工具</figcaption></figure>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/202404232040995.png" type="image/png"/>
    </item>
    <item>
      <title>Spring Data JPA 快速入门</title>
      <link>https://www.geekyspace.cn/md/spring-data-jpa/jetbrains/getting-started.html</link>
      <guid>https://www.geekyspace.cn/md/spring-data-jpa/jetbrains/getting-started.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring Data JPA 快速入门</source>
      <description>Spring Data JPA 快速入门 目标： 了解如何使用Spring Data JPA从数据库中存储和检索数据。 参考： Spring Data JPA 官方文档 Jetbrains 官方文档 介绍 Spring Data JPA是一个功能强大的框架，允许用户轻松地与数据库交互，同时最大限度地减少样板代码。 在本教程中，我们将研究如何使用Spri...</description>
      <category>Spring Data</category>
      <pubDate>Thu, 04 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>目标： 了解如何使用Spring Data JPA从数据库中存储和检索数据。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://docs.spring.io/spring-data/jpa/reference/jpa/getting-started.html" target="_blank" rel="noopener noreferrer">Spring Data JPA 官方文档</a></li>
<li><a href="https://www.jetbrains.com/guide/java/tutorials/getting-started-spring-data-jpa/" target="_blank" rel="noopener noreferrer">Jetbrains 官方文档</a></li>
</ul>
<h2>介绍</h2>
<p><a href="https://spring.io/projects/spring-data-jpa" target="_blank" rel="noopener noreferrer">Spring Data JPA</a>是一个功能强大的框架，允许用户轻松地与数据库交互，同时最大限度地减少样板代码。
在本教程中，我们将研究如何使用Spring Data JPA插入数据库并从数据库查询数据。
我们将使用<a href="https://www.jetbrains.com/lp/intellij-frameworks/" target="_blank" rel="noopener noreferrer">IntelliJ IDEA Ultimate</a>创建一个简单的Spring靴子应用程序，以利用其Spring特性支持。</p>
<h2>创建一个新的Spring Boot项目</h2>
<p>首先，在 IntelliJ IDEA Ultimate 中，我们将通过在欢迎屏幕中点击 "<strong>New Project</strong>" 来创建一个新项目。
我们将从左侧菜单中选择 "<strong>Spring Initializr</strong>"。然后，我们将指定项目的名称 - 你可以将其命名为 <mark>SpringDataJPA</mark>。
我们还可以将 "<strong>Group</strong>" 字段更改为我们公司的名称。
对于其余的字段，你可以接受默认值。请随意为你的项目使用最新的 Java 版本。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032048778.png" alt="New Project Window" tabindex="0" loading="lazy"><figcaption>New Project Window</figcaption></figure>
<p>接下来，我们将点击 "<strong>Next</strong>"。</p>
<p>在接下来的窗口中，我们将选择我们可用的最新的 Spring Boot 版本。
然后在 "Dependencies" 下，我们将在搜索框中搜索 "<mark>data</mark>"。
在 SQL 下，我们将从列表中选择 <strong>Spring Data JPA</strong> 和 <strong>H2 Database</strong> 的复选框。
对于本教程，我们将使用 H2 作为我们的数据库，因为它很容易设置。
如果你想使用不同的数据库，比如 MySQL 或 HyperSQL，可以随意选择这些依赖项，或者稍后将它们添加到你的 pom.xml 文件中。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032053947.png" alt="New Project Window Dependency" tabindex="0" loading="lazy"><figcaption>New Project Window Dependency</figcaption></figure>
<p>一旦我们点击 "<strong>Finish</strong>"，IntelliJ IDEA 就会创建一个带有 Spring Data JPA 和数据库依赖的新的 Spring Boot 项目。</p>
<h2>创建员工实体</h2>
<p>实体是一个Java类，代表着你想要插入到数据库中的数据。 对于我们的应用程序，我们将创建一个名为 Employee 的实体，
我们将使用它来将员工数据插入到我们数据库中的 Employee 表中。</p>
<p>在项目工具窗口中，我们将导航到我们的 <code>src/main/java</code> 目录，选择 <code>com.jetbrains.springdatajpaapp</code> 包，
并按下 <strong>⌘N</strong> (macOS) / <strong>Alt+Insert</strong> (Windows/Linux)。选择 <strong>Java Class</strong>，然后输入我们的实体名称 - <mark>Employee</mark>。
然后，按下 <strong>⏎</strong> (macOS) / <strong>Enter</strong> (Windows/Linux)。</p>
<p>在 Employee 类中，我们将通过在类定义中添加 <mark>@Entity</mark> 注解并导入 <code>javax.persistence.Entity</code> 包来将其设置为实体。
一旦你这样做了，你会注意到你的类中出现了一个错误。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032108680.png" alt="Employee Entity Error" tabindex="0" loading="lazy"><figcaption>Employee Entity Error</figcaption></figure>
<p>正如错误消息所指示的，实体必须有一个由 <code>@Id </code>注解指定的主键字段。我们将使用 <strong>⌥⏎</strong> (macOS) / <strong>Alt+Enter</strong> (Windows/Linux)
快捷键，
这样 IntelliJ IDEA 就可以为我们添加 ID，这将导致提示输入 ID 字段的信息。 我们将采用默认的名称和类型。
你可以选择 "<strong>Field Access</strong>" 复选框（我更喜欢在字段上使用注解，而不是在 setter 方法上，因为我觉得这样更易读）。
你也可以选择 "<strong>Generated</strong>" 复选框，这样你就不必自己分配员工 ID。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032111916.png" alt="Add Employee ID" tabindex="0" loading="lazy"><figcaption>Add Employee ID</figcaption></figure>
<p>然后，我们将点击 "<strong>OK</strong>"。你会注意到 IntelliJ IDEA 创建了一个带有其 setter 和 getter 的 <code>id</code> 字段。</p>
<p>接下来，让我们添加几个 String 字段：<mark>firstName</mark> 和 <mark>lastName</mark>。</p>
<p>接下来，我们将通过调出 Generate 菜单 <strong>⌘N</strong> (macOS) / <strong>Alt+Insert</strong> (Windows/Linux)，然后选择 <strong>Constructor</strong> 来生成我们的构造函数。
我们不需要构造函数接收一个 id，因为我们的 id 将会自动生成，
所以我们将点击 <strong>firstName</strong>，然后按住 <strong>⌘</strong> (macOS) / <strong>Ctrl</strong> (Windows/Linux) 键，然后选择 <strong>lastName</strong>。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032114060.png" alt="Generate Constructor" tabindex="0" loading="lazy"><figcaption>Generate Constructor</figcaption></figure>
<p>然后，我们将点击 "<strong>OK</strong>"。</p>
<p>你现在会注意到你的 <code>Employee</code> 类上出现了一个错误，因为你没有一个无参构造函数。
如果你在错误上按下 <strong>Alt+Enter</strong> (Windows/Linux)
或 <strong>⌥⏎</strong> (macOS)，IntelliJ IDEA 将为你提供创建它的选项 - 让我们继续执行。</p>
<p>接下来，我们将生成字段的 setter 和 getter。
我们将调出 Generate 菜单 ⌘N (macOS) / Alt+Insert (Windows/Linux)，然后选择 Getter 和 Setter。
我们将按住 ⌘ (macOS) / Ctrl (Windows/Linux) 键，并选择两个变量。
然后，我们将点击 "<strong>OK</strong>"。IntelliJ IDEA 为这两个变量生成了 getter 和 setter。</p>
<p>最后，让我们再次调出 Generate 菜单 ⌘N (macOS) / Alt+Insert (Windows/Linux)，然后选择 <code>toString</code> 来生成一个 toString 方法。
我们将保持所有字段选中，然后点击 "<strong>OK</strong>"。</p>
<p>最终，Employee 实体应该类似于以下内容（格式可能会有所不同）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>springdatajpaapp</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Entity</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">GeneratedValue</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Id</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">,</span> <span class="token class-name">String</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token class-name">String</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Employee{"</span> <span class="token operator">+</span>
                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>
                <span class="token string">", firstName='"</span> <span class="token operator">+</span> firstName <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>
                <span class="token string">", lastName='"</span> <span class="token operator">+</span> lastName <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>创建 Repository 接口</h2>
<p>现在我们已经创建了 Employee 实体，我们需要一种方式来执行 CRUD（创建、读取、更新、删除）操作。
幸运的是，Spring Data JPA 通过 <mark>Repositories</mark> 提供了所有基本的操作。让我们看看它们是如何工作的。</p>
<p>在项目工具窗口中，我们将选择 <code>com.jetbrains.springdatajpaapp</code> 包，并按下 ⌘N (macOS) / Alt+Insert (Windows/Linux)。
选择 <strong>Java Class</strong>。
我们将其命名为 <mark>EmployeeRepository</mark>，这次我们选择 <strong>Interface</strong> 然后按下 ⏎ (macOS) / Enter (Windows/Linux)。
为了使我们的接口成为一个 repository，我们需要让它扩展 <mark>CrudRespository&lt;T, ID&gt;</mark> 接口，其中泛型参数是我们的实体类和实体的
id 类型。
所以对于我们的应用程序，我们的 repository
接口定义将会是：<code>public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt;</code>。</p>
<p>我们将使用这个 <code>EmployeeRepository</code> 接口来在我们的应用程序代码中执行 CRUD 操作。
由于我们正在扩展 <code>CrudRepository</code>，我们默认就可以访问基本的 CRUD 方法。
例如，我们可以调用 <code>save</code> 方法将一个 Employee 对象插入到我们的数据库中。
我们也可以调用 <code>findAll</code> 方法来列出你的 Employee 表中的所有员工。
当我们编写我们的应用程序逻辑时，我们将看到如何做到这一点。</p>
<p>在大多数应用程序中，你会发现自己希望做的事情超出了 CrudRepository 接口默认提供的范围。
例如，假设我们想要找到所有姓氏中包含空格的员工。你当然可以编写一个 SQL 查询来实现这个功能。
然而，一个更简单的方法是利用 Spring Data JPA，它允许你在你的 repository 中创建方法，这些方法将根据方法名被转换为查询。</p>
<p>例如，假设我们想要添加一个方法来查找所有姓氏中包含特定字符串的员工。
我们将前往我们的 <code>EmployeeRepository</code> 接口，并开始声明我们的方法。
我的方法将返回一个员工列表，因此我们将使用 <code>List&lt;Employee&gt;</code> 作为返回类型。
然后，我们需要指定一个由两部分组成的方法名：引入部分和条件部分。
我们可以在 IntelliJ IDEA 中使用 <strong>⌃␣</strong> (macOS) / <strong>Ctrl+Space</strong> (Windows/Linux) 来查看引入部分的方法建议列表：</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032144256.png" alt="Repository Method Suggestion Introducer" tabindex="0" loading="lazy"><figcaption>Repository Method Suggestion Introducer</figcaption></figure>
<p>我们将选择 <mark>findEmployeesBy</mark> 作为引入部分。
然后，我们将再次点击 <strong>⌃␣</strong> (macOS) / <strong>Ctrl+Space</strong> (Windows/Linux) 来查看可以选择的条件列表。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032145040.png" alt="Repository Method Suggestion Criteria" tabindex="0" loading="lazy"><figcaption>Repository Method Suggestion Criteria</figcaption></figure>
<p>我们将选择 <code>LastNameContaining</code>。最后，我们将声明一个 String 方法参数，表示我们要检查的字符串。
现在我们有了一个方法，可以找到所有姓氏中包含所提供字符串的员工。</p>
<p>你可能会想：如果我定义了这个接口，我不是必须要实现它吗？答案是否定的。
Spring Data JPA 会为你处理这些！你只需要定义你的 Repository 接口，并遵循 Spring Data 的约定声明你的方法。
当你添加更多方法时，如果在方法名中犯错，IntelliJ IDEA 将会指出错误。
例如，如果我们尝试创建一个用于查询具有不正确 <code>LName</code> 属性的员工的方法，IntelliJ IDEA
会给出一个错误，说<code>Cannot resolve property LName</code>。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032330980.png" alt="Method Signature Validation" tabindex="0" loading="lazy"><figcaption>Method Signature Validation</figcaption></figure>
<p>最终，你的 EmployeeRepository 接口应该如下所示：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>springdatajpaapp</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span></span><span class="token class-name">CrudRepository</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmployeeRepository</span> <span class="token keyword">extends</span> <span class="token class-name">CrudRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> <span class="token function">findEmployeesByLastNameContaining</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>配置数据库</h2>
<p>此时，我们可以使用 Spring Boot 为我们创建的默认内存数据库。
然而，默认数据库功能有限，并且在应用程序终止后不允许数据保留，因此让我们继续配置一个数据库。</p>
<p>我们将调出搜索菜单 <strong>⇧⇧</strong> (macOS) / <strong>Shift+Shift</strong> (Windows/Linux) 并搜索我们的 <mark>application.properties</mark> 文件。
在我们的 application.properties 文件中，我们可以利用 IntelliJ IDEA 的建议来指定连接到我们的 H2 数据库所需的属性。
我们将开始输入 <mark>url</mark>，并从建议列表中选择 <mark>spring.datasource.url</mark> 属性。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032332643.png" alt="Application Properties URL" tabindex="0" loading="lazy"><figcaption>Application Properties URL</figcaption></figure>
<p>如果你没有使用 H2 作为你的数据库，你可以在这里指定你自己的数据库 URL。
在我们的情况下，我们将指定 <mark>jdbc:h2:file:./data/myDB</mark> 作为我们的 URL，这将创建一个名为 <mark>myDB</mark> 的 H2 数据库。</p>
<p>接下来，我们需要指定我们的驱动类名。
我们可以类似地搜索 <mark>driver</mark>，并从我们的建议列表中选择 <mark>spring.datasource.driver-class-name</mark>。
一旦我们选择了这个，IntelliJ IDEA 将根据我们之前指定的 URL 提供 H2 驱动程序的建议值，因此我们可以选择它。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032156491.png" alt="Application Properties Driver Class" tabindex="0" loading="lazy"><figcaption>Application Properties Driver Class</figcaption></figure>
<p>接下来，我们同样搜索 <mark>username</mark> 和 <mark>password</mark> 属性，并将它们的值分别设置为 <mark>sa</mark> 和 <mark>password</mark>。</p>
<p>最后，我们不想手动创建任何表，因此我们将添加 <mark>spring.jpa.hibernate.ddl-auto</mark> 属性，并使用代码完成来查看可能的值列表。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032158424.png" alt="Application Properties ddl-auto" tabindex="0" loading="lazy"><figcaption>Application Properties ddl-auto</figcaption></figure>
<p>对于我的应用程序，我将把属性值设置为 <mark>update</mark>，这样如果表不存在，它将在数据库中创建表，并在我对实体进行更改时更新它们。</p>
<p>最终，你的 application.properties 文件应该如下所示：</p>
<div class="language-properties" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:h2:file:./data/myDB</span>
<span class="token key attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token value attr-value">org.h2.Driver</span>
<span class="token key attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token value attr-value">sa</span>
<span class="token key attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token value attr-value">password</span>
<span class="token key attr-name">spring.jpa.hibernate.ddl-auto</span><span class="token punctuation">=</span><span class="token value attr-value">update</span>
</code></pre></div><h2>从应用程序写入数据库</h2>
<p>现在我们有了我们的 Employee 实体、Repository 和数据库配置，我们准备编写我们的应用程序逻辑。
假设我们想要向我们的数据库插入四个员工。我们将导航到为我们的 Spring Boot 应用程序
创建的 <mark>SpringDataJpaApplication</mark> 类 <strong>⇧⇧</strong> (macOS) / <strong>Shift+Shift</strong> (Windows/Linux)。</p>
<p><strong>练习</strong>：</p>
<p>花几分钟时间看看你能否创建一个 <code>insertFourEmployees(EmployeeRepository repository)</code> 方法，使用 <code>save()</code> 方法插入员工。</p>
<p>完成了吗？以下是你的方法应该是什么样子的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertFourEmployees</span><span class="token punctuation">(</span><span class="token class-name">EmployeeRepository</span> repository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Dalia"</span><span class="token punctuation">,</span> <span class="token string">"Abo Sheasha"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Trisha"</span><span class="token punctuation">,</span> <span class="token string">"Gee"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Helen"</span><span class="token punctuation">,</span> <span class="token string">"Scott"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"Mala"</span><span class="token punctuation">,</span> <span class="token string">"Gupta"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，让我们继续在我们的应用程序中调用那个方法。在一个典型的 Spring Boot 应用程序中，我们会有一个服务类，其中包含服务提供的功能。
然而，由于我们只是做一些一次性的操作，让我们保持简单，使用一个 Bean 来调用我们的 <code>insertFourEmployees</code> 方法。
然后，让我们调用 <code>repository.findAll()</code> 来检索已插入的实体。下面是代码示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">CommandLineRunner</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EmployeeRepository</span> repository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">insertFourEmployees</span><span class="token punctuation">(</span>repository<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>repository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们运行我们的应用程序并看到它的运行情况。我们将按 <strong>⌃R</strong> (macOS) / <strong>Shift+F10</strong> (Windows/Linux)。</p>
<p>最终结果，一旦我们的应用程序启动，我们可以看到控制台日志显示我们的 Spring Boot 应用程序正在启动。
然后，我们可以看到 <code>findAll</code> 调用的结果，打印出数据库中所有的员工。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032212130.png" alt="Application Run Successfully" tabindex="0" loading="lazy"><figcaption>Application Run Successfully</figcaption></figure>
<h2>创建数据源</h2>
<p>在你的项目中使用数据库时，在IntelliJ IDEA中创建一个数据源连接非常有用。
它允许你在IDE中轻松地与数据库进行交互。让我们为我们的<a href="https://www.h2database.com/html/main.html" target="_blank" rel="noopener noreferrer">H2</a>数据库创建一个数据源连接。
如果你正在使用其他数据库，你可以使用类似的步骤，或者你可以按照
IntelliJ IDEA<a href="https://www.jetbrains.com/help/java/connecting-to-a-database.html" target="_blank" rel="noopener noreferrer">数据库连接帮助页面</a>中概述的说明进行操作。
请注意，此功能仅适用于<a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html" target="_blank" rel="noopener noreferrer">IntelliJ IDEA Ultimate</a>版。</p>
<p>要创建我们的H2数据源，我们将打开数据库工具窗口（<strong>View | Tool Windows | Database</strong>），然后点击<code>+</code>按钮。
有多种方式可以创建我们的连接。我们将使用<strong>Data source from URL</strong>选项。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032330533.png" alt="New Database" tabindex="0" loading="lazy"><figcaption>New Database</figcaption></figure>
<p>我们将输入我们的数据库URL：<mark>jdbc:h2:file:./data/myDB</mark>，然后点击确定。</p>
<p>接下来，我们将完成数据库的配置。对于我们的用户和密码字段，
我们将输入在我们的<code>application.properties</code>文件中设置的用户和密码（<mark>sa</mark>，<mark>password</mark>）。
如果你收到有关缺少H2驱动程序的警告，请点击下载缺失的驱动程序文件。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032332971.png" alt="Data Source myDB Config" tabindex="0" loading="lazy"><figcaption>Data Source myDB Config</figcaption></figure>
<p><strong>可选步骤</strong>：在选项选项卡下，启用“设置后自动断开连接”，并将其设置为在3秒后断开连接。
此设置将断开IntelliJ IDEA中的数据库并释放所有锁定，使我们应用程序的进程可以持续连接并写入数据库。
这将防止来自你的应用程序的<code>database may already be in use</code>的错误。
如果执行了此步骤，则可能需要在数据库工具窗口中点击“刷新”按钮以更新数据源。</p>
<p>然后，我们将点击“<strong>Test Connection</strong>”以确保我们的配置是有效的。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032331974.png" alt="Data Source Config Options" tabindex="0" loading="lazy"><figcaption>Data Source Config Options</figcaption></figure>
<p>一旦我们点击"<strong>OK</strong>"，我们就会看到一个新的数据源，用于我们的H2数据库。</p>
<p>最终结果 ，在数据库视图中，我们现在可以导航到我们的Employee表，并通过双击表格查看所有员工数据。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032331767.png" alt="Database View" tabindex="0" loading="lazy"><figcaption>Database View</figcaption></figure>
<h2>调用自定义查询</h2>
<p>假设我们想要查询数据库中所有姓氏中包含空格的员工。</p>
<p><strong>练习</strong>：花几分钟时间编写代码，查找并打印姓氏中带有空格的所有员工。</p>
<p>完成了吗？以下是实现代码的样子：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">CommandLineRunner</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EmployeeRepository</span> repository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>repository<span class="token punctuation">.</span><span class="token function">findEmployeesByLastNameContaining</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最终结果， 如果你插入了教程中提到的相同数据，你应该在控制台输出中看到"<code>Dalia</code>"员工。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403032250455.png" alt="Application Run Successfully" tabindex="0" loading="lazy"><figcaption>Application Run Successfully</figcaption></figure>
<h2>总结</h2>
<p>在这个教程中，我们创建了一个简单的Spring Boot应用程序，它使用Spring Data JPA来存储和检索数据库中的数据。</p>
<p>一些在教程中提到的有用的快捷方式包括：</p>
<p>| Name          | Windows Shortcut | macOS Shortcut |
|</p>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202403032048778.png" type="image/png"/>
    </item>
    <item>
      <title>Spring 核心技术</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring 核心技术</source>
      <description>Spring 核心技术 核心技术 Spring 框架的核心技术主要包括： 依赖注入（dependency injection），也称为控制反转（IoC） 事件（events） 资源（resources） 国际化（i18n） 数据验证（validation） 数据绑定（data binding） 类型转换（type conversion） SpEL（Sp...</description>
      <category>Spring</category>
      <pubDate>Mon, 18 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>核心技术</h2>
<p>Spring 框架的核心技术主要包括：</p>
<ul>
<li><strong>依赖注入（dependency injection），也称为控制反转（IoC）</strong></li>
<li>事件（events）</li>
<li>资源（resources）</li>
<li>国际化（i18n）</li>
<li>数据验证（validation）</li>
<li>数据绑定（data binding）</li>
<li>类型转换（type conversion）</li>
<li>SpEL（Spring Expression Language）</li>
<li><strong>面向切面编程（AOP）</strong></li>
</ul>
<h2>Spring IoC容器和Bean简介</h2>
<p><strong>Spring IoC（控制反转）也被称为依赖注入（DI）</strong></p>
<p>它是一个过程，对象仅通过构造参数、工厂方法参数或在<strong>对象实例</strong>被构造函数或工厂方法返回后，在其上设置的属性来定义它们的依赖关系。
在IoC容器创建Bean时，它会自动注入这些依赖项。 不再需要通<code>直接构造依赖项</code>或使用<code>服务定位器模式</code>等方式来管理对象的实例化或位置，
而是交由IoC容器来管理，因此称为<strong>控制反转</strong>。</p>
<p><a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener noreferrer">org.springframework.beans</a>
和 <a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener noreferrer">org.springframework.context</a>
包是Spring Framework的IoC容器的基础。
<a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener noreferrer">BeanFactory</a>
接口提供了一种高级配置机制，能够管理任何类型的<code>object</code>对象。
<a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener noreferrer">ApplicationContext</a>
是 BeanFactory 的一个子接口。它增加了：</p>
<ul>
<li>与Spring的AOP特性更好的集成</li>
<li><code>Message resource</code>消息资源处理（用于国际化）</li>
<li><code>Event publication</code>事件发布</li>
<li>应用层特定的上下文，例如Web应用程序的<code>WebApplicationContext</code></li>
</ul>
<p>简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，<code>ApplicationContext</code> 添加了更多企业特定的功能。
<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个超集。 在特别要求轻量级应用程序的情况下，可以考虑使用<code>BeanFactory</code>。</p>
<p>想要了解 BeanFactory
参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html" target="_blank" rel="noopener noreferrer">BeanFactory API</a> 。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bean 定义（Definition）</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/beans-definition.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/beans-definition.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Bean 定义（Definition）</source>
      <description>Bean 定义（Definition） 概述 构建应用程序主干并由Spring IoC 容器管理的对象称为 Bean。 在容器中，Bean的定义表示为org.springframework.beans.factory.config.BeanDefinition对象。 BeanDefinition包含以下元数据： 全路径类名：通常，被定义为Bean的实现...</description>
      <category>Spring</category>
      <pubDate>Mon, 18 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>概述</h2>
<blockquote>
<p>构建应用程序主干并由Spring IoC 容器管理的对象称为 Bean。</p>
<p>在容器中，Bean的定义表示为<code>org.springframework.beans.factory.config.BeanDefinition</code>对象。</p>
</blockquote>
<p><strong>BeanDefinition包含以下元数据：</strong></p>
<ul>
<li><strong>全路径类名</strong>：通常，被定义为Bean的实现类</li>
<li><strong>行为配置元素</strong>：说明了Bean在容器中的行为方式，例如作用域scope、生命周期回调等</li>
<li><strong>依赖关系</strong>：描述Bean与其他Bean之间的依赖关系，包括依赖注入，依赖查找等</li>
<li>其他配置信息：如：管理连接池的Bean可以配置pool的大小限制，使用的连接数量等</li>
</ul>
<p>该元数据转换为组成每个Bean定义的一组属性。 下表介绍了这些属性：</p>
<p>| 属性                       | 描述           |
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bean生命周期（Lifecycle）</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/beans-lifecycle.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/beans-lifecycle.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Bean生命周期（Lifecycle）</source>
      <description>Bean生命周期（Lifecycle） Spring框架提供了多种接口，你可以使用这些接口来定制Bean的性质。本节将它们分为以下几类： 生命周期回调 ApplicationContextAware 和 BeanNameAware 其他Aware接口 生命周期回调 为了与容器管理Bean的生命周期进行交互，你可以实现Spring的Initializin...</description>
      <category>Spring</category>
      <pubDate>Mon, 08 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Spring框架提供了多种接口，你可以使用这些接口来定制Bean的性质。本节将它们分为以下几类：</p>
<ul>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83">生命周期回调</a></li>
<li><a href="#applicationcontextaware%E5%92%8Cbeannameaware">ApplicationContextAware 和 BeanNameAware</a></li>
<li><a href="#%E5%85%B6%E4%BB%96aware%E6%8E%A5%E5%8F%A3">其他Aware接口</a></li>
</ul>
<h2>生命周期回调</h2>
<p>为了与容器管理Bean的生命周期进行交互，你可以实现Spring的<code>InitializingBean</code>和<code>DisposableBean</code>接口。
容器调用前者的<code>afterPropertiesSet()</code>方法以及后者的<code>destroy()</code>方法，让Bean在初始化和销毁时执行特定的操作。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在现代的Spring应用程序中，通常认为JSR-250的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解是用于接收生命周期回调最佳实践。
使用这些注解意味着你的Bean不会与Spring特定的接口耦合。参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/postconstruct-and-predestroy-annotations.html" target="_blank" rel="noopener noreferrer">使用@PostConstruct和@PreDestroy</a>。</p>
<p>如果你不想使用JSR-250注解，但仍然希望消除耦合，可以考虑使用<code>init-method</code>和<code>destroy-method</code>的Bean定义元数据。</p>
</div>
<p>Spring框架在内部使用<code>BeanPostProcessor</code>实现来处理它找到的任何回调接口，并调用适当的方法。
如果你需要自定义功能或其他Spring默认不提供的生命周期行为，你可以自己实现一个<code>BeanPostProcessor</code>。
参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html" target="_blank" rel="noopener noreferrer">容器扩展点</a>。</p>
<p>除了初始化和销毁回调之外，Spring管理的对象还可以实现<code>Lifecycle</code>接口，以便这些对象可以参与由容器自身生命周期驱动的启动和关闭过程。</p>
<p>生命周期回调接口在本节中有详细描述。</p>
<h3>初始化回调</h3>
<p>实现<code>org.springframework.beans.factory.InitializingBean</code>接口允许Bean在容器设置了所有必要属性之后执行初始化工作。
<code>InitializingBean</code>接口指定了一个方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
</code></pre></div><p>我们建议不要使用<code>InitializingBean</code>接口，因为它会将代码不必要地耦合到Spring。
相反，我们建议使用<code>@PostConstruct</code>注解或指定一个POJO初始化方法。
在基于XML的配置中，你可以使用<code>init-method</code>属性来指定具有<code>void</code>无参数签名的方法的名称。
对于Java配置，你可以使用<code>@Bean</code>的<code>initMethod</code>属性。
参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-lifecycle-callbacks" target="_blank" rel="noopener noreferrer">接收生命周期回调</a>。
考虑以下示例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleInitBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 做一些初始化工作</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上一个示例与以下示例几乎具有相同的效果：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleInitBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.AnotherExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnotherExampleBean</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 做一些初始化工作</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，前面两个示例中的第一个并未将代码与Spring耦合。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>请注意，<code>@PostConstruct</code>和初始化方法一般在容器的单例创建锁内执行。只有在从<code>@PostConstruct</code>方法返回后，
Bean实例才被视为完全初始化并准备好发布给其他对象。
这些单独的初始化方法仅用于验证配置状态并可能根据给定的配置准备一些数据结构，但不涉及外部Bean访问相关的进一步活动。
否则，存在初始化死锁的风险。</p>
<p>对于需要触发昂贵的初始化后活动的场景，例如异步数据库准备步骤，你的Bean应该实现
<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code>方法，或依赖于上下文刷新事件：实现
<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>或声明其注解等效的 <code>@EventListener(ContextRefreshedEvent.class)</code>。
这些变体在所有常规单例初始化之后，因此不会在任何单例创建锁内。</p>
<p>或者，你可以实现<code>(Smart)Lifecycle</code>接口并与容器的整体生命周期管理集成，包括自动启动机制、预销毁停止步骤和潜在的停止/重新启动回调（参见下文）。</p>
</div>
<h3>销毁回调</h3>
<p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许Bean在包含它的容器销毁时获得回调。
<code>DisposableBean</code>接口指定了一个方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
</code></pre></div><p>我们建议不要使用<code>DisposableBean</code>回调接口，因为它会将代码不必要地耦合到Spring。
相反，我们建议使用<code>@PreDestroy</code>注解或指定一个由Bean定义支持的通用方法。
在基于XML的配置中，你可以在<code>&lt;bean/&gt;</code>元素中使用<code>destroy-method</code>属性。
在Java配置中，你可以使用<code>@Bean</code>的<code>destroyMethod</code>属性。
参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html#beans-java-lifecycle-callbacks" target="_blank" rel="noopener noreferrer">接收生命周期回调</a>。
考虑以下示例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleInitBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cleanup<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 做一些销毁工作(比如释放池连接)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上一个示例与以下示例几乎具有相同的效果：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleInitBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.AnotherExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnotherExampleBean</span> <span class="token keyword">implements</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 做一些销毁工作(比如释放池连接)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，前面两个示例中的第一个并未将代码与Spring耦合。</p>
<p>请注意，Spring还支持推断销毁方法，可以检测到公开的<code>close</code>或<code>shutdown</code>方法。
这是Java配置类中<code>@Bean</code>方法的默认行为，并且自动匹配<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>实现，也不会将销毁逻辑与Spring耦合。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在XML配置中，你可以将<code>&lt;bean&gt;</code>元素的<code>destroy-method</code>属性设置为一个特殊的(inferred)值。
该值指示Spring自动检测特定Bean类上的public <code>close</code>或<code>shutdown</code>方法。
另外，你也可以将这个特殊（inferred）值赋给<code>&lt;beans&gt;</code>元素的<code>default-destroy-method</code>属性，以将此行为应用于一组Bean定义。
（参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-default-init-destroy-methods" target="_blank" rel="noopener noreferrer">默认初始化和销毁方法</a>）。</p>
</div>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>要实现扩展的关闭阶段，你可以实现<code>Lifecycle</code>接口，这样可以在调用任何单例Bean的销毁方法之前接收到早期停止信号。
此外，你还可以实现<code>SmartLifecycle</code>接口，用于时间限制的停止步骤，容器将等待所有这类停止处理完成后再继续执行销毁方法。</p>
</div>
<h3>默认的初始化和销毁方法</h3>
<p>当你编写初始化和销毁方法时，如果不使用Spring特定<code>InitializingBean</code>和<code>DisposableBean</code>回调接口，
通常会使用<code>init()</code>、<code>initialize()</code>、<code>dispose()</code>等名称的方法。
理想情况下，这些生命周期回调方法的命名应在项目中标准化，以便所有开发人员使用相同的方法名称并确保一致性。</p>
<p>在Spring中，你可以配置容器来自动"寻找"每个Bean上具有特定名称的初始化和销毁回调方法。
这意味着作为应用开发者，你可以编写应用类并使用名为<code>init()</code>的初始化回调，而无需在每个Bean定义中配置<code>init-method="init"</code>属性。
Spring IoC容器会在创建Bean时调用该方法
（并且符合<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle" target="_blank" rel="noopener noreferrer">之前描述</a>
的标准生命周期回调约定）。这个特性还可以强制执行初始化和销毁方法回调的一致命名约定。</p>
<p>假设你的初始化回调方法命名为<code>init()</code>，销毁回调方法命名为<code>destroy()</code>。那么你的类将类似于以下示例中的类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultBlogService</span> <span class="token keyword">implements</span> <span class="token class-name">BlogService</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token class-name">BlogDao</span> blogDao<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBlogDao</span><span class="token punctuation">(</span><span class="token class-name">BlogDao</span> blogDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>blogDao <span class="token operator">=</span> blogDao<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 这个方法被标记为初始化回调方法</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blogDao <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"必须设置 [blogDao] 属性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后你可以在一个类似于以下示例的Bean中使用该类：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">default-init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blogService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.something.DefaultBlogService<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blogDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blogDao<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在顶层<code>&lt;beans/&gt;</code>元素中添加<code>default-init-method</code>属性会导致Spring IoC容器识别Bean类中名为<code>init</code>的方法作为初始化方法的回调。
当创建和组装Bean时，如果Bean类具有这样的方法，它会在适当的时候被调用。</p>
<p>你可以类似地（在XML中）通过在顶层<code>&lt;beans/&gt;</code>元素上使用<code>default-destroy-method</code>属性来配置销毁方法的回调。</p>
<p>如果现有的Bean类已经有了与约定不符的回调方法的名称，你可以通过在<code>&lt;bean/&gt;</code>本身上使用<code>init-method</code>和<code>destroy-method</code>
属性（在XML中）来覆盖默认值，指定方法的名称。</p>
<p>Spring容器保证在为Bean提供所有依赖项之后立即调用配置的初始化回调。 因此，初始化回调在原始Bean引用上被调用，这意味着AOP拦截器等还没有被应用到Bean上。
首先完全创建目标Bean，然后再应用AOP代理（例如）及其拦截器链。 如果目标Bean和代理是分开定义的，你的代码甚至可以与原始目标Bean交互，绕过代理。
因此，将拦截器应用于<code>init</code>方法是不一致的，因为这样做会将目标Bean的生命周期与它的代理或拦截器耦合在一起，当你的代码直接与原始目标Bean交互时，会留下奇怪的语义。</p>
<h3>组合式生命周期机制</h3>
<p>截至Spring 2.5，你有三种选项来控制bean的生命周期行为：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener noreferrer">InitializingBean</a>
和<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener noreferrer">DisposableBean</a>
回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><code>@PostConstruct</code>和<code>@PreDestroy</code>注解
<ol>
<li>你可以组合这些机制来控制Bean的生命周期行为</li>
</ol>
</li>
</ul>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>如果为一个Bean配置了多种生命周期机制，并且每种机制都配置了不同的方法名称，则每个配置的方法按照本说明后面列出的顺序运行。
然而，如果为这些生命周期机制中的一个或多个配置了相同的方法名称，例如使用<code>init()</code>
作为初始化方法的名称，则该方法只会被执行一次，详细说明参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-default-init-destroy-methods" target="_blank" rel="noopener noreferrer">上一节</a>。</p>
</div>
<p>为同一个Bean配置了多个生命周期机制，并且使用了不同的初始化方法时，调用顺序如下：</p>
<ol>
<li>使用<code>@PostConstruct</code>注解的方法</li>
<li>实现<code>InitializingBean</code>接口定义的<code>afterPropertiesSet()</code>方法</li>
<li>自定义配置的<code>init()</code>方法</li>
</ol>
<p>销毁方法的调用顺序也类似：</p>
<ol>
<li>使用<code>@PreDestroy</code>注解的方法</li>
<li>实现<code>DisposableBean</code>接口定义的<code>destroy()</code>方法</li>
<li>自定义配置的<code>destroy()</code>方法</li>
</ol>
<h3>启动和关闭的回调</h3>
<p><code>Lifecycle</code>接口定义了任何具有自身生命周期要求的对象的基本方法（例如启动和停止某些后台进程）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>

    <span class="token comment">// 启动方法</span>
	<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 停止方法</span>
	<span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 是否正在运行</span>
	<span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>任何由Spring管理的对象都可以实现<code>Lifecycle</code>接口。
然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时（例如，在运行时进行停止/重启场景），它会将这些调用级联到该上下文中定义的所有<code>Lifecycle</code>实现中。
它通过委托给一个<code>LifecycleProcessor</code>来实现这一点，如下所示。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LifecycleProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>

    <span class="token comment">// 刷新时触发的方法</span>
	<span class="token keyword">void</span> <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 关闭时触发的方法</span>
	<span class="token keyword">void</span> <span class="token function">onClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请注意，<code>LifecycleProcessor</code>本身就实现了<code>Lifecycle</code>接口。它还添加了另外两个方法，用于在上下文（context）被刷新和关闭时做出反应。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>请注意，常规的<code>org.springframework.context.Lifecycle</code>接口是一个明确的<code>start</code>和<code>stop</code>通知的简单约定，并不意味着在上下文刷新时自动启动。
为了对特定Bean的自动启动进行细粒度控制（包括启动和停止阶段），建议实现扩展的<code>org.springframework.context.SmartLifecycle</code>接口。</p>
<p>此外，请注意，<code>stop</code>通知不能保证在销毁之前执行。
在正常关闭时，所有<code>Lifecycle</code> Bean首先接收到<code>stop</code>通知，然后才会被传播到一般的销毁回调。
然而，在上下文生命周期中的热刷新或<code>stop</code>刷新时，只会调用销毁方法。</p>
</div>
<p>启动和关闭调用的顺序可能非常重要。如果任何两个对象之间存在“依赖(depends-on)”关系，则依赖方会在其依赖项之后启动，并在其依赖项之前停止。
然而，有时候直接的依赖关系是未知的。你可能只知道某种类型的对象应该在另一种类型的对象之前启动。
在这种情况下，<code>SmartLifecycle</code>接口定义了另一种选择，即其父接口<code>Phased</code>上定义的<code>getPhase()</code>方法。以下代码展示了<code>Phased</code>接口的定义：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Phased</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 返回一个整数值，表示该对象的启动和停止顺序</span>
    <span class="token keyword">int</span> <span class="token function">getPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下面列出了<code>SmartLifecycle</code>接口的定义：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SmartLifecycle</span> <span class="token keyword">extends</span> <span class="token class-name">Lifecycle</span><span class="token punctuation">,</span> <span class="token class-name">Phased</span> <span class="token punctuation">{</span>

    <span class="token comment">// 返回一个boolean值，表示该对象是否应该自动启动</span>
	<span class="token keyword">boolean</span> <span class="token function">isAutoStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 通知该对象已请求停止</span>
	<span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>启动时，<code>phase</code>最低的对象首先启动。停止时，按相反的顺序执行。
因此，实现<code>SmartLifecycle</code>接口并且<code>getPhase()</code>方法返回Integer.MIN_VALUE的对象会是最先启动和最后停止的对象之一。
在另一端，如果阶段值为Integer.MAX_VALUE，则表示该对象应该最后启动并且最先停止（通常是因为它依赖于其他正在运行的进程）。
在考虑<code>phase</code>值时，还要知道任何没有实现<code>SmartLifecycle</code>接口的“正常”<code>Lifecycle</code>对象的默认<code>phase</code>是0。
因此，任何负的<code>phase</code>值表示对象应该在这些标准组件之前启动（并在它们之后停止）。反之，任何正的<code>phase</code>值也是如此。</p>
<p><code>SmartLifecycle</code>定义的<code>stop</code>方法接受一个回调。 任何实现都必须在该实现的关闭过程完成后调用该回调的<code>run()</code>方法。
这使得在必要时可以实现异步关机，因为<code>LifecycleProcessor</code>接口的默认实现<code>DefaultLifecycleProcessor</code>会等待每个阶段内的对象组调用该回调，直到其超时值。
每个阶段的默认超时时间是30秒。你可以通过在上下文中定义一个名为<code>lifecycleProcessor</code>的Bean来覆盖默认的生命周期处理器实例。
如果你只想修改超时时间，定义以下内容就足够了：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lifecycleProcessor<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.context.support.DefaultLifecycleProcessor<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 超时值，单位为毫秒 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeoutPerShutdownPhase<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如前所述，<code>LifecycleProcessor</code>接口还定义了用于刷新和关闭上下文（context ）的回调方法。
后者驱动关闭过程，就像显式调用了<code>stop()</code>方法一样，但它发生在上下文关闭时。
另一方面，“<code>refresh</code>”回调实现了<code>SmartLifecycle</code> Bean的另一个特性。
当上下文被刷新（在所有对象都被实例化和初始化之后）时，该回调被调用。
此时，默认的生命周期处理器会检查每个<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法返回的布尔值。
如果为true，该对象将在此时启动，而不是等待上下文或自身<code>start()</code>方法的显式调用（与上下文刷新不同，上下文的启动不会自动发生在标准的上下文实现中）。
如前所述，<code>phase</code>值和任何"依赖"关系决定了启动的顺序。</p>
<h3>在非Web应用中优雅地关闭Spring IoC容器</h3>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>本节仅适用于非Web应用。Spring的基于Web的<code>ApplicationContext</code>实现已经有代码可以在相关Web应用关闭时优雅地关闭Spring IoC容器。</p>
</div>
<p>如果你在非Web应用程序环境中（例如，在客户端桌面环境中）使用Spring的IoC容器，请向JVM注册一个关闭钩子（shutdown hook）。
这样做可以确保优雅地关闭，并调用你的单例Bean上的相关销毁<code>destroy</code>方法，以释放所有资源。你仍然必须正确配置和实现这些销毁<code>destroy</code>回调。</p>
<p>要注册一个关闭钩子（shutdown hook），调用<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook</code>()方法，如下例所示。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Boot</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
		<span class="token comment">// 加载Spring配置文件并创建应用上下文</span>
		<span class="token class-name">ConfigurableApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 为上述上下文添加一个关闭钩子...</span>
		ctx<span class="token punctuation">.</span><span class="token function">registerShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 应用程序在此处运行...</span>

		<span class="token comment">// main方法退出前，钩子在应用关闭之前被调用...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>线程安全性和可见性</h3>
<p>Spring核心容器以线程安全的方式发布创建的单例实例，通过一个单例锁来保护访问，并确保在其他线程中的可见性。</p>
<p>因此，由应用程序提供的Bean类不必担心其初始化状态的可见性。
只要常规配置字段仅在初始化阶段被修改，它们就不需要被标记为<code>volatile</code>，从而提供了类似于<code>final</code>的可见性保证，
即使是对于在初始阶段可变的基于setter的配置状态也是如此。
如果这些字段在Bean创建阶段之后及其随后的初始发布之后被更改，则需要将它们声明为<code>volatile</code>或在访问时受到公共锁的保护。</p>
<p>请注意，在从容器方面进行安全初始发布后，对单例Bean实例中的这种配置状态进行并发访问
（例如控制器实例或存储库实例） 是完全线程安全的。这还包括通用的单例<code>FactoryBean</code>实例，这些实例也在通用单例锁中进行处理。</p>
<p>对于销毁回调，配置状态仍然是线程安全的，但在初始化和销毁之间累积的任何运行时状态应该保存在线程安全的结构中
（或者对于简单情况，保存在<code>volatile</code>字段中），根据常见的Java指导方针。</p>
<p>如上所示，更深入的生命周期集成涉及到运行时可变状态，例如一个可运行字段，这个字段将需要声明为<code>volatile</code>。
虽然常见的生命周期回调遵循一定的顺序，例如，启动回调只会在完全初始化之后发生，而停止回调只会在初始启动之后发生，
但与常见的停止前销毁安排有一个特殊情况：强烈建议在任何这样的Bean中内部状态也允许在没有先前停止的情况下立即进行销毁回调，
因为这可能会在取消引导时或在由另一个bean引起的停止超时的情况下发生非常规关闭时发生。</p>
<h2>ApplicationContextAware</h2>
<p>当一个类实现了<code>org.springframework.context.ApplicationContextAware</code>接口时，
该类的实例会得到对应的<code>ApplicationContext</code>实例的引用。</p>
<p>以下是<code>ApplicationContextAware</code>接口的定义示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>

	<span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这意味着，当一个Bean实现了<code>ApplicationContextAware</code>接口或 引用了该接口的已知子类（如<code>ConfigurableApplicationContext</code>），
它就可以通过<code>ApplicationContext</code>接口来访问Spring容器的各种功能，
比如访问其他Bean、获取文件资源、发布事件，以及访问<code>MessageSource</code>的功能。
这些额外功能在<a href="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html" target="_blank" rel="noopener noreferrer">ApplicationContext的附加功能</a>
中描述。 不过，通常情况下不推荐过度使用这种方式，因为它会将代码与Spring框架耦合在一起，不符合控制反转的原则。</p>
<p>另一种获得对<code>ApplicationContext</code>引用的方式是通过自动装配（Autowiring）。
你可以使用<code>@Autowired</code>注解来自动装配 ApplicationContext，这样就可以在需要时轻松访问Spring容器的功能。
详细信息可以查阅使用<a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html" target="_blank" rel="noopener noreferrer">使用@Autowired</a>。</p>
<h2>BeanNameAware</h2>
<p>当一个类实现了<code>org.springframework.beans.factory.BeanNameAware</code>接口时，
这个类的实例会得到对应的Bean名称的引用。</p>
<p>以下是<code>BeanNameAware</code>接口的定义示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanNameAware</span> <span class="token punctuation">{</span>

	<span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>回调方法会在Bean的属性填充后 &amp; 初始化回调之前（如<code>InitializingBean.afterPropertiesSet</code>() 或 自定义<code>init</code>方法）被调用。
通过实现<code>BeanNameAware</code>接口，Bean可以在需要时获取自己在Spring容器中的名称，这在某些场景下可能会很有用。</p>
<h2>其他Aware接口</h2>
<p>除了之前讨论的<code>ApplicationContextAware</code>和<code>BeanNameAware</code>，Spring还提供了一系列广泛的<code>Aware</code>回调接口，
让Bean向容器表明它们需要某种基础设施的依赖性。通常，接口名称反映了依赖的类型。以下表格总结了最重要的<code>Aware</code>接口：</p>
<p>| Aware 接口                         | 注入的依赖                       | 解释                                                                                                                                                                                |
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bean作用域（Scope）</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/beans-scope.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/beans-scope.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Bean作用域（Scope）</source>
      <description>Bean作用域（Scope） 当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。 将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。 你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。 这种方法是强...</description>
      <category>Spring</category>
      <pubDate>Wed, 03 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>当你创建一个Bean定义时，实际上是在创建Bean定义所定义类的实际实例的配方。
将Bean定义视为“配方”的概念非常重要，因为它意味着，就像一个类一样，你可以从一个单一的“配方”中创建多个对象实例。</p>
<p>你不仅可以控制Bean定义中的各种依赖项和配置值，还可以控制由Bean定义创建的对象的作用域（scope）。
这种方法是强大且灵活的，因为你可以通过配置选择创建的对象的作用域，而不必在Java类级别上固定对象的作用域。
Bean定义可以是多种作用域之一。Spring框架支持六种作用域，其中四种仅在使用Web感知（aware）的<code>ApplicationContext</code>时才可用。
你还可以创建<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-custom" target="_blank" rel="noopener noreferrer">自定义作用域</a>。</p>
<p>| Bean作用域（Scope） | 描述                                   |
|</p>
]]></content:encoded>
      <enclosure url="http://img.geekyspace.cn/pictures/2024/singleton.png" type="image/png"/>
    </item>
    <item>
      <title>Bean定义继承</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/child-bean-definitions.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/child-bean-definitions.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Bean定义继承</source>
      <description>Bean定义继承 一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。 一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。 使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。 如果你以编程方式使用ApplicationCon...</description>
      <category>Spring</category>
      <pubDate>Wed, 10 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>一个Bean定义可以包含大量的配置信息，包括构造函数参数、属性值以及容器特定的信息，比如初始化方法、静态工厂方法名称等等。
一个子Bean定义会从父定义中继承配置数据。子定义可以根据需要覆盖一些值或添加其他值。
使用父子Bean定义可以节省大量的输入工作。实际上，这是一种模板化的形式。</p>
<p>如果你以编程方式使用<code>ApplicationContext</code>接口，子Bean定义由<code>ChildBeanDefinition</code>类表示。
大多数用户不会在这个层面上直接操作它们。相反，他们会在诸如<code>ClassPathXmlApplicationContext</code>之类的类中以声明性方式配置Bean定义。
当你使用基于XML的配置元数据时，可以通过使用<code>parent</code>属性指定父Bean来表示子Bean定义，将父Bean作为此属性的值。以下示例展示了如何这样做：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 抽象的父Bean定义 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritedTestBean<span class="token punctuation">"</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.beans.TestBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 设置name属性为parent --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 设置age属性为1 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 继承父Bean定义的子Bean --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritsWithDifferentClass<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.beans.DerivedTestBean<span class="token punctuation">"</span></span>
		<span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritedTestBean<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>initialize<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>override<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 覆盖name属性为override --&gt;</span>
	<span class="token comment">&lt;!-- age属性的值1将从父Bean继承 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子Bean定义如果未指定Bean类，则会使用父定义中的Bean类，但也可以覆盖它。
在后一种情况下，子Bean类必须与父Bean类兼容（即，它必须接受父Bean的属性值）。</p>
<p>子Bean定义从父Bean继承作用域（Scope）、构造函数参数值、属性值和方法重写，并有添加新值的选项。
你指定的任何作用域、初始化方法、销毁（destroy）方法或静态（static）工厂方法设置都会覆盖相应的父设置。</p>
<p>剩余的设置始终来自于子Bean定义：依赖（depends on）、自动注入（autowire）模式、依赖检查、singleton以及懒加载（lazy init）。</p>
<p>在上面的示例中，通过使用<code>abstract</code>属性显式地将父Bean定义标记为抽象。
如果父定义没有指定类，则需要显式地将父Bean定义标记为抽象，如下面的示例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 抽象的父Bean定义，未指定类 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritedTestBeanWithoutClass<span class="token punctuation">"</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- 继承父Bean定义的子Bean --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritsWithClass<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.beans.DerivedTestBean<span class="token punctuation">"</span></span>
      <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inheritedTestBeanWithoutClass<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>initialize<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>override<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 覆盖name属性为override --&gt;</span>
    <span class="token comment">&lt;!-- age 属性将继承父Bean定义中的值1 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>父Bean定义不能单独实例化，因为它是不完整的，并且也明确标记为<code>abstract</code>。
当一个定义是<code>abstract</code>的时候，它只能作为纯模板Bean定义使用，用作子定义的父定义。
尝试单独使用这样的<code>abstract</code>父Bean，通过将其作为另一个Bean的<code>ref</code>属性引用或者显式地使用<code>getBean()</code>方法调用父Bean的ID，都会返回错误。
同样，容器的内部<code>preInstantiateSingletons()</code>方法会忽略那些被定义为抽象的Bean定义。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p><code>ApplicationContext</code> 默认预设了所有的单例Bean。因此，重要的是（至少对于单例Bean来说），
如果你有一个（父）Bean定义，你打算只作为模板使用，并且这个定义指定了一个类，你必须确保将<code>abstract</code>属性设置为
true，否则应用上下文将尝试预实化<code>abstract</code> Bean。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>IoC 容器（Container）</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/ioc-container.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/ioc-container.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">IoC 容器（Container）</source>
      <description>IoC 容器（Container） 概述 Spring IoC（控制反转）容器是Spring框架的核心。 org.springframework.context.ApplicationContext接口代表Spring IoC容器，负责实例化、配置和组装Bean。 Spring提供了几个 ApplicationContext 接口的实现，在独立应用程序...</description>
      <category>Spring</category>
      <pubDate>Mon, 18 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>概述</h2>
<blockquote>
<p>Spring IoC（控制反转）容器是Spring框架的核心。
<code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，负责实例化、配置和组装<code>Bean</code>。</p>
</blockquote>
<p>Spring提供了几个 ApplicationContext 接口的实现，在独立应用程序中，最常用的是：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="noopener noreferrer">ClassPathXmlApplicationContext</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="noopener noreferrer">FileSystemXmlApplicationContext</a></li>
<li>等等</li>
</ul>
<p><strong>支持以XML、Java注释或Java代码作为配置元数据的格式</strong></p>
<p>虽然<code>XML</code>一直是定义配置元数据的传统格式， 但你可以通过提供少量的<code>XML</code>配置来指定容器使用<code>Java注解</code>或<code>Java代码</code>作为元数据格式。
以声明式方式启用对这些元数据格式的支持，从而更灵活地定义应用程序的配置信息。</p>
<p><strong>为Web应用程序提供方便的ApplicationContext实例化</strong></p>
<p>在大多数应用场景中，无需手动编写代码来实例化<strong>Spring IoC</strong>容器；
例如：在Web应用场景中，通常只需要在应用程序的<code>web.xml</code>文件中编写 8
行（或更多）<a href="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create" target="_blank" rel="noopener noreferrer">模板式的Web描述符</a>
即可初始化<code>ApplicationContext</code></p>
<p><strong>解析Spring框架的工作原理：<mark>应用程序类</mark>与<mark>配置元数据</mark>的整合</strong></p>
<p>下图表展示了Spring框架的工作原理高层视图。通过将你的应用程序类与配置元数据结合起来，
一旦<code>ApplicationContext</code>被创建和初始化，你就获得了一个完全配置且可执行的系统或应用程序。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/202403181756387.png" alt="Spring IoC容器" tabindex="0" loading="lazy"><figcaption>Spring IoC容器</figcaption></figure>
<h2>配置元数据</h2>
<p>如上图所示，Spring IoC容器消费配置元数据。
这种配置元数据代表了你作为一个应用开发者，如何告诉Spring容器在你的应用中实例化、配置和组装对象。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p><strong>注意⚠️</strong>：Spring IoC容器本身与实际配置元数据的编写格式完全解耦。
如今，许多开发者选择使用<a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html" target="_blank" rel="noopener noreferrer">基于Java的容器配置</a>
来构建他们的Spring应用程序。</p>
</div>
<p>有关在<code>Spring</code>容器中使用其他形式的元数据信息，参阅：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html" target="_blank" rel="noopener noreferrer">基于XML的容器配置</a></li>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html" target="_blank" rel="noopener noreferrer">基于注解的容器配置</a>（Spring
2.5开始支持）</li>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html" target="_blank" rel="noopener noreferrer">基于Java的容器配置</a>（Spring
3.0开始支持；参阅 <a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/annotation/Configuration.html" target="_blank" rel="noopener noreferrer">@Configuration</a>, <a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/annotation/Bean.html" target="_blank" rel="noopener noreferrer">@Bean</a>,
<a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/annotation/Import.html" target="_blank" rel="noopener noreferrer">@Import</a>,
和 <a href="https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/context/annotation/DependsOn.html" target="_blank" rel="noopener noreferrer">@DependsOn</a>
注解）</li>
</ul>
<p>Spring的配置包含至少一个，通常是多个<code>&lt;bean&gt;</code>元素。容器必须管理这些定义的bean。</p>
<ul>
<li>XML配置：将这些Bean配置为顶层 <code>&lt;beans/&gt;</code> 元素内的 <code>&lt;bean/&gt;</code> 元素</li>
<li>Java配置：将这些Bean配置为<code>@Configuration</code>类中的<code>@Bean</code>注解的方法</li>
</ul>
<p>这些Bean的定义对应于构成应用程序的实际对象，
如服务层对象，持久层对象（Dao），表示层对象（Web控制器），基础设施对象（JPA EntityManagerFactory），JMS队列等。
通常，人们不会在容器中配置细粒度的<code>domain</code>对象，因为创建和加载<code>domain</code>对象的通常是<code>repository</code>和<code>service</code>层逻辑的责任。</p>
<p>下面的例子显示了基于XML的配置元数据的基本结构：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>(1) (2)
        <span class="token comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 更多bean 定义在这里 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol>
<li><code>id</code>属性是一个字符串，用于<mark>唯一标识</mark>Bean</li>
<li><code>class</code>属性是一个字符串，用于指定Bean的<mark>完整类名</mark>（包括包名）</li>
</ol>
<p><code>id</code>属性的值可以用来指代其他Bean的<code>ref</code>属性，从而实现Bean之间的依赖关系。
参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html" target="_blank" rel="noopener noreferrer">依赖</a>。</p>
<h2>实例化容器</h2>
<p>提供给<code>ApplicationContext</code>
构造函数的一条或多条路径是<mark>资源字符串</mark>，它让容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code>
等）加载配置元数据。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"services.xml"</span><span class="token punctuation">,</span> <span class="token string">"daos.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="hint-container note">
<p class="hint-container-title">注</p>
<p>了解更多关于<a href="https://docs.spring.io/spring-framework/reference/core/resources.html" target="_blank" rel="noopener noreferrer">资源加载</a>的信息；
它提供了一种简单的方法，可以从<code>URI</code>语法中定义的位置读取<code>InputStream</code>。 特别是，<code>Resource</code>路径被用来构建应用程序上下文， 如
<a href="https://docs.spring.io/spring-framework/reference/core/resources.html#resources-app-ctx" target="_blank" rel="noopener noreferrer">Application Context和资源路径</a>
中所述。</p>
</div>
<p>以下示例显示了<strong>服务层对象</strong><code>services.xml</code> 配置文件：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- services --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>petStore<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.samples.jpetstore.services.PetStoreServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>itemDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>itemDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 更多服务的bean 定义在这里 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>以下示例显示<strong>数据访问对象</strong>（data access object）<code>daos.xml</code> 文件：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span>
          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>itemDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.samples.jpetstore.dao.jpa.JpaItemDao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 这个bean的协作者和配置在这里 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 更多数据访问对象的bean 定义在这里 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在前面的示例中，服务层由 <code>PetStoreServiceImpl</code> 类和两个类型为 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code> 的数据访问对象组成（基于JPA对象-关系映射标准）。</p>
<ul>
<li><code>property name</code> 元素指的是<code>JavaBean</code>属性的名称</li>
<li><code>ref</code> 元素指的是引用另一个<code>Bean</code>定义的名称</li>
</ul>
<p><code>id</code> 和 <code>ref</code>元素之间的这种联系，表达了协作对象之间的依赖关系。
有关配置对象依赖项的详细信息，参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html" target="_blank" rel="noopener noreferrer">依赖</a>。</p>
<h2>使用容器</h2>
<p><code>ApplicationContext</code>是一个高级工厂的接口，能够维护不同Bean及其依赖关系的注册表。
通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，你可以检索到Bean的实例。</p>
<p><code>ApplicationContext</code>可以让你读取Bean定义（definition）并访问它们，如下例所示。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建和配置Bean</span>
<span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"services.xml"</span><span class="token punctuation">,</span> <span class="token string">"daos.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 检索配置的实例</span>
<span class="token class-name">PetStoreService</span> service <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"petStore"</span><span class="token punctuation">,</span> <span class="token class-name">PetStoreService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用配置的实例</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> userList <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">getUsernameList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>不直接依赖于Spring的API</strong></p>
<blockquote>
<p>理想情况下，应用程序代码不应该直接依赖于Spring的API，而是通过元数据（如自动装配<code>@Autowired</code>注解）声明对特定Bean的依赖。</p>
</blockquote>
<p>虽然 ApplicationContext 接口提供了一些检索 Bean 的方法，如 getBean() 等，但在设计上，应该避免直接依赖这些方法。</p>
<p>例如，Spring与Web框架的集成为各种<strong>Web框架组件</strong>（如Controller控制器和JSF管理的Bean）提供了依赖注入的能力，
使得你可以通过元数据（如<code>@Autowired</code>注解）声明对特定<code>Bean</code>的依赖，而不必直接调用<code>getBean()</code>等方法。
这样可以使代码更加模块化、可维护性更高。</p>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/202403181756387.png" type="image/png"/>
    </item>
    <item>
      <title>Spring Framework 概述</title>
      <link>https://www.geekyspace.cn/md/spring-framework/overview/</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/overview/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring Framework 概述</source>
      <description>Spring Framework 概述 Spring Framework 简介 Spring是一个开源、轻量级、依赖注入(DI)容器和框架，用于构建Java企业应用程序。 Spring 官网：spring.io Spring 中文网：springdoc.cn 为什么使用Spring？ 官网解释：why-spring Spring让Java编程变得更快、...</description>
      <category>Spring</category>
      <pubDate>Fri, 15 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>Spring Framework 简介</h2>
<p>Spring是一个开源、轻量级、依赖注入(DI)容器和框架，用于构建Java企业应用程序。</p>
<ul>
<li>Spring 官网：<a href="https://docs.spring.io/spring-framework/reference/" target="_blank" rel="noopener noreferrer">spring.io</a></li>
<li>Spring 中文网：<a href="https://springdoc.cn/spring/" target="_blank" rel="noopener noreferrer">springdoc.cn</a></li>
</ul>
<h2>为什么使用Spring？</h2>
<blockquote>
<p>官网解释：<a href="https://spring.io/why-spring" target="_blank" rel="noopener noreferrer">why-spring</a></p>
<p>Spring让Java编程变得更快、更容易、更安全。
Spring对速度、简单性和生产力的关注使其成为世界上最受欢迎的Java框架。</p>
</blockquote>
<p>我们使用了许多Spring框架提供的工具，并受益于许多<mark>开箱即用</mark>的解决方案，
无需担心编写大量额外的代码，因此这确实为我们节省了时间和精力。</p>
<h2>核心思想</h2>
<p>Spring的核心思想是 <strong>控制反转（IOC）</strong> 和 <strong>面向切面编程（AOP）</strong>。</p>
<p><strong>控制反转（IoC）</strong></p>
<p>控制反转是一种设计模式，它将对象的创建和对象之间的依赖关系的管理交给了Spring IoC容器。
在传统的开发模式中，对象的创建和对象之间的依赖关系的管理都是由程序员来完成的。</p>
<p><strong>面向切面编程（AOP）</strong></p>
<p>面向切面编程是一种编程范式，它将程序的业务逻辑和系统级服务（如日志，事务，安全等）分开，通过横切关注点的方式来解耦。
在传统的开发模式中，业务逻辑和系统级服务是混在一起的，这样会导致代码的复杂性增加。</p>
<h2>版本支持</h2>
<p>我们建议尽可能从Maven Central升级到最新的<strong>Spring Framework 6.0.x / 5.3.x</strong> 版本</p>
<p>在Spring Framework 6.0中， Spring需要Java 17+。</p>
<ul>
<li>6.2.x (2024年11月) - 下一个功能分支</li>
<li>6.1.x (2023年11月) - 即将推出的功能分支</li>
<li>6.0.x (2022年11月) - 主要生产线，基于JDK 17和Jakarta EE 9</li>
<li>5.3.x - 第五代最终功能分支，长期支持，支持JDK 8、11、17和Java EE 8</li>
<li>4.3.x - EOL (2020年12月31日)，不再提供维护和安全补丁</li>
<li>3.2.x - EOL (2016年12月31日)，不再提供维护和安全补丁</li>
</ul>
<p>您可以在 <a href="https://spring.io/projects/spring-framework#support" target="_blank" rel="noopener noreferrer">spring.io#support</a>上找到有关官方支持日期的更多信息。</p>
<h2>入门指南</h2>
<p>使用<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener noreferrer">Spring Boot</a>来快速创建生产就绪的Spring应用程序</p>
<ul>
<li>您可以通过<a href="start.spring.io">start.spring.io</a>生成基本项目</li>
<li>或者遵循"<a href="https://spring.io/guides" target="_blank" rel="noopener noreferrer">入门指南</a>"
之一，例如"<a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener noreferrer">开始构建RESTful Web服务</a>"</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Spring Framework 快速开始</title>
      <link>https://www.geekyspace.cn/md/spring-framework/overview/quickstart.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/overview/quickstart.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Spring Framework 快速开始</source>
      <description>Spring Framework 快速开始 IntelliJ IDEA 提供的专用项目向导，您能够快速创建Spring应用程序，这也是创建Spring应用程序的最佳方式之一。 参考🚀 ：Jetbrains 创建第一个Spring应用程序 在本教程中，您将学习如何公开HTTP端点并将其映射到一个方法，当用户通过Web浏览器访问时，该方法会向用户返回问候...</description>
      <category>Spring</category>
      <pubDate>Fri, 15 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p><strong>IntelliJ IDEA</strong> 提供的专用项目向导，您能够快速创建Spring应用程序，这也是创建Spring应用程序的最佳方式之一。</p>
</blockquote>
<p>参考🚀 ：<a href="https://www.jetbrains.com/help/idea/your-first-spring-application.html" target="_blank" rel="noopener noreferrer">Jetbrains 创建第一个Spring应用程序</a></p>
<p>在本教程中，您将学习如何公开HTTP端点并将其映射到一个方法，当用户通过Web浏览器访问时，该方法会向用户返回问候信息。</p>
<h2>创建 Spring Boot项目</h2>
<ol>
<li>在主菜单中，转到 <strong>文件(File) | 新建(New) | 项目(Project)</strong></li>
<li>在 <strong>新建项目(New Project)</strong> 对话框中，选择 <code>Spring Initializr</code></li>
<li>指定项目的名称 <mark>spring-boot-tutorial</mark>，单击 <strong>下一步(Next)</strong> 继续</li>
</ol>
<figure><img src="https://img.geekyspace.cn/pictures/2024/spring-new-project-initializr.png" alt="Spring Initializr in the New Project wizard" tabindex="0" loading="lazy"><figcaption>Spring Initializr in the New Project wizard</figcaption></figure>
<ol start="4">
<li>在<strong>Web</strong>组下选择<strong>Spring Web</strong>依赖项，然后单击 <strong>创建(Create)</strong> 生成并设置项目</li>
</ol>
<figure><img src="https://img.geekyspace.cn/pictures/2024/spring-new-project-dependencies.png" alt="Spring Dependencies in the New Project wizard" tabindex="0" loading="lazy"><figcaption>Spring Dependencies in the New Project wizard</figcaption></figure>
<h2>添加 sayHello() 方法</h2>
<p><code>Spring Initializr</code> 会创建一个带有 <code>main()</code> 方法的类来启动你的 Spring 应用程序。</p>
<ol>
<li>转到 "<strong>导航(Navigate) | 文件(File )</strong>"，搜索<code>SpringBootTutorialApplication.java</code>文件并打开</li>
</ol>
<figure><img src="https://img.geekyspace.cn/pictures/2024/spring-boot-tutorial-gotofile.png" alt="Using Go To File to open SpringBootTutorialApplication.java" tabindex="0" loading="lazy"><figcaption>Using Go To File to open SpringBootTutorialApplication.java</figcaption></figure>
<ol start="2">
<li>添加 <code>sayHello()</code> 方法，并包含所有必要的注解和导入：</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>springboottutorial</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">GetMapping</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestParam</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootTutorialApplication</span> <span class="token punctuation">{</span>

   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringBootTutorialApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>
   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"myName"</span><span class="token punctuation">,</span> defaultValue <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hello %s!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p><code>sayHello()</code>方法接受一个名字参数，并返回与参数值组合的<code>Hello</code>单词。其余的工作由添加Spring注解来处理：</p>
<ul>
<li><code>@RestController</code>注解将<code>SpringBootTutorialApplication</code>类标记为请求处理程序（<mark>REST控制器</mark>）。</li>
<li><code>@GetMapping("/hello")</code>注解将<code>sayHello()</code>方法<mark>映射</mark>到GET请求的<code>/hello</code>路径。
*<code> @RequestParam</code>注解将名字<strong>方法参数</strong><mark>映射</mark>到<code>myName</code> Web请求参数。如果您在Web请求中未提供<code>myName</code>
参数，则默认为<code>World</code>。</li>
</ul>
<h2>运行Spring应用程序</h2>
<p><strong>IntelliJ IDEA</strong> 创建了一个<code> Spring Boot</code> 运行配置，您可以使用它来运行新 <code>Spring</code> 应用程序。</p>
<ul>
<li>如果选择了运行配置，请按 <code>Shift</code> <code>F10</code>键。</li>
<li>还可以点击 <code>SpringBootTutorialApplication.java</code> 文件<code> main()</code>方法旁边的▶️图标运行。</li>
</ul>
<p>默认情况下，IntelliJ IDEA 会在运行工具窗口中显示你正在运行的 Spring Boot 应用程序。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/spring-boot-demo-run-console_dark.png" alt="The Run tool window with a running Spring Boot application" tabindex="0" loading="lazy"><figcaption>The Run tool window with a running Spring Boot application</figcaption></figure>
<p>控制台选项卡显示 Spring 日志消息的输出。
默认情况下，内置的 Apache Tomcat 服务器正在监听端口 8080。
打开你的网络浏览器并访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener noreferrer">http://localhost:8080/hello</a>。
如果你操作正确，你应该会看到你的应用程序以 Hello World! 回应。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/spring-boot-web-browser-hello-world.png" alt="Spring Boot Hello World response in the browser" tabindex="0" loading="lazy"><figcaption>Spring Boot Hello World response in the browser</figcaption></figure>
<p>这是默认的响应。你可以在你的网络请求中提供一个参数，让应用程序知道如何适当地问候你。
例如，尝试访问 <a href="http://localhost:8080/hello?myName=Human" target="_blank" rel="noopener noreferrer">http://localhost:8080/hello?myName=Human</a>。</p>
<h2>添加主页</h2>
<p>创建的 Spring Boot 应用程序在 <code>/hello</code> 路径下有一个端点可用。
然而，如果你在 <a href="http://localhost:8080/" target="_blank" rel="noopener noreferrer">http://localhost:8080/</a> 中打开你的应用程序的根上下文，你会收到错误，因为没有定义根资源。
让我们添加一个静态 HTML 首页，其中包含指向你端点的链接。</p>
<ol>
<li>请在 <code>/src/main/resources/static/</code> 下创建 <code>index.html</code> 文件。</li>
<li>你可以修改默认模板或者使用以下 HTML 代码替换它：</li>
</ol>
<div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>您的第一个 Spring 应用程序<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html; charset=UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/hello<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>问候全世界！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ifm</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/hello<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GET<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nameForm<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nameField<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>应用程序应该怎样称呼您？<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myName<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nameField<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>问候我！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ifm</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>3.在运行工具窗口中，点击 "<strong>重新运行</strong>" 按钮，或按下 <code>Shift</code> + <code>F10</code>。
现在你的应用程序将会在 <a href="http://localhost:8080/" target="_blank" rel="noopener noreferrer">http://localhost:8080/</a> 上作为根资源提供 <code>index.html</code> 页面。</p>
<figure><img src="https://img.geekyspace.cn/pictures/2024/image-20240316015405566.png" alt="image-20240316015405566" tabindex="0" loading="lazy"><figcaption>image-20240316015405566</figcaption></figure>
<h2>下一个教程</h2>
<p>这个简单的应用程序演示了如何开始使用 Spring。 要了解 IntelliJ IDEA 如何帮助你编写代码并在运行时管理应用程序，
请参考下一个教程，该教程重点介绍更高级的 <a href="https://www.jetbrains.com/help/idea/spring-support-tutorial.html" target="_blank" rel="noopener noreferrer">Spring 支持功能</a>。</p>
]]></content:encoded>
      <enclosure url="https://img.geekyspace.cn/pictures/2024/spring-new-project-initializr.png" type="image/png"/>
    </item>
    <item>
      <title>依赖（Dependencies）</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">依赖（Dependencies）</source>
      <description>依赖（Dependencies） 企业应用程序通常不是由单个对象（或Spring术语中的Bean）构成的。 即使是最简单的应用程序，也是由多个对象共同协作来呈现给最终用户一个连贯的应用体验。 下一节将解释如何从定义独立的Bean开始，逐步实现一个完整的应用程序。 在这个应用程序中，各个对象将相互协作，实现一个共同的目标。 章节摘要</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>企业应用程序通常不是由单个对象（或<code>Spring</code>术语中的<code>Bean</code>）构成的。
即使是最简单的应用程序，也是由多个对象共同协作来呈现给最终用户一个连贯的应用体验。</p>
<p>下一节将解释如何从定义独立的Bean开始，逐步实现一个完整的应用程序。
在这个应用程序中，各个对象将相互协作，实现一个共同的目标。</p>
<h2>章节摘要</h2>
<ul>
<li><a href="/md/spring-framework/core/dependencies/factory-collaborators.html" target="_blank">依赖注入</a></li>
<li><a href="/md/spring-framework/core/dependencies/factory-properties-detailed.html" target="_blank">依赖和配置详解</a></li>
<li><a href="/md/spring-framework/core/dependencies/factory-dependson.html" target="_blank">使用depends-on</a></li>
<li><a href="/md/spring-framework/core/dependencies/factory-lazy-init.html" target="_blank">懒加载Bean</a></li>
<li><a href="/md/spring-framework/core/dependencies/factory-autowire.html" target="_blank">自动装配协作者</a></li>
<li><a href="/md/spring-framework/core/dependencies/factory-method-injection.html" target="_blank">方法注入</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>自动装配协作者</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-autowire.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-autowire.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">自动装配协作者</source>
      <description>自动装配协作者（Autowiring Collaborators） Spring容器可以自动装配协作Bean之间的关系。 你可以通过检查ApplicationContext的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。 自动装配的优势 减少手动配置：自动装配可以显著减少对手动指定属性或构造方法参数的需求。 其他机制 ，如bean...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>Spring容器可以自动装配协作Bean之间的关系。
你可以通过检查<code>ApplicationContext</code>的内容，让Spring自动为你的Bean解析协作对象（其他Bean）。</p>
<p><strong>自动装配的优势</strong></p>
<ul>
<li><strong>减少手动配置</strong>：自动装配可以显著减少对手动指定属性或构造方法参数的需求。
<a href="https://docs.spring.io/spring-framework/reference/core/beans/child-bean-definitions.html" target="_blank" rel="noopener noreferrer">其他机制</a>
，如bean模板，在这方面也是非常有价值的。</li>
<li><strong>动态更新配置</strong>：随着项目的发展，对象可能会增加新的依赖。自动装配能够适应这种变化，自动满足新的依赖关系，而无需手动更新配置。
这一点在项目的迭代开发过程中尤为有用。同时，当项目稳定下来后，开发者仍然可以选择切换到显式装配，以获得更精确的控制。</li>
</ul>
<p><strong>四种自动装配模式</strong></p>
<p>在使用XML配置时，
（参阅 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html" target="_blank" rel="noopener noreferrer">依赖注入</a>），
可以通过<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性来定义Bean的自动装配模式。
Spring提供了四种自动装配模式，允许你为每个Bean单独指定使用哪种模式。以下是这四种模式的详细描述：</p>
<p>| 模式          | 描述                                                                                                                                           |
|</p>
]]></content:encoded>
    </item>
    <item>
      <title>依赖注入</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-collaborators.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-collaborators.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">依赖注入</source>
      <description>依赖注入 依赖注入（DI）是什么？ Spring IoC（控制反转）也被称为依赖注入（DI） 它是一个过程，对象仅通过构造参数、工厂方法参数或在对象实例被构造函数或工厂方法返回后，在其上设置的属性来定义它们的依赖关系。 在IoC容器创建Bean时，它会自动注入这些依赖项。 不再需要通直接构造依赖项或使用服务定位器模式等方式来管理对象的实例化或位置， 而...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>依赖注入（DI）是什么？</h2>
<p><strong>Spring IoC（控制反转）也被称为依赖注入（DI）</strong></p>
<p>它是一个过程，对象仅通过构造参数、工厂方法参数或在<strong>对象实例</strong>被构造函数或工厂方法返回后，在其上设置的属性来定义它们的依赖关系。
在IoC容器创建Bean时，它会自动注入这些依赖项。 不再需要通<code>直接构造依赖项</code>或使用<code>服务定位器模式</code>等方式来管理对象的实例化或位置，
而是交由IoC容器来管理，因此称为<strong>控制反转</strong>。</p>
<p><strong>DI解耦</strong></p>
<p>采用依赖注入（DI）原则，可以使代码更干净简洁，同时也更有效地解耦。
通过DI，对象不需要查找其依赖，也不知道依赖的位置或类别。
因此，你的类变得更易于测试，特别是当依赖是在接口或抽象基类上时，可以使用<code>stub</code>或<code>mock</code>进行单元测试。
这种方式使代码更加整洁，同时也更符合面向对象的设计原则。</p>
<p>DI有两个主要的变体。 基于<a href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">构造器的依赖注入</a>和<a href="#%E5%9F%BA%E4%BA%8Esetter%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">基于Setter的依赖注入</a>。</p>
<h2>基于构造函数的依赖注入</h2>
<p><strong>基于构造函数的依赖注入</strong>是容器（如Spring框架）调用具有多个参数的构造函数来实现，每个参数代表一个依赖项，容器负责在创建Bean时注入这些依赖项。
<strong>与静态工厂方法的比较</strong>构造Bean几乎是等价的。</p>
<p>以下示例通过构造函数进行依赖注入：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleMovieLister</span> <span class="token punctuation">{</span>

    <span class="token comment">// SimpleMovieLister 依赖于 MovieFinder</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MovieFinder</span> movieFinder<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数，以便Spring容器可以注入MovieFinder</span>
    <span class="token keyword">public</span> <span class="token class-name">SimpleMovieLister</span><span class="token punctuation">(</span><span class="token class-name">MovieFinder</span> movieFinder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>movieFinder <span class="token operator">=</span> movieFinder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略了实际使用注入的 MovieFinder 的业务逻辑...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个类并没有什么特别之处。它是一个普通的POJO（简单的Java对象），不依赖于容器特定的接口、基类或注解。</p>
<h3>构造函数参数解析</h3>
<p><strong>1.按定义的顺序传递构造函数的参数（参数无歧义时）</strong></p>
<p>构造函数参数的解析匹配是通过使用参数的类型来完成的。
如果Bean定义中的构造函数参数不存在歧义， 那么构造函数参数的顺序就是Bean定义中的定义顺序。
这样在实例化Bean时，Spring IoC容器就会按照定义的顺序传递参数。 请考虑以下这个类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">x<span class="token punctuation">.</span>y</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThingOne</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">ThingOne</span><span class="token punctuation">(</span><span class="token class-name">ThingTwo</span> thingTwo<span class="token punctuation">,</span> <span class="token class-name">ThingThree</span> thingThree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设<code>ThingTwo</code>和<code>ThingThree</code>类没有继承关系，不存在潜在的歧义。
因此，下面的配置可以正常工作，你不需要在<code>&lt;constructor-arg/&gt;</code>元素中显示指定构造函数参数的索引或类型。</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingOne<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingTwo<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingThree<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>2.使用<code>type</code>属性显式指定构造函数参数的类型</strong></p>
<p>当引用另一个Bean时，类型是已知的，并且可以进行匹配（就像前面的例子那样）。
但是，当使用简单类型时，比如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring不能确定值的类型，所以在没有帮助的情况下不能通过类型进行匹配。
请考虑以下这个类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">examples</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

	<span class="token comment">// 用于计算终极答案的年数</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> years<span class="token punctuation">;</span>

	<span class="token comment">// 生命、宇宙和万物的终极答案</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ultimateAnswer<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span><span class="token keyword">int</span> years<span class="token punctuation">,</span> <span class="token class-name">String</span> ultimateAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>years <span class="token operator">=</span> years<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>ultimateAnswer <span class="token operator">=</span> ultimateAnswer<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述情况下，可以通过使用<code>type</code>属性显式指定构造函数参数的类型，容器就对简单类型进行类型匹配，如下例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7500000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>42<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>3.使用<code>index</code>属性显示指定构造函数参数的索引</strong></p>
<p>你还可以使用<code>index</code>属性显示指定构造函数参数的索引，如下例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7500000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>42<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>除了解决多个简单值的歧义外，指定索引还可以解决构造函数具有两个相同类型参数的歧义问题。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p><strong>注意⚠️</strong>：索引（下标）从0开始。</p>
</div>
<p>你还可以使用构造函数的参数名称来消除值的歧义，如下例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>years<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7500000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ultimateAnswer<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>42<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>4.使用<code>@ConstructorProperties</code>指定构造函数参数名称</strong></p>
<p>请记住，要使这一方法开箱即用，代码在编译时必须启用<code>debug</code>标志，以便Spring可以从构造函数中查找参数名称。</p>
<p>如果你不想用<code>debug</code>标志编译你的代码，
可以使用<a href="https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html" target="_blank" rel="noopener noreferrer">@ConstructorProperties</a>
JDK注解来显式命名你的构造函数参数。 示例类将如下所示：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">examples</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

	<span class="token comment">// 省略字段</span>

    <span class="token comment">// 指定构造函数属性，以便Spring容器可以注入参数</span>
	<span class="token annotation punctuation">@ConstructorProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"years"</span><span class="token punctuation">,</span> <span class="token string">"ultimateAnswer"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span><span class="token keyword">int</span> years<span class="token punctuation">,</span> <span class="token class-name">String</span> ultimateAnswer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>years <span class="token operator">=</span> years<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>ultimateAnswer <span class="token operator">=</span> ultimateAnswer<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>基于Setter的依赖注入</h2>
<p><strong>基于Setter的依赖注入（DI）</strong> 是指容器在调用<code>无参构造函数</code>或<code>无参静态工厂方法</code>实例化Bean后，调用Setter方法来实现的。</p>
<p>以下示例展示了一个只能通过Setter进行依赖注入的类。这个类是传统的Java类，是一个普通的POJO，不依赖于容器特定的接口、基类或注解。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleMovieLister</span> <span class="token punctuation">{</span>

    <span class="token comment">// SimpleMovieLister 依赖于 MovieFinder</span>
    <span class="token keyword">private</span> <span class="token class-name">MovieFinder</span> movieFinder<span class="token punctuation">;</span>

    <span class="token comment">// Setter方法，以便Spring容器可以注入MovieFinder</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMovieFinder</span><span class="token punctuation">(</span><span class="token class-name">MovieFinder</span> movieFinder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>movieFinder <span class="token operator">=</span> movieFinder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略了实际使用注入的 MovieFinder 的业务逻辑...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>ApplicationContext的依赖注入支持</strong>：<code>ApplicationContext</code>在管理的<code>Bean</code>时支持基于构造函数和基于Setter的依赖注入（DI）。
此外，它还支持通过构造函数注入依赖项后，再使用Setter方法注入其他依赖项。
<strong>配置依赖关系和属性转换</strong>：你可以通过<code>BeanDefinition</code>来配置依赖关系，并利用<code>java.beans.PropertyEditor</code>
接口实例将属性值从一种格式转换为另一种格式。
<strong>Spring用户的使用方式</strong>：然而，大多数Spring用户并不直接使用这些类（即以编程方式），而是使用XML Bean定义、
注解组件（即使用<code>@Component</code>、<code>@Controller</code>等注解的类），
或基于Java的<code>@Configuration</code>类中的<code>@Bean</code>方法。
<strong>内部转换为BeanDefinition</strong>：然后，这些来源在内部被转换为<code>BeanDefinition</code>的实例，并用于加载整个Spring IoC容器实例。</p>
<div class="hint-container tip">
<p class="hint-container-title">基于构造器的DI还是基于Setter的DI？</p>
<p>通常建议对于必要的依赖项使用构造函数注入（DI），对于可选的依赖项使用Setter方法或配置方法进行注入。
需要注意的是，在Setter方法上使用<a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html" target="_blank" rel="noopener noreferrer">@Autowired</a>
注解也可以使属性标记为必需的依赖项；但是，带有参数的程序化验证的构造函数注入更为推荐。</p>
<p>Spring团队倡导使用构造函数注入，它允许你将应用程序组件实现为不可变<code>final</code>对象，并确保了所需的依赖项不是<code>null</code>。
此外，构造函数注入组件总是以完全初始化的状态返回给客户端，这有利于提高稳定性和可预测性。</p>
<p>另一方面，Setter注入适用于可选的依赖项，可以在类内部设置默认值。
但是，它需要在整个代码库使用依赖性的地方进行额外的<code>null</code>值检查，以处理依赖项未设置的情况。
通过<a href="https://docs.spring.io/spring-framework/reference/integration/jmx.html" target="_blank" rel="noopener noreferrer">JMX MBean</a>进行管理是Setter注入的一个很好的用例。</p>
<p>在某些情况下，选择构造函数注入或Setter注入可能由类本身决定，特别是当处理没有源代码的第三方类时。
例如，如果第三方类没有暴露任何Setter方法，则构造函数注入可能是唯一可用的DI形式。</p>
</div>
<h2>依赖的解析过程</h2>
<p>容器执行Bean依赖解析的步骤如下：</p>
<ol>
<li><strong>容器初始化</strong>：
<ul>
<li><code>ApplicationContext</code> 是 Spring 容器的接口，用于创建和管理 Bean</li>
<li>配置元数据可以是 XML、Java 代码或注解，它们描述了 Bean 的配置信息</li>
</ul>
</li>
<li><strong>依赖表达方式</strong>：
<ul>
<li>依赖可以表达为属性、构造函数参数或静态工厂方法的参数</li>
<li>Spring 会根据依赖表达方式来创建和注入依赖的 Bean</li>
</ul>
</li>
<li><strong>属性和构造函数参数定义</strong>：
<ul>
<li>属性或构造函数参数可以是值的定义，也可以是对容器中另一个 Bean 的引用</li>
<li><strong>属性值转换</strong>：对于值的定义，Spring 会将以字符串格式提供的值转换为所有内置类型，如<code>int</code>、<code>long</code>、<code>String</code>、<code>boolean</code>等等</li>
</ul>
</li>
<li><strong>容器验证和Bean创建</strong>:
<ul>
<li>容器在创建时，会验证每个Bean的配置</li>
<li>容器被创建时，单例作用域并被设置为预实例化的Bean（默认）被创建。
作用域范围在<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html" target="_blank" rel="noopener noreferrer">Bean Scope</a>中定义</li>
<li>非单例Bean只有在被请求时才会被创建</li>
</ul>
</li>
<li><strong>Bean的依赖项解析</strong>：
<ul>
<li>创建Bean可能会导致创建Bean Graph，因为Bean的依赖项及其依赖项的依赖项（以此类推）会被创建和分配</li>
</ul>
</li>
<li><strong>注意⚠️：解析不匹配问题</strong>
<ul>
<li>依赖项之间的解析不匹配可能会在创建受影响的 Bean 时才会出现问题</li>
</ul>
</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">循环依赖</p>
<p>循环依赖是指在使用主要基于构造函数的依赖注入时，可能会创建一个无法解决的循环依赖场景。</p>
<p>例如：Class A通过构造函数注入需要Class B的实例，而Class B通过构造函数注入需要Class A的实例。
如果配置Bean A和Bean B相互注入对方，Spring IoC容器会在运行时检测到这种循环引用，并抛出<code>BeanCurrentlyInCreationException</code>
异常。</p>
<p>解决这种问题的一个可能方法是编辑某些类的源代码，改为通过Setter方法配置，而不是构造函数。
另一个方法是避免构造函数注入，只使用Setter注入。换句话说，虽然不推荐，但你可以通过Setter注入配置循环依赖。</p>
<p>与典型情况（没有循环依赖）不同，Bean A和Bean B之间的循环依赖会导致其中一个Bean在自身完全初始化之前被注入到另一个Bean中（经典的鸡生蛋蛋生鸡的情况）。</p>
</div>
<p><strong>Spring容器的行为</strong>： 通常情况下，你可以相信Spring会做正确的事情。
它在容器加载时检测配置问题，例如引用不存在的Bean或存在循环依赖等。
<strong>异常生成可能性</strong>： Spring会尽可能地延迟设置属性和解析依赖，直到真正创建Bean时才会进行。
这意味着，一个正确加载的Spring容器在请求对象时可能会生成异常；例如在创建该对象或其依赖关系时出现问题，Bean由于缺少或无效属性而抛出异常。
<strong>ApplicationContext的预实例化</strong>： 这种潜在的延迟暴露一些配置的情况，是<code>ApplicationContext</code>实现默认预先实例化单例Bean的原因。
在实际创建这些Bean之前，尽管需要花费一些前期时间和内存代价，但这样做可以在创建<code>ApplicationContext</code>时发现配置问题，而不是之后。
<strong>覆盖默认行为</strong>： 你仍然可以覆盖这种默认行为，使得单例Bean延迟（懒加载）初始化，而不是预先实例化。</p>
<h2>依赖注入的例子</h2>
<h3>Setter依赖注入</h3>
<p>以下示例使用基于XML的配置元数据来实现基于Setter的依赖注入。Spring XML配置文件的一小部分如下所示，指定了一些<code>Bean</code>定义：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 使用嵌套的 ref 元素进行Setter注入 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 使用更简洁的 ref 属性进行Setter注入 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integerProperty<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.AnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.YetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>以下示例展示了相应的<code>ExampleBean</code>类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">AnotherBean</span> beanOne<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">YetAnotherBean</span> beanTwo<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanOne</span><span class="token punctuation">(</span><span class="token class-name">AnotherBean</span> beanOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>beanOne <span class="token operator">=</span> beanOne<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanTwo</span><span class="token punctuation">(</span><span class="token class-name">YetAnotherBean</span> beanTwo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>beanTwo <span class="token operator">=</span> beanTwo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIntegerProperty</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>构造函数依赖注入</h3>
<p>在上面的例子中，Setter 方法被声明来匹配 XML 文件中指定的属性。以下示例使用基于构造函数依赖注入（DI）：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 使用嵌套的ref元素进行构造函数注入 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 使用更简洁的ref属性进行构造函数注入 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.AnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.YetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>对应的<code>ExampleBean</code>类如下所示：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">AnotherBean</span> beanOne<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">YetAnotherBean</span> beanTwo<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span>
        <span class="token class-name">AnotherBean</span> anotherBean<span class="token punctuation">,</span> <span class="token class-name">YetAnotherBean</span> yetAnotherBean<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>beanOne <span class="token operator">=</span> anotherBean<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>beanTwo <span class="token operator">=</span> yetAnotherBean<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>Bean</code>定义中指定的构造函数参数将作为<code>ExampleBean</code>的构造函数参数使用。</p>
<h3>静态工厂方法依赖注入</h3>
<p>现在考虑这个示例的一个变体，在这个变体中，不是使用构造函数，而是告诉 Spring 调用一个静态工厂方法来返回对象的实例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.ExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>createInstance<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anotherExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.AnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yetAnotherBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>examples.YetAnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>以下示例展示了相应的<code>ExampleBean</code>类：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">{</span>

	<span class="token comment">// 私有构造函数</span>
	<span class="token keyword">private</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 静态工厂方法；该方法的参数可以被视为返回的Bean的依赖项，</span>
	<span class="token comment">// 不管这些参数实际上是如何使用的。</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExampleBean</span> createInstance <span class="token punctuation">(</span>
		<span class="token class-name">AnotherBean</span> anotherBean<span class="token punctuation">,</span> <span class="token class-name">YetAnotherBean</span> yetAnotherBean<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token class-name">ExampleBean</span> eb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExampleBean</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 其他操作...</span>
		<span class="token keyword">return</span> eb<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>静态工厂方法的参数由<code>&lt;constructor-arg/&gt;</code>元素提供，与实际使用构造函数时完全相同。
被工厂方法返回的类的类型不一定与包含静态工厂方法的类的类型相同（尽管在这个例子中，它是相同的）。
实例（非静态）工厂方法可以以基本相同的方式使用（除了使用<code>factory-bean</code>属性而不是<code>class</code>属性），因此我们不在此讨论这些细节。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用depends-on</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-dependson.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-dependson.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">使用depends-on</source>
      <description>使用depends-on 如果一个Bean是另一个Bean的依赖项，这意味着一个Bean被设置为另一个Bean的属性。 可以通过&amp;lt;ref/&amp;gt;元素 来实现这一点。 然而，有时Bean之间的依赖关系并不那么直接。 举个例子：当一个类中的静态初始化器需要被触发时，比如数据库驱动程序的注册。 depends-on属性可以强制容器在初始化beanOne Bean...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>如果一个Bean是另一个Bean的依赖项，这意味着一个Bean被设置为另一个Bean的属性。
可以通过<a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-dependson.html#beans-ref-element" target="_blank" rel="noopener noreferrer">&lt;ref/&gt;元素</a>
来实现这一点。 然而，有时Bean之间的依赖关系并不那么直接。</p>
<p>举个例子：当一个类中的静态初始化器需要被触发时，比如数据库驱动程序的注册。
<code>depends-on</code>属性可以强制容器在初始化<code>beanOne</code> Bean之前先初始化指定的<code>manager</code> Bean。
以下示例使用<code>depends-on</code>属性来表达对单个Bean的依赖：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">depends-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ManagerBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>要表达对多个Bean的依赖，可以将多个Bean名称作为<code>depends-on</code>属性的值提供（通过逗号、空格和分号进行分隔）：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExampleBean<span class="token punctuation">"</span></span> <span class="token attr-name">depends-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager,accountDao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ManagerBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.jdbc.JdbcAccountDao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="hint-container note">
<p class="hint-container-title">注</p>
<p><code>depends-on</code>属性不仅可以指定初始化时的依赖关系，而且在
<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-singleton" target="_blank" rel="noopener noreferrer">单例</a>
Bean的情况下，还可以指定相应的销毁时依赖关系。
<code>depends-on</code>指定的依赖Bean会在给定Bean本身被销毁之前被首先销毁。因此，<code>depends-on</code>也可以控制关闭顺序。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>懒加载（Lazy Initialization）Bean</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-lazy-init.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-lazy-init.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">懒加载（Lazy Initialization）Bean</source>
      <description>懒加载（Lazy Initialization）Bean 在Spring框架中，ApplicationContext的默认行为是在启动过程中立即创建并配置所有的单例Bean。 这种做法有利于及时发现配置错误或环境问题，避免了错误在应用运行一段时间后才暴露。 然而，如果需要改变这一行为，可以通过设置Bean定义为懒加载（lazy-initialized）...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>在Spring框架中，<code>ApplicationContext</code>的默认行为是在启动过程中立即创建并配置所有的单例Bean。
这种做法有利于及时发现配置错误或环境问题，避免了错误在应用运行一段时间后才暴露。
然而，如果需要改变这一行为，可以通过设置Bean定义为懒加载（lazy-initialized）来实现。
这样一来，Bean的实例化将被推迟到第一次实际请求该Bean时进行，而不是在应用启动时完成，从而提供了更大的灵活性和控制。</p>
<p>在XML中，通过<code>&lt;bean/&gt;</code>元素上的<code>lazy-init</code>属性来控制这种行为，如下例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 将Bean定义为懒加载 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazy<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.something.ExpensiveToCreateBean<span class="token punctuation">"</span></span> <span class="token attr-name">lazy-init</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 默认立即创建Bean --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>not.lazy<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.something.AnotherBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>当上述配置被<code>ApplicationContext</code>加载启动时，<code>lazy</code> Bean不会立即预实例化，而<code>not.lazy</code> Bean则会被急切地预实例化。</p>
<p>然而，当一个懒加载的Bean作为另一个未标记为懒加载单例Bean的依赖项时，<code>ApplicationContext</code>会在启动时创建这个懒加载的Bean，
因为它必须满足单例Bean的依赖关系。懒加载的Bean会被注入到一个未标记为懒加载的单例Bean中。</p>
<p>你还可以通过在<code>&lt;beans/&gt;</code>元素上使用<code>default-lazy-init</code>属性来控制容器级别的懒加载初始化，如下例所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">default-lazy-init</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- 不会预实例化任何Bean... --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>方法注入</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-method-injection.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-method-injection.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">方法注入</source>
      <description>方法注入 大多数应用场景中，容器中的大多数Bean都是单例（singleton） 的。 当一个单例（singleton）Bean需要与原型（prototype）Bean协作时，传统的注入方式可能不再适用。 这是因为单例Bean在整个应用生命周期内只创建一次，而原型Bean每次请求时都会创建一个新的实例。 一种解决方案是放弃一些控制反转（inversio...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>大多数应用场景中，容器中的大多数Bean都是<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-singleton" target="_blank" rel="noopener noreferrer">单例（singleton）</a>
的。
当一个单例（singleton）Bean需要与原型（prototype）Bean协作时，传统的注入方式可能不再适用。
这是因为单例Bean在整个应用生命周期内只创建一次，而原型Bean每次请求时都会创建一个新的实例。</p>
<p>一种解决方案是放弃一些控制反转（inversion of control）。
通过实现<a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-aware" target="_blank" rel="noopener noreferrer">ApplicationContextAware</a>
接口使Bean A意识到Spring IoC容器 ，并
<a href="https://docs.spring.io/spring-framework/reference/core/beans/basics.html#beans-factory-client" target="_blank" rel="noopener noreferrer">使用容器</a>
进行<code>getBean("B")</code>调用，每次Bean A需要时请求（新建<code>new</code>）Bean B实例。 以下示例展示了这种方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">fiona<span class="token punctuation">.</span>apple</span><span class="token punctuation">;</span>

<span class="token comment">// 导入 Spring 框架相关类</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeansException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ApplicationContext</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ApplicationContextAware</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 使用一个有状态的 Command-style 类来执行一些处理的类。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandManager</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Map</span> commandState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">// 获取一个适当的 Command 的新实例</span>
		<span class="token class-name">Command</span> command <span class="token operator">=</span> <span class="token function">createCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 设置 Command 的状态</span>
		command<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>commandState<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">protected</span> <span class="token class-name">Command</span> <span class="token function">createCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 注意 Spring API 的依赖！</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"command"</span><span class="token punctuation">,</span> <span class="token class-name">Command</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>
			<span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述方法并不理想，因为业务代码意识到并与Spring框架耦合。
方法注入（Method Injection）是Spring IoC容器的一种高级特性，可以干净地处理这种用例。</p>
<blockquote>
<p>你可以在<a href="https://spring.io/blog/2004/08/06/method-injection/" target="_blank" rel="noopener noreferrer">这篇博客文章</a>中阅读更多关于方法注入的动机。</p>
</blockquote>
<h2>查找方法依赖注入</h2>
<h2>任意方法替换</h2>
]]></content:encoded>
    </item>
    <item>
      <title>依赖和配置详解</title>
      <link>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-properties-detailed.html</link>
      <guid>https://www.geekyspace.cn/md/spring-framework/core/dependencies/factory-properties-detailed.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">依赖和配置详解</source>
      <description>依赖和配置详解 正如前一节所述，您可以将Bean属性和构造函数参数定义为对其它托管Bean（协作者）的引用或内联定义的值。 Spring基于XML的配置元数据支持&amp;lt;property/&amp;gt;和&amp;lt;constructor-arg/&amp;gt;元素内的子元素类型，以达到这个目的。 字面值 (基本类型、 String 等) &amp;lt;property/&amp;gt;元素的value属性指定了一个...</description>
      <category>Spring</category>
      <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>正如前一节所述，您可以将<code>Bean</code>属性和构造函数参数定义为对其它<mark>托管Bean（协作者）的引用</mark>或<mark>内联定义的值</mark>。
Spring基于XML的配置元数据支持<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>元素内的子元素类型，以达到这个目的。</p>
<h2>字面值 (基本类型、 String 等)</h2>
<p><code>&lt;property/&gt;</code>元素的<code>value</code>属性指定了一个属性或构造函数参数的可读字符串表示。
Spring使用 <a href="https://docs.spring.io/spring-framework/reference/core/validation/convert.html#core-convert-ConversionService-API" target="_blank" rel="noopener noreferrer">转换服务</a>
来将这些值从字符串转换为属性或参数的实际类型。以下示例展示了设置各种值的方式：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.commons.dbcp.BasicDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 调用 setDriverClassName(String) 方法 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mydb<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>misterkaoli<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>以下示例使用了<a href="#%E4%BD%BF%E7%94%A8p-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84xml%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F">p-命名空间</a>，使得 XML 配置更加简洁：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.commons.dbcp.BasicDataSource<span class="token punctuation">"</span></span>
          <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>driverClassName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mydb<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>username</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>password</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>misterkaoli<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>前面的 XML 更加简洁。但是，拼写错误是在运行时而不是设计时被发现。
除非你使用支持在创建 Bean 定义时进行自动属性完成的集成开发环境（例如<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener noreferrer">IntelliJ IDEA</a>
或<a href="https://spring.io/tools" target="_blank" rel="noopener noreferrer">Spring Tools for Eclipse</a>），强烈建议使用这类 IDE 的帮助。</p>
<p>你也可以配置一个<code>java.util.Properties</code>实例，示例如下：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mappings<span class="token punctuation">"</span></span>
      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.context.support.PropertySourcesPlaceholderConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 作为 java.util.Properties 类型 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>properties<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>Spring容器会利用JavaBeans的<code>PropertyEditor</code>机制，将<code>&lt;value/&gt;</code>元素内的文本转换为<code>java.util.Properties</code>实例。
这是一个很好的快捷方式，Spring团队中在一些场景中更倾向于使用嵌套的<code>&lt;value/&gt;</code>元素而不是<code>value</code>属性的方式。</p>
<h3>idref元素</h3>
<p><code>idref</code>元素仅仅是将容器中另一个<code>Bean</code>的id（一个字符串值，而不是引用）
传递给<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素的一种防错方式。下面的例子展示了如何使用它。</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>theTargetBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>theClientBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>targetName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>idref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>theTargetBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面的 Bean 定义片段（在运行时）与以下代码片段完全等价：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>theTargetBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>client<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>targetName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>theTargetBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>第一种形式比第二种形式好，使用<code>idref</code>标签可以在部署时验证引用的<code>Bean</code>是否存在，
避免在第二种情况下，当实例化时才发现拼写错误或不存在的引用（并且可能导致致命的结果）。这提高了配置文件的可靠性和易读性。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>4.0 版Bean XSD中，不再支持<code>idref</code>元素上的<code>local</code>属性，因为它与常规的Bean引用没有区别。
在升级到4.0模式时，将你现有的<code>idref</code>局部引用改为<code>idref bean</code>。</p>
</div>
<p><code>&lt;idref/&gt;</code>元素带来价值的一个常见地方（至少在早于Spring 2.0的版本中）是在<code>ProxyFactory</code> Bean
定义中配置 <a href="https://docs.spring.io/spring-framework/reference/core/aop-api/pfb.html#aop-pfb-1" target="_blank" rel="noopener noreferrer">AOP interceptor（拦截器）</a>
。当你指定拦截器名称时，使用<code>&lt;idref/&gt;</code>元素可以防止你把拦截器的ID拼错。</p>
<h2>对其他Bean的引用（协作者）</h2>
<p><strong><code>ref</code>元素使用<code>bean</code>属性引用其他Bean</strong></p>
<p><code>ref</code>元素作为<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素的子元素，可以将一个Bean的属性值设置为容器管理的另一个Bean（协作者）的引用。
这个被引用的Bean是依赖项，它将在属性设置之前被初始化。（如果这个协作者Bean是单例的，可能被容器进行预先初始化）
作用域（scope）和验证取决于你是否通过<code>bean</code>或<code>parent</code>属性指定了其他对象的ID或名称。</p>
<p>最常见的使用方式是通过<code>&lt;ref/&gt;</code>标签的<code>bean</code>属性来指定目标Bean。
这样做可以创建对同一容器或父容器中任何<code>Bean</code>的引用，无论它们是否定义在同一个XML文件中。
使用<code>bean</code>属性时，你可以指定目标Bean的<code>id</code>或<code>name</code>属性中的一个值。</p>
<p>以下是一个使用<code>&lt;ref/&gt;</code>元素的例子：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p><strong><code>ref</code>元素使用<code>parent</code>属性引用父容器中的Bean</strong></p>
<p>通过<code>parent</code>属性，可以创建对当前容器的父容器中的Bean的引用。
<code>parent</code>属性的值可以与目标<code>Bean</code>的<code>id</code>属性或<code>name</code>属性中的一个值相同。 目标<code>Bean</code>必须在当前容器的父容器中。
这种方式特别适用于当你有一个容器层次结构，并且希望在子容器中引用父容器中的 Bean 时，且代理具有与父 Bean 具有相同名称的 Bean。</p>
<p>以下是如何使用<code>parent</code>属性的示例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 在父容器中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.something.SimpleAccountService<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 根据需要在此处插入依赖项 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 在子容器（后代）上下文中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">&lt;!--</span> <span class="token attr-name">bean名称与父bean相同</span> <span class="token attr-name">--</span><span class="token punctuation">&gt;</span></span>
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- 注意我们是如何引用父bean的 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 插入其他配置和依赖项 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="hint-container note">
<p class="hint-container-title">注</p>
<p>4.0 版Bean XSD中，<code>ref</code>元素上的<code>local</code>属性不在支持，因为它与常规的Bean引用没有区别。
在升级到4.0模式时，将你现有的<code>ref</code>局部引用改为<code>idref bean</code>。</p>
</div>
<h2>内部 Bean</h2>
<p>在<code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素内部使用<code>&lt;bean/&gt;</code>元素定义了一个内部Bean，如下例所示。</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 不使用对目标 Bean 的引用，而是直接内联定义目标 Bean --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.Person<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 这是内部 Bean --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Fiona Apple<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>内部Bean定义不需要指定ID或名称。如果指定了，容器不会将它们作标识符。
容器在创建时也会忽略作用域（scope）标志，因为内部Bean总是匿名的，并且始终与外部Bean一起创建。
无法独立地访问内部Bean，也无法将其注入到除封闭Bean之外的其他协作Bean中。</p>
<p>作为一个特例，可以从自定义作用域（scope）中接收销毁回调，例如，对于包含在单例Bean中的请求作用域（scope）的内层Bean。
内层Bean实例的创建与其包含的Bean相关联，但是销毁回调允许它参与到请求作用域（scope）的生命周期中。
这并不是一种常见的情况。内层Bean通常只是简单地共享其包含Bean的作用域（scope）。</p>
<h2>集合（Collection）</h2>
<p><code>&lt;list/&gt;</code>、<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code> 元素分别用于设置 Java 集合类型<code>List</code>、<code>Set</code>、<code>Map</code>和<code>Properties</code>的属性和参数。</p>
<p>以下示例展示了如何使用它们：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>moreComplexObject<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.ComplexObject<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 调用 setAdminEmails(java.util.Properties) 方法 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>adminEmails<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>administrator<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>administrator@example.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>support<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>support@example.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>development@example.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 调用 setSomeList(java.util.List) 方法 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someList<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>a list element followed by a reference<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 调用 setSomeMap(java.util.Map) 方法 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>an entry<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>just some string<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a ref<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 调用 setSomeSet(java.util.Set) 方法 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someSet<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>just some string<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myDataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>Map</code>的键值对中的值、或者<code>Set</code>中的元素，可以是以下任一元素：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>bean | ref | idref | list | set | map | props | value | null
</code></pre></div><h3>集合合并（merging）</h3>
<p>Spring 容器还支持集合合并。开发者可以定义一个父级<code>&lt;list/&gt;</code>、<code>&lt;map/&gt;</code>、<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，
并让子级<code>&lt;list/&gt;</code>、<code>&lt;map/&gt;</code>、<code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code>元素继承并覆盖父集合中的值。</p>
<p>也就是说，子集合的值是合并父子集合的元素后的结果，其中子集合的元素会覆盖在父集合中指定的值。
这部分关于合并（merging）的内容讨论了父子Bean机制。对于不熟悉父子Bean定义的读者，建议在继续阅读之前阅读<a href="https://docs.spring.io/spring-framework/reference/core/beans/child-bean-definitions.html" target="_blank" rel="noopener noreferrer">相关章节</a>。</p>
<p>以下示例演示了集合合并（merging）：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 父 Bean 定义 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span> <span class="token attr-name">abstract</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.ComplexObject<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>adminEmails<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>administrator<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>administrator@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>support<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>support@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 子 Bean 继承父 Bean 定义 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>adminEmails<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- merge 在子集合定义上进行了指定 --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span> <span class="token attr-name">merge</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sales<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>sales@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>support<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>support@example.co.uk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>请注意，在子Bean定义的<code>adminEmails</code>属性的<code>&lt;props/&gt;</code>元素上使用了<code>merge=true</code>属性。
当容器解析并实例化子Bean时，生成的实例具有一个<code>adminEmails Properties</code>集合，
该集合是合并子Bean的 <code>adminEmails</code>集合与父Bean的<code>adminEmails</code>集合的结果。</p>
<p>以下列表显示了合并的结果：</p>
<div class="language-properties" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">administrator</span><span class="token punctuation">=</span><span class="token value attr-value">administrator@example.com</span>
<span class="token key attr-name">sales</span><span class="token punctuation">=</span><span class="token value attr-value">sales@example.com</span>
<span class="token key attr-name">support</span><span class="token punctuation">=</span><span class="token value attr-value">support@example.co.uk</span>
</code></pre></div><p>子代<code>Properties</code>集合的值集继承了父<code>&lt;props/&gt;</code>中的所有属性元素，并且子集合中对于<code>support</code>键的值会覆盖父代集合中的值。</p>
<p>这种合并行为同样适用于<code>&lt;list/&gt;</code>、<code>&lt;map/&gt;</code> 和 <code>&lt;set/&gt;</code>等集合类型。在<code>&lt;list/&gt;</code>元素的特定情况下，与List集合类型相关的语义（即有序值集合的概念）被保留。
父集合的值位于子列表所有值之前。对于Map、Set和Properties集合类型，不存在任何排序。因此，在容器内部使用的关于
Map、Set和Properties实现的集合类型，没有排序语义。</p>
<h3>集合合并的限制</h3>
<p>你不能合并不同的集合类型（例如 Map 和 List）。如果你试图这样做，会抛出一个适当的<code>Exception</code>异常。
合并属性（merge attribute）必须在较低层级、被继承的子定义上指定。
在父级集合定义上指定<code>merge</code>属性是多余的，不会产生期望的合并行为。</p>
<h3>强类型集合</h3>
<p>得益于Java的泛型特性，你能够创建特定类型的强类型的集合（Collection）。
例如，可以声明一个Collection类型，使其只能包含（例如）String元素。
当你通过Spring进行依赖注入时，Spring的类型转换功能将确保Collection中的元素在添加之前被自动转换为正确的类型。</p>
<p>以下示例 Java 类和 Bean 定义展示了如何实现这一点：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Float</span><span class="token punctuation">&gt;</span></span> accounts<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAccounts</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Float</span><span class="token punctuation">&gt;</span></span> accounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>accounts <span class="token operator">=</span> accounts<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>something<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.SomeClass<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accounts<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>one<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>9.99<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>two<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.75<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>six<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3.99<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>当准备注入<code>something</code> Bean 的<code>accounts</code>属性时，关于强类型<code>Map&lt;String, Float&gt;</code>的元素类型的泛型信息可通过反射获得。
因此，Spring 的类型转换基础设施能够识别出这些值元素属于 <code>Float</code> 类型，并将字符串值（9.99、2.75 和 3.99）转换为实际的 <code>Float</code> 类型。</p>
<h2>Null和空字符串值</h2>
<p>Spring 将属性等的空参数视为空字符串。下面这个基于XML的配置元数据片段将<code>email</code>属性设置为空字符串值（<code>""</code>）。</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上述示例等同于以下Java代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>exampleBean<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>使用 p-命名空间</h2>
<p>p-命名空间提供了一种便捷的XML配置方式，允许你直接在<code>bean</code>
元素的属性中定义属性值或引用其他Bean，而无需使用嵌套的<code>&lt;property/&gt;</code>标签。</p>
<p>Spring框架支持通过XML Schema定义的扩展配置格式和命名空间。
虽然<code>beans</code>的配置格式在XML Schema文档中有所定义，但p-命名空间并未在XSD文件中声明，它是Spring框架内部的一个特性。</p>
<p><strong>简化bean属性设置</strong></p>
<p>以下是一个示例，展示了两种不同的XML配置片段（标准XML格式和使用p-命名空间的格式），它们将产生相同的配置结果：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 用于bean设置的标准XML配置 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classic<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.ExampleBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someone@somewhere.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 用于bean设置的p-命名空间快捷方式 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p-namespace<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.ExampleBean<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>email</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>someone@somewhere.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这个示例展示了在Bean定义中，p-命名空间中有一个名为<code>email</code>的属性。这告诉Spring要包含一个属性声明。
如前所述，p-命名空间没有Schema定义，所以你可以直接使用属性名作为属性值，而无需按照常规方式指定属性值。</p>
<p><strong>简化bean属性引用</strong></p>
<p>以下示例包含了两个bean定义，它们都引用了另一个bean：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 用于bean引用的标准XML配置 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>john-classic<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.Person<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>John Doe<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>spouse<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jane<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- 用于bean引用的p-命名空间快捷方式 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>john-modern<span class="token punctuation">"</span></span>
          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.Person<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>John Doe<span class="token punctuation">"</span></span>
          <span class="token attr-name"><span class="token namespace">p:</span>spouse-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jane<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>

    <span class="token comment">&lt;!-- 另一个bean定义，名称为jane --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jane<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.Person<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Jane Doe<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>此示例不仅使用p-命名空间声明了属性值，还使用了一种特殊的格式来声明属性的引用。
第一个bean定义使用了传统的</p>
<ul>
<li><code>p:name</code>：这是使用p-命名空间设置name属性值的简洁方式</li>
<li><code>p:spouse-ref</code>：这是使用p-命名空间声明spouse属性的引用，<code>-ref</code>后跟被引用Bean</li>
</ul>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>注意⚠️：p-命名空间不如标准XML格式灵活。例如，声明属性引用的格式与以<code>Ref</code>结尾的属性发生冲突，而标准XML格式则不会。
我们建议你谨慎选择这种方式，并将此决策传达给你的团队成员，以避免同时使用这三种格式的XML文档。</p>
</div>
<h2>使用 c-命名空间</h2>
<p>与带有<a href="#%E4%BD%BF%E7%94%A8-p-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">p-命名空间的XML快捷方式</a>类似，
Spring 3.1中引入的c-命名空间，允许使用内联属性来配置构造函数参数，而不是嵌套的<code>constructor-arg</code>元素。</p>
<p>以下示例使用c-命名空间来实现与基于构造函数依赖注入相同的功能：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
	<span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
	<span class="token attr-name"><span class="token namespace">xmlns:</span>c</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/c<span class="token punctuation">"</span></span>
	<span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingTwo<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingThree<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>

	<span class="token comment">&lt;!-- 传统的声明，可以使用可选的参数名称 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingOne<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>thingTwo<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>thingThree<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>something@somewhere.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

	<span class="token comment">&lt;!-- 使用c-命名空间声明参数名称 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingOne<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">c:</span>thingTwo-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span>
		<span class="token attr-name"><span class="token namespace">c:</span>thingThree-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">c:</span>email</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>something@somewhere.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>c-命名空间与p-命名空间使用相同的约定（以<code>-ref</code>结尾表示Bean引用）来通过名称设置构造函数参数。
同样，即使c-命名空间在XSD模式中未定义（它存在于Spring核心中），但在XML文件中仍然需要声明。</p>
<p>对于构造函数参数名称不可用的罕见情况（通常是因为字节码是在没有调试debug信息的情况下编译的），可以使用参数索引（下标）作为备用，如下所示：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- c-namespace索引声明 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanOne<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x.y.ThingOne<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">c:</span>_0-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanTwo<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">c:</span>_1-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beanThree<span class="token punctuation">"</span></span>
      <span class="token attr-name"><span class="token namespace">c:</span>_2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>something@somewhere.com<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="hint-container note">
<p class="hint-container-title">注</p>
<p>由于XML语法限制，索引表示法需要以下划线（_）开头，因为XML属性名不能以数字开头（尽管一些IDE允许这样做）。
对于<code>&lt;constructor-arg&gt;</code>元素，也有相应的索引表示法可用，但并不常用，因为通常情况下，普通的声明顺序已经足够了。</p>
</div>
<p>在实践中，构造函数解析机制在匹配参数方面非常高效，因此除非确实需要，我们建议在整个配置中始终使用名称标记。</p>
<h2>复合属性名</h2>
<p>在设置Bean属性时，只要路径中除最终属性名外的所有组件不为null，就可以使用复合或嵌套的属性名称。以下是一个Bean定义的示例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>something<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>things.ThingOne<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fred.bob.sammy<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在这个示例中，<code>something</code> Bean有一个<code>fred</code>属性，该属性又有一个<code>bob</code>属性，属性下又有一个<code>sammy</code>属性，最终<code>sammy</code>属性被设置为值 123。
为了使这个设置生效，除了最终的属性名<code>sammy</code>外，要保证路径中的所有属性不为 <code>null</code>。否则，将抛出 NullPointerException 异常。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>